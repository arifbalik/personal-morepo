<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>A Practical Guide to Zephyr Device Driver Development</title>
  <style>
    @media (prefers-color-scheme:dark) {

      .markdown-body,
      [data-theme=dark] {
        color-scheme: dark;
        --color-prettylights-syntax-comment: #8b949e;
        --color-prettylights-syntax-constant: #79c0ff;
        --color-prettylights-syntax-entity: #d2a8ff;
        --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
        --color-prettylights-syntax-entity-tag: #7ee787;
        --color-prettylights-syntax-keyword: #ff7b72;
        --color-prettylights-syntax-string: #a5d6ff;
        --color-prettylights-syntax-variable: #ffa657;
        --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
        --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
        --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
        --color-prettylights-syntax-carriage-return-text: #f0f6fc;
        --color-prettylights-syntax-carriage-return-bg: #b62324;
        --color-prettylights-syntax-string-regexp: #7ee787;
        --color-prettylights-syntax-markup-list: #f2cc60;
        --color-prettylights-syntax-markup-heading: #1f6feb;
        --color-prettylights-syntax-markup-italic: #c9d1d9;
        --color-prettylights-syntax-markup-bold: #c9d1d9;
        --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
        --color-prettylights-syntax-markup-deleted-bg: #67060c;
        --color-prettylights-syntax-markup-inserted-text: #aff5b4;
        --color-prettylights-syntax-markup-inserted-bg: #033a16;
        --color-prettylights-syntax-markup-changed-text: #ffdfb6;
        --color-prettylights-syntax-markup-changed-bg: #5a1e02;
        --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
        --color-prettylights-syntax-markup-ignored-bg: #1158c7;
        --color-prettylights-syntax-meta-diff-range: #d2a8ff;
        --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
        --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
        --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
        --color-fg-default: #e6edf3;
        --color-fg-muted: #848d97;
        --color-fg-subtle: #6e7681;
        --color-canvas-default: #0d1117;
        --color-canvas-subtle: #161b22;
        --color-border-default: #30363d;
        --color-border-muted: #21262d;
        --color-neutral-muted: rgba(110, 118, 129, 0.4);
        --color-accent-fg: #2f81f7;
        --color-accent-emphasis: #1f6feb;
        --color-success-fg: #3fb950;
        --color-success-emphasis: #238636;
        --color-attention-fg: #d29922;
        --color-attention-emphasis: #9e6a03;
        --color-attention-subtle: rgba(187, 128, 9, 0.15);
        --color-danger-fg: #f85149;
        --color-danger-emphasis: #da3633;
        --color-done-fg: #a371f7;
        --color-done-emphasis: #8957e5
      }
    }

    @media (prefers-color-scheme:light) {

      .markdown-body,
      [data-theme=light] {
        color-scheme: light;
        --color-prettylights-syntax-comment: #57606a;
        --color-prettylights-syntax-constant: #0550ae;
        --color-prettylights-syntax-entity: #6639ba;
        --color-prettylights-syntax-storage-modifier-import: #24292f;
        --color-prettylights-syntax-entity-tag: #116329;
        --color-prettylights-syntax-keyword: #cf222e;
        --color-prettylights-syntax-string: #0a3069;
        --color-prettylights-syntax-variable: #953800;
        --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
        --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
        --color-prettylights-syntax-invalid-illegal-bg: #82071e;
        --color-prettylights-syntax-carriage-return-text: #f6f8fa;
        --color-prettylights-syntax-carriage-return-bg: #cf222e;
        --color-prettylights-syntax-string-regexp: #116329;
        --color-prettylights-syntax-markup-list: #3b2300;
        --color-prettylights-syntax-markup-heading: #0550ae;
        --color-prettylights-syntax-markup-italic: #24292f;
        --color-prettylights-syntax-markup-bold: #24292f;
        --color-prettylights-syntax-markup-deleted-text: #82071e;
        --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
        --color-prettylights-syntax-markup-inserted-text: #116329;
        --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
        --color-prettylights-syntax-markup-changed-text: #953800;
        --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
        --color-prettylights-syntax-markup-ignored-text: #eaeef2;
        --color-prettylights-syntax-markup-ignored-bg: #0550ae;
        --color-prettylights-syntax-meta-diff-range: #8250df;
        --color-prettylights-syntax-brackethighlighter-angle: #57606a;
        --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
        --color-prettylights-syntax-constant-other-reference-link: #0a3069;
        --color-fg-default: #1F2328;
        --color-fg-muted: #656d76;
        --color-fg-subtle: #6e7781;
        --color-canvas-default: #ffffff;
        --color-canvas-subtle: #f6f8fa;
        --color-border-default: #d0d7de;
        --color-border-muted: hsla(210, 18%, 87%, 1);
        --color-neutral-muted: rgba(175, 184, 193, 0.2);
        --color-accent-fg: #0969da;
        --color-accent-emphasis: #0969da;
        --color-success-fg: #1a7f37;
        --color-success-emphasis: #1f883d;
        --color-attention-fg: #9a6700;
        --color-attention-emphasis: #9a6700;
        --color-attention-subtle: #fff8c5;
        --color-danger-fg: #d1242f;
        --color-danger-emphasis: #cf222e;
        --color-done-fg: #8250df;
        --color-done-emphasis: #8250df
      }
    }

    .markdown-body {
      -ms-text-size-adjust: 100%;
      -webkit-text-size-adjust: 100%;
      margin: 0;
      color: var(--color-fg-default);
      background-color: var(--color-canvas-default);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
      font-size: 16px;
      line-height: 1.5;
      word-wrap: break-word
    }

    .markdown-body .octicon {
      display: inline-block;
      fill: currentColor;
      vertical-align: text-bottom
    }

    .markdown-body h1:hover .anchor .octicon-link:before,
    .markdown-body h2:hover .anchor .octicon-link:before,
    .markdown-body h3:hover .anchor .octicon-link:before,
    .markdown-body h4:hover .anchor .octicon-link:before,
    .markdown-body h5:hover .anchor .octicon-link:before,
    .markdown-body h6:hover .anchor .octicon-link:before {
      width: 16px;
      height: 16px;
      content: ' ';
      display: inline-block;
      background-color: currentColor;
      -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
      mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>")
    }

    .markdown-body details,
    .markdown-body figcaption,
    .markdown-body figure {
      display: block
    }

    .markdown-body summary {
      display: list-item
    }

    .markdown-body [hidden] {
      display: none !important
    }

    .markdown-body a {
      background-color: transparent;
      color: var(--color-accent-fg);
      text-decoration: none
    }

    .markdown-body abbr[title] {
      border-bottom: none;
      -webkit-text-decoration: underline dotted;
      text-decoration: underline dotted
    }

    .markdown-body b,
    .markdown-body strong {
      font-weight: var(--base-text-weight-semibold, 600)
    }

    .markdown-body dfn {
      font-style: italic
    }

    .markdown-body h1 {
      margin: .67em 0;
      font-weight: var(--base-text-weight-semibold, 600);
      padding-bottom: .3em;
      font-size: 2em;
      border-bottom: 1px solid var(--color-border-muted)
    }

    .markdown-body mark {
      background-color: var(--color-attention-subtle);
      color: var(--color-fg-default)
    }

    .markdown-body small {
      font-size: 90%
    }

    .markdown-body sub,
    .markdown-body sup {
      font-size: 75%;
      line-height: 0;
      position: relative;
      vertical-align: baseline
    }

    .markdown-body sub {
      bottom: -.25em
    }

    .markdown-body sup {
      top: -.5em
    }

    .markdown-body img {
      border-style: none;
      max-width: 100%;
      box-sizing: content-box;
      background-color: var(--color-canvas-default)
    }

    .markdown-body code,
    .markdown-body kbd,
    .markdown-body pre,
    .markdown-body samp {
      font-family: monospace;
      font-size: 1em
    }

    .markdown-body figure {
      margin: 1em 40px
    }

    .markdown-body hr {
      box-sizing: content-box;
      overflow: hidden;
      background: 0 0;
      border-bottom: 1px solid var(--color-border-muted);
      height: .25em;
      padding: 0;
      margin: 24px 0;
      background-color: var(--color-border-default);
      border: 0
    }

    .markdown-body input {
      font: inherit;
      margin: 0;
      overflow: visible;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit
    }

    .markdown-body [type=button],
    .markdown-body [type=reset],
    .markdown-body [type=submit] {
      -webkit-appearance: button;
      appearance: button
    }

    .markdown-body [type=checkbox],
    .markdown-body [type=radio] {
      box-sizing: border-box;
      padding: 0
    }

    .markdown-body [type=number]::-webkit-inner-spin-button,
    .markdown-body [type=number]::-webkit-outer-spin-button {
      height: auto
    }

    .markdown-body [type=search]::-webkit-search-cancel-button,
    .markdown-body [type=search]::-webkit-search-decoration {
      -webkit-appearance: none;
      appearance: none
    }

    .markdown-body ::-webkit-input-placeholder {
      color: inherit;
      opacity: .54
    }

    .markdown-body ::-webkit-file-upload-button {
      -webkit-appearance: button;
      appearance: button;
      font: inherit
    }

    .markdown-body a:hover {
      text-decoration: underline
    }

    .markdown-body ::placeholder {
      color: var(--color-fg-subtle);
      opacity: 1
    }

    .markdown-body hr::before {
      display: table;
      content: ""
    }

    .markdown-body hr::after {
      display: table;
      clear: both;
      content: ""
    }

    .markdown-body table {
      border-spacing: 0;
      border-collapse: collapse;
      display: block;
      width: max-content;
      max-width: 100%;
      overflow: auto
    }

    .markdown-body td,
    .markdown-body th {
      padding: 0
    }

    .markdown-body details summary {
      cursor: pointer
    }

    .markdown-body details:not([open])>:not(summary) {
      display: none !important
    }

    .markdown-body [role=button]:focus,
    .markdown-body a:focus,
    .markdown-body input[type=checkbox]:focus,
    .markdown-body input[type=radio]:focus {
      outline: 2px solid var(--color-accent-fg);
      outline-offset: -2px;
      box-shadow: none
    }

    .markdown-body [role=button]:focus:not(:focus-visible),
    .markdown-body a:focus:not(:focus-visible),
    .markdown-body input[type=checkbox]:focus:not(:focus-visible),
    .markdown-body input[type=radio]:focus:not(:focus-visible) {
      outline: solid 1px transparent
    }

    .markdown-body [role=button]:focus-visible,
    .markdown-body a:focus-visible,
    .markdown-body input[type=checkbox]:focus-visible,
    .markdown-body input[type=radio]:focus-visible {
      outline: 2px solid var(--color-accent-fg);
      outline-offset: -2px;
      box-shadow: none
    }

    .markdown-body a:not([class]):focus,
    .markdown-body a:not([class]):focus-visible,
    .markdown-body input[type=checkbox]:focus,
    .markdown-body input[type=checkbox]:focus-visible,
    .markdown-body input[type=radio]:focus,
    .markdown-body input[type=radio]:focus-visible {
      outline-offset: 0
    }

    .markdown-body kbd {
      display: inline-block;
      padding: 3px 5px;
      font: 11px ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
      line-height: 10px;
      color: var(--color-fg-default);
      vertical-align: middle;
      background-color: var(--color-canvas-subtle);
      border: solid 1px var(--color-neutral-muted);
      border-bottom-color: var(--color-neutral-muted);
      border-radius: 6px;
      box-shadow: inset 0 -1px 0 var(--color-neutral-muted)
    }

    .markdown-body h1,
    .markdown-body h2,
    .markdown-body h3,
    .markdown-body h4,
    .markdown-body h5,
    .markdown-body h6 {
      margin-top: 24px;
      margin-bottom: 16px;
      font-weight: var(--base-text-weight-semibold, 600);
      line-height: 1.25
    }

    .markdown-body h2 {
      font-weight: var(--base-text-weight-semibold, 600);
      padding-bottom: .3em;
      font-size: 1.5em;
      border-bottom: 1px solid var(--color-border-muted)
    }

    .markdown-body h3 {
      font-weight: var(--base-text-weight-semibold, 600);
      font-size: 1.25em
    }

    .markdown-body h4 {
      font-weight: var(--base-text-weight-semibold, 600);
      font-size: 1em
    }

    .markdown-body h5 {
      font-weight: var(--base-text-weight-semibold, 600);
      font-size: .875em
    }

    .markdown-body h6 {
      font-weight: var(--base-text-weight-semibold, 600);
      font-size: .85em;
      color: var(--color-fg-muted)
    }

    .markdown-body p {
      margin-top: 0;
      margin-bottom: 10px
    }

    .markdown-body blockquote {
      margin: 0;
      padding: 0 1em;
      color: var(--color-fg-muted);
      border-left: .25em solid var(--color-border-default)
    }

    .markdown-body ol,
    .markdown-body ul {
      margin-top: 0;
      margin-bottom: 0;
      padding-left: 2em
    }

    .markdown-body ol ol,
    .markdown-body ul ol {
      list-style-type: lower-roman
    }

    .markdown-body ol ol ol,
    .markdown-body ol ul ol,
    .markdown-body ul ol ol,
    .markdown-body ul ul ol {
      list-style-type: lower-alpha
    }

    .markdown-body dd {
      margin-left: 0
    }

    .markdown-body code,
    .markdown-body samp,
    .markdown-body tt {
      font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
      font-size: 12px
    }

    .markdown-body pre {
      margin-top: 0;
      margin-bottom: 0;
      font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
      font-size: 12px;
      word-wrap: normal
    }

    .markdown-body .octicon {
      display: inline-block;
      overflow: visible !important;
      vertical-align: text-bottom;
      fill: currentColor
    }

    .markdown-body input::-webkit-inner-spin-button,
    .markdown-body input::-webkit-outer-spin-button {
      margin: 0;
      -webkit-appearance: none;
      appearance: none
    }

    .markdown-body .mr-2 {
      margin-right: var(--base-size-8, 8px) !important
    }

    .markdown-body::before {
      display: table;
      content: ""
    }

    .markdown-body::after {
      display: table;
      clear: both;
      content: ""
    }

    .markdown-body>:first-child {
      margin-top: 0 !important
    }

    .markdown-body>:last-child {
      margin-bottom: 0 !important
    }

    .markdown-body a:not([href]) {
      color: inherit;
      text-decoration: none
    }

    .markdown-body .absent {
      color: var(--color-danger-fg)
    }

    .markdown-body .anchor {
      float: left;
      padding-right: 4px;
      margin-left: -20px;
      line-height: 1
    }

    .markdown-body .anchor:focus {
      outline: 0
    }

    .markdown-body blockquote,
    .markdown-body details,
    .markdown-body dl,
    .markdown-body ol,
    .markdown-body p,
    .markdown-body pre,
    .markdown-body table,
    .markdown-body ul {
      margin-top: 0;
      margin-bottom: 16px
    }

    .markdown-body blockquote>:first-child {
      margin-top: 0
    }

    .markdown-body blockquote>:last-child {
      margin-bottom: 0
    }

    .markdown-body h1 .octicon-link,
    .markdown-body h2 .octicon-link,
    .markdown-body h3 .octicon-link,
    .markdown-body h4 .octicon-link,
    .markdown-body h5 .octicon-link,
    .markdown-body h6 .octicon-link {
      color: var(--color-fg-default);
      vertical-align: middle;
      visibility: hidden
    }

    .markdown-body h1:hover .anchor,
    .markdown-body h2:hover .anchor,
    .markdown-body h3:hover .anchor,
    .markdown-body h4:hover .anchor,
    .markdown-body h5:hover .anchor,
    .markdown-body h6:hover .anchor {
      text-decoration: none
    }

    .markdown-body h1:hover .anchor .octicon-link,
    .markdown-body h2:hover .anchor .octicon-link,
    .markdown-body h3:hover .anchor .octicon-link,
    .markdown-body h4:hover .anchor .octicon-link,
    .markdown-body h5:hover .anchor .octicon-link,
    .markdown-body h6:hover .anchor .octicon-link {
      visibility: visible
    }

    .markdown-body h1 code,
    .markdown-body h1 tt,
    .markdown-body h2 code,
    .markdown-body h2 tt,
    .markdown-body h3 code,
    .markdown-body h3 tt,
    .markdown-body h4 code,
    .markdown-body h4 tt,
    .markdown-body h5 code,
    .markdown-body h5 tt,
    .markdown-body h6 code,
    .markdown-body h6 tt {
      padding: 0 .2em;
      font-size: inherit
    }

    .markdown-body summary h1,
    .markdown-body summary h2,
    .markdown-body summary h3,
    .markdown-body summary h4,
    .markdown-body summary h5,
    .markdown-body summary h6 {
      display: inline-block
    }

    .markdown-body summary h1 .anchor,
    .markdown-body summary h2 .anchor,
    .markdown-body summary h3 .anchor,
    .markdown-body summary h4 .anchor,
    .markdown-body summary h5 .anchor,
    .markdown-body summary h6 .anchor {
      margin-left: -40px
    }

    .markdown-body summary h1,
    .markdown-body summary h2 {
      padding-bottom: 0;
      border-bottom: 0
    }

    .markdown-body ol.no-list,
    .markdown-body ul.no-list {
      padding: 0;
      list-style-type: none
    }

    .markdown-body ol[type="a s"] {
      list-style-type: lower-alpha
    }

    .markdown-body ol[type="A s"] {
      list-style-type: upper-alpha
    }

    .markdown-body ol[type="i s"] {
      list-style-type: lower-roman
    }

    .markdown-body ol[type="I s"] {
      list-style-type: upper-roman
    }

    .markdown-body ol[type="1"] {
      list-style-type: decimal
    }

    .markdown-body div>ol:not([type]) {
      list-style-type: decimal
    }

    .markdown-body ol ol,
    .markdown-body ol ul,
    .markdown-body ul ol,
    .markdown-body ul ul {
      margin-top: 0;
      margin-bottom: 0
    }

    .markdown-body li>p {
      margin-top: 16px
    }

    .markdown-body li+li {
      margin-top: .25em
    }

    .markdown-body dl {
      padding: 0
    }

    .markdown-body dl dt {
      padding: 0;
      margin-top: 16px;
      font-size: 1em;
      font-style: italic;
      font-weight: var(--base-text-weight-semibold, 600)
    }

    .markdown-body dl dd {
      padding: 0 16px;
      margin-bottom: 16px
    }

    .markdown-body table th {
      font-weight: var(--base-text-weight-semibold, 600)
    }

    .markdown-body table td,
    .markdown-body table th {
      padding: 6px 13px;
      border: 1px solid var(--color-border-default)
    }

    .markdown-body table td>:last-child {
      margin-bottom: 0
    }

    .markdown-body table tr {
      background-color: var(--color-canvas-default);
      border-top: 1px solid var(--color-border-muted)
    }

    .markdown-body table tr:nth-child(2n) {
      background-color: var(--color-canvas-subtle)
    }

    .markdown-body table img {
      background-color: transparent
    }

    .markdown-body img[align=right] {
      padding-left: 20px
    }

    .markdown-body img[align=left] {
      padding-right: 20px
    }

    .markdown-body .emoji {
      max-width: none;
      vertical-align: text-top;
      background-color: transparent
    }

    .markdown-body span.frame {
      display: block;
      overflow: hidden
    }

    .markdown-body span.frame>span {
      display: block;
      float: left;
      width: auto;
      padding: 7px;
      margin: 13px 0 0;
      overflow: hidden;
      border: 1px solid var(--color-border-default)
    }

    .markdown-body span.frame span img {
      display: block;
      float: left
    }

    .markdown-body span.frame span span {
      display: block;
      padding: 5px 0 0;
      clear: both;
      color: var(--color-fg-default)
    }

    .markdown-body span.align-center {
      display: block;
      overflow: hidden;
      clear: both
    }

    .markdown-body span.align-center>span {
      display: block;
      margin: 13px auto 0;
      overflow: hidden;
      text-align: center
    }

    .markdown-body span.align-center span img {
      margin: 0 auto;
      text-align: center
    }

    .markdown-body span.align-right {
      display: block;
      overflow: hidden;
      clear: both
    }

    .markdown-body span.align-right>span {
      display: block;
      margin: 13px 0 0;
      overflow: hidden;
      text-align: right
    }

    .markdown-body span.align-right span img {
      margin: 0;
      text-align: right
    }

    .markdown-body span.float-left {
      display: block;
      float: left;
      margin-right: 13px;
      overflow: hidden
    }

    .markdown-body span.float-left span {
      margin: 13px 0 0
    }

    .markdown-body span.float-right {
      display: block;
      float: right;
      margin-left: 13px;
      overflow: hidden
    }

    .markdown-body span.float-right>span {
      display: block;
      margin: 13px auto 0;
      overflow: hidden;
      text-align: right
    }

    .markdown-body code,
    .markdown-body tt {
      padding: .2em .4em;
      margin: 0;
      font-size: 85%;
      white-space: break-spaces;
      background-color: var(--color-neutral-muted);
      border-radius: 6px
    }

    .markdown-body code br,
    .markdown-body tt br {
      display: none
    }

    .markdown-body del code {
      text-decoration: inherit
    }

    .markdown-body samp {
      font-size: 85%
    }

    .markdown-body pre code {
      font-size: 100%
    }

    .markdown-body pre>code {
      padding: 0;
      margin: 0;
      word-break: normal;
      white-space: pre;
      background: 0 0;
      border: 0
    }

    .markdown-body .highlight {
      margin-bottom: 16px
    }

    .markdown-body .highlight pre {
      margin-bottom: 0;
      word-break: normal
    }

    .markdown-body .highlight pre,
    .markdown-body pre {
      padding: 16px;
      overflow: auto;
      font-size: 85%;
      line-height: 1.45;
      color: var(--color-fg-default);
      background-color: var(--color-canvas-subtle);
      border-radius: 6px
    }

    .markdown-body pre code,
    .markdown-body pre tt {
      display: inline;
      max-width: auto;
      padding: 0;
      margin: 0;
      overflow: visible;
      line-height: inherit;
      word-wrap: normal;
      background-color: transparent;
      border: 0
    }

    .markdown-body .csv-data td,
    .markdown-body .csv-data th {
      padding: 5px;
      overflow: hidden;
      font-size: 12px;
      line-height: 1;
      text-align: left;
      white-space: nowrap
    }

    .markdown-body .csv-data .blob-num {
      padding: 10px 8px 9px;
      text-align: right;
      background: var(--color-canvas-default);
      border: 0
    }

    .markdown-body .csv-data tr {
      border-top: 0
    }

    .markdown-body .csv-data th {
      font-weight: var(--base-text-weight-semibold, 600);
      background: var(--color-canvas-subtle);
      border-top: 0
    }

    .markdown-body [data-footnote-ref]::before {
      content: "["
    }

    .markdown-body [data-footnote-ref]::after {
      content: "]"
    }

    .markdown-body .footnotes {
      font-size: 12px;
      color: var(--color-fg-muted);
      border-top: 1px solid var(--color-border-default)
    }

    .markdown-body .footnotes ol {
      padding-left: 16px
    }

    .markdown-body .footnotes ol ul {
      display: inline-block;
      padding-left: 16px;
      margin-top: 16px
    }

    .markdown-body .footnotes li {
      position: relative
    }

    .markdown-body .footnotes li:target::before {
      position: absolute;
      top: -8px;
      right: -8px;
      bottom: -8px;
      left: -24px;
      pointer-events: none;
      content: "";
      border: 2px solid var(--color-accent-emphasis);
      border-radius: 6px
    }

    .markdown-body .footnotes li:target {
      color: var(--color-fg-default)
    }

    .markdown-body .footnotes .data-footnote-backref g-emoji {
      font-family: monospace
    }

    .markdown-body .pl-c {
      color: var(--color-prettylights-syntax-comment)
    }

    .markdown-body .pl-c1,
    .markdown-body .pl-s .pl-v {
      color: var(--color-prettylights-syntax-constant)
    }

    .markdown-body .pl-e,
    .markdown-body .pl-en {
      color: var(--color-prettylights-syntax-entity)
    }

    .markdown-body .pl-s .pl-s1,
    .markdown-body .pl-smi {
      color: var(--color-prettylights-syntax-storage-modifier-import)
    }

    .markdown-body .pl-ent {
      color: var(--color-prettylights-syntax-entity-tag)
    }

    .markdown-body .pl-k {
      color: var(--color-prettylights-syntax-keyword)
    }

    .markdown-body .pl-pds,
    .markdown-body .pl-s,
    .markdown-body .pl-s .pl-pse .pl-s1,
    .markdown-body .pl-sr,
    .markdown-body .pl-sr .pl-cce,
    .markdown-body .pl-sr .pl-sra,
    .markdown-body .pl-sr .pl-sre {
      color: var(--color-prettylights-syntax-string)
    }

    .markdown-body .pl-smw,
    .markdown-body .pl-v {
      color: var(--color-prettylights-syntax-variable)
    }

    .markdown-body .pl-bu {
      color: var(--color-prettylights-syntax-brackethighlighter-unmatched)
    }

    .markdown-body .pl-ii {
      color: var(--color-prettylights-syntax-invalid-illegal-text);
      background-color: var(--color-prettylights-syntax-invalid-illegal-bg)
    }

    .markdown-body .pl-c2 {
      color: var(--color-prettylights-syntax-carriage-return-text);
      background-color: var(--color-prettylights-syntax-carriage-return-bg)
    }

    .markdown-body .pl-sr .pl-cce {
      font-weight: 700;
      color: var(--color-prettylights-syntax-string-regexp)
    }

    .markdown-body .pl-ml {
      color: var(--color-prettylights-syntax-markup-list)
    }

    .markdown-body .pl-mh,
    .markdown-body .pl-mh .pl-en,
    .markdown-body .pl-ms {
      font-weight: 700;
      color: var(--color-prettylights-syntax-markup-heading)
    }

    .markdown-body .pl-mi {
      font-style: italic;
      color: var(--color-prettylights-syntax-markup-italic)
    }

    .markdown-body .pl-mb {
      font-weight: 700;
      color: var(--color-prettylights-syntax-markup-bold)
    }

    .markdown-body .pl-md {
      color: var(--color-prettylights-syntax-markup-deleted-text);
      background-color: var(--color-prettylights-syntax-markup-deleted-bg)
    }

    .markdown-body .pl-mi1 {
      color: var(--color-prettylights-syntax-markup-inserted-text);
      background-color: var(--color-prettylights-syntax-markup-inserted-bg)
    }

    .markdown-body .pl-mc {
      color: var(--color-prettylights-syntax-markup-changed-text);
      background-color: var(--color-prettylights-syntax-markup-changed-bg)
    }

    .markdown-body .pl-mi2 {
      color: var(--color-prettylights-syntax-markup-ignored-text);
      background-color: var(--color-prettylights-syntax-markup-ignored-bg)
    }

    .markdown-body .pl-mdr {
      font-weight: 700;
      color: var(--color-prettylights-syntax-meta-diff-range)
    }

    .markdown-body .pl-ba {
      color: var(--color-prettylights-syntax-brackethighlighter-angle)
    }

    .markdown-body .pl-sg {
      color: var(--color-prettylights-syntax-sublimelinter-gutter-mark)
    }

    .markdown-body .pl-corl {
      text-decoration: underline;
      color: var(--color-prettylights-syntax-constant-other-reference-link)
    }

    .markdown-body g-emoji {
      display: inline-block;
      min-width: 1ch;
      font-family: "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      font-size: 1em;
      font-style: normal !important;
      font-weight: var(--base-text-weight-normal, 400);
      line-height: 1;
      vertical-align: -.075em
    }

    .markdown-body g-emoji img {
      width: 1em;
      height: 1em
    }

    .markdown-body .task-list-item {
      list-style-type: none
    }

    .markdown-body .task-list-item label {
      font-weight: var(--base-text-weight-normal, 400)
    }

    .markdown-body .task-list-item.enabled label {
      cursor: pointer
    }

    .markdown-body .task-list-item+.task-list-item {
      margin-top: 4px
    }

    .markdown-body .task-list-item .handle {
      display: none
    }

    .markdown-body .task-list-item-checkbox {
      margin: 0 .2em .25em -1.4em;
      vertical-align: middle
    }

    .markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {
      margin: 0 -1.6em .25em .2em
    }

    .markdown-body .contains-task-list {
      position: relative
    }

    .markdown-body .contains-task-list:focus-within .task-list-item-convert-container,
    .markdown-body .contains-task-list:hover .task-list-item-convert-container {
      display: block;
      width: auto;
      height: 24px;
      overflow: visible;
      clip: auto
    }

    .markdown-body ::-webkit-calendar-picker-indicator {
      filter: invert(50%)
    }

    .markdown-body .markdown-alert {
      padding: var(--base-size-8) var(--base-size-16);
      margin-bottom: 16px;
      color: inherit;
      border-left: .25em solid var(--color-border-default)
    }

    .markdown-body .markdown-alert>:first-child {
      margin-top: 0
    }

    .markdown-body .markdown-alert>:last-child {
      margin-bottom: 0
    }

    .markdown-body .markdown-alert .markdown-alert-title {
      display: flex;
      font-weight: var(--base-text-weight-medium, 500);
      align-items: center;
      line-height: 1
    }

    .markdown-body .markdown-alert.markdown-alert-note {
      border-left-color: var(--color-accent-emphasis)
    }

    .markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title {
      color: var(--color-accent-fg)
    }

    .markdown-body .markdown-alert.markdown-alert-important {
      border-left-color: var(--color-done-emphasis)
    }

    .markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title {
      color: var(--color-done-fg)
    }

    .markdown-body .markdown-alert.markdown-alert-warning {
      border-left-color: var(--color-attention-emphasis)
    }

    .markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title {
      color: var(--color-attention-fg)
    }

    .markdown-body .markdown-alert.markdown-alert-tip {
      border-left-color: var(--color-success-emphasis)
    }

    .markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title {
      color: var(--color-success-fg)
    }

    .markdown-body .markdown-alert.markdown-alert-caution {
      border-left-color: var(--color-danger-emphasis)
    }

    .markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title {
      color: var(--color-danger-fg)
    }
  </style>
  <style>
    body {
      margin: 0;
    }

    .markdown-body-content {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
    }

    @media (max-width: 767px) {
      .markdown-body-content {
        padding: 15px;
      }
    }

    .markdown-body {
      --base-size-8: 8px;
      --base-size-16: 16px;
    }
  </style>
</head>

<body class="markdown-body">
  <article class="markdown-body-content">
    <h1>A Practical Guide to Zephyr Device Driver Development </h1>
    <p>This is a guide on how to write a production grade device driver in Zephyr. This includes driver code, testing,
      CI and many more. Do not consider this document as a tutorial to Zephyr or device drivers, I'll just showcase my
      workflow and the environment I use to develop device drivers in Zephyr. Some of this may not be suited for your
      workflow, but I'll try to keep each section on it's own so you can skip the parts you don't need or don't want to
      use.</p>
    <p>I'll not talk about some details and assume you have at least heard about Zephyr and device drivers. If you
      don't, or want to refresh your memory check out the <a href="https://docs.zephyrproject.org/latest/"
        rel="nofollow">official documentation</a>. More of the talk will assume you were already developing on embedded
      projects and want to try something new, or you are already developing on Zephyr and want to see how others do it.
    </p>
    <div class="markdown-alert markdown-alert-note">
      <p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1"
          width="16" height="16" aria-hidden="true">
          <path
            d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
          </path>
        </svg>Note</p>
      <p>Zephyr still makes big changes to the framework, so some of the information here might be outdated or not the
        best practice anymore. I'll try to keep this up to date as much as possible, and give version information
        anywhere I can. Also I'll run inside a development container for you readers to easily follow along.</p>
    </div>
    <h2>Table of Contents </h2>
    <ul>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#prerequisites-and-setup">Prerequisites and Setup</a>
        <ul>
          <li><a href="#setup">Setup</a>
            <ul>
              <li><a href="#using-the-container">Using the container</a></li>
              <li><a href="#vscode-remote-containers">VSCode Remote Containers</a></li>
              <li><a href="#building-the-container-optional">Building the container (optional)</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#getting-started">Getting Started</a>
        <ul>
          <li><a href="#west-workspaces">West Workspaces</a></li>
        </ul>
      </li>
      <li><a href="#device-driver-development">Device Driver Development</a>
        <ul>
          <li><a href="#understanding-the-hardware">Understanding the Hardware</a>
            <ul>
              <li><a href="#surface-charge-transfer">Surface Charge Transfer</a></li>
            </ul>
          </li>
          <li><a href="#registers-and-configurations">Registers and Configurations</a>
            <ul>
              <li><a href="#reset-and-clock-configuration">Reset and Clock Configuration</a></li>
              <li><a href="#gpio-configuration">GPIO Configuration</a></li>
              <li><a href="#tsc-clock-prescaler-configuration">TSC Clock Prescaler Configuration</a></li>
              <li><a href="#tsc-pulse-generator-configuration">TSC Pulse Generator Configuration</a></li>
              <li><a href="#tsc-spread-spectrum-configuration">TSC Spread Spectrum Configuration</a></li>
              <li><a href="#tsc-sync-configuration">TSC SYNC Configuration</a></li>
              <li><a href="#tsc-interrupts">TSC Interrupts</a></li>
              <li><a href="#how-to-read-the-count-value">How to Read the Count Value</a></li>
            </ul>
          </li>
          <li><a href="#hardware-configuration">Hardware Configuration</a></li>
          <li><a href="#device-tree-nodes-and-bindings">Device Tree Nodes and Bindings</a>
            <ul>
              <li><a href="#pin-control">Pin Control</a></li>
              <li><a href="#other-bindings">Other Bindings</a>
                <ul>
                  <li><a href="#pulse-generator-prescaler">Pulse Generator Prescaler</a></li>
                  <li><a href="#charge-transfer-pulse-high-and-low">Charge Transfer Pulse High and Low</a></li>
                  <li><a href="#max-count-value">Max Count Value</a></li>
                  <li><a href="#spread-spectrum">Spread Spectrum</a></li>
                  <li><a href="#sync-signal">SYNC Signal</a></li>
                  <li><a href="#io-default-mode">IO Default Mode</a></li>
                </ul>
              </li>
              <li><a href="#child-nodes-and-bindings">Child Nodes and Bindings</a></li>
              <li><a href="#final-binding-file-and-device-tree-nodes">Final Binding File and Device Tree Nodes</a></li>
            </ul>
          </li>
          <li><a href="#plumbing-device-tree-to-driver-code">Plumbing Device Tree to Driver Code</a>
            <ul>
              <li><a href="#device-tree-macros">Device Tree Macros</a></li>
              <li><a href="#register-base-address">Register Base Address</a></li>
              <li><a href="#clock-and-reset-control">Clock and Reset Control</a></li>
              <li><a href="#pin-controller">Pin Controller</a></li>
              <li><a href="#group-configurations">Group Configurations</a></li>
              <li><a href="#tsc-configuration">TSC Configuration</a></li>
              <li><a href="#putting-it-all-together">Putting it all together</a>
                <ul>
                  <li><a href="#interrupts">Interrupts</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#device-driver-implementation">Device Driver Implementation</a>
            <ul>
              <li><a href="#peripheral-and-subsystem-apis">Peripheral and Subsystem APIs</a></li>
              <li><a href="#reset-api">Reset API</a></li>
              <li><a href="#clock-control-api">Clock Control API</a></li>
              <li><a href="#pin-controller-api">Pin Controller API</a></li>
              <li><a href="#stm32_tsc_init">stm32_tsc_init</a></li>
              <li><a href="#tsc-peripheral-api">TSC Peripheral API</a></li>
              <li><a href="#tsc-peripheral-api-implementation">TSC Peripheral API Implementation</a>
                <ul>
                  <li><a href="#stm32_tsc_start">stm32_tsc_start</a></li>
                  <li><a href="#stm32_tsc_poll_for_acquisition">stm32_tsc_poll_for_acquisition</a></li>
                  <li><a href="#stm32_tsc_read">stm32_tsc_read</a></li>
                  <li><a href="#stm32_tsc_isr">stm32_tsc_isr</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#integration-into-the-build-system">Integration into the Build System</a>
            <ul>
              <li><a href="#source-cmakeliststxt">Source CMakeLists.txt</a></li>
              <li><a href="#source-kconfig">Source Kconfig</a></li>
              <li><a href="#zephyr-cmakeliststxt">Zephyr CMakeLists.txt</a></li>
              <li><a href="#zephyr-kconfig">Zephyr Kconfig</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#how-do-we-test-this">How Do We Test This?</a>
        <ul>
          <li><a href="#building">Building</a></li>
          <li><a href="#flashing">Flashing</a>
            <ul>
              <li><a href="#linux">Linux</a></li>
              <li><a href="#windows">Windows</a></li>
              <li><a href="#osx">OSX</a></li>
            </ul>
          </li>
          <li><a href="#integration-testing">Integration Testing</a>
            <ul>
              <li><a href="#what-to-test">What to Test?</a></li>
              <li><a href="#test-plan">Test Plan</a></li>
              <li><a href="#test-application">Test Application</a>
                <ul>
                  <li><a href="#cmakeliststxt">CMakeLists.txt</a></li>
                  <li><a href="#prjconf">prj.conf</a></li>
                  <li><a href="#device-tree-overlays">Device tree overlays</a></li>
                  <li><a href="#testcaseyml">testcase.yml</a></li>
                </ul>
              </li>
              <li><a href="#test-cases">Test Cases</a>
                <ul>
                  <li><a href="#test-setup">Test Setup</a></li>
                  <li><a href="#first-test-case">First Test Case</a></li>
                  <li><a href="#test-mmio">Test MMIO</a></li>
                  <li><a href="#api-tests">API Tests</a></li>
                </ul>
              </li>
              <li><a href="#running-the-tests">Running the Tests</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#wrapping-up">Wrapping Up</a></li>
    </ul>
    <h2>Introduction</h2>
    <p>I've known about Zephyr for a while now but only had the chance to work with it by the beginning of this year
      when I listened the <a href="https://theamphour.com/653-benjamin-cabe-nose-zephyr/" rel="nofollow">this Amp Hour
        podcast</a>. I've quickly come to realize the enormous benefits of using Zephyr for any kind of embedded
      project. From full blown RTOS running on x86 with network stacks and PCIe drivers to a microcontroller with 32KB
      of flash, Zephyr is a great choice for any project. It was surreal to edit <a href="https://www.devicetree.org/"
        rel="nofollow">devicetree</a> files to configure a 50-cent microcontroller.</p>
    <p>Zephyr gives you a nice framework for everything embedded. You have device trees, device drivers, networking
      stacks, filesystems, a testing framework, a nice RTOS, a nice build system and anything else you can name. It
      abstracts low level hardware so nicely that you only need to write what your application ultimately wants to do in
      a hardware-agnostic way and have it run on anything without touching a single line of code.</p>
    <p>I especially liked the Zephyr because I was working on a range of similar products with an unorganized and
      distributed codebase, we needed to run our business logic on slightly different hardware platforms, so the device
      driver model and device trees was the perfect solution in this case. We initially got concerned about the size of
      the firmware as we were on very tight budget, we could only get 32KB and 64KB flash microcontrollers, and Zephyr
      seemed overkill for this, but it was not. It seems like the Zephyr team has a lot of experience in the embedded
      world and Linux in general, so they've made the right choice of making the entire thing customizable down to the
      detail. If you strip down everything you can get down to a ~3KB binary, which is amazing. But most of the time you
      want to use OS services and other features so you end up with a <a
        href="https://docs.zephyrproject.org/latest/samples/basic/minimal/README.html" rel="nofollow">~7KB-10KB binary
        for a minimal application</a>.</p>
    <p>Most of the drivers are already in the Zephyr upstream, but you eventually have to write your own device drivers
      for your custom hardware. That's what I ended up doing, writing some device drivers, generating my custom board
      configurations and device trees, and wrote my application logic, and here I'll show you how I did it.</p>
    <h2>Prerequisites and Setup</h2>
    <p>First of all we need an environment to work in. In this environment we'll have all the tools we need to develop,
      test and debug our device driver. I usually prefer working in docker containers for reproducibility and ease of
      deployment. Therefore you need some tools installed in your host to get started.</p>
    <ul>
      <li><a href="https://www.docker.com/" rel="nofollow">Docker</a> (v26.0.0)</li>
      <li><a href="https://code.visualstudio.com/" rel="nofollow">VSCode</a> (v1.92.0)</li>
      <li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers"
          rel="nofollow">Remote - Containers</a> extension for VSCode (v0.389.0)</li>
    </ul>
    <div class="markdown-alert markdown-alert-note">
      <p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1"
          width="16" height="16" aria-hidden="true">
          <path
            d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
          </path>
        </svg>Note</p>
      <p>I'm running on a x86 Windows machine, so I can use things like <a href="https://usbip.sourceforge.net/"
          rel="nofollow">USBIP</a> to debug my hardware connected to my host but this feature is not yet available in
        macOS, but we will also discuss about remote debugging in later sections.</p>
    </div>
    <p>I assume most of you already have those installed, so lets quickly get started.</p>
    <h3>Setup</h3>
    <p>If you are using VSCode, you can use devcontainers feature to get your development environment up and running in
      no time. But you can also use any other editor or a terminal to do everything I'll show you here.</p>
    <p>If you want to work on your host machine, you can check out the <a
        href="https://docs.zephyrproject.org/latest/getting_started/index.html" rel="nofollow">official Zephyr
        documentation</a> to setup your environment.</p>
    <p>The development container is based on official <code class="notranslate">zephyr-build</code> container in <a
        href="https://github.com/zephyrproject-rtos/docker-image">Zephyr's <code class="notranslate">docker-image</code>
        repository</a>. I've added extra configurations to really integrate it into VSCode with extensions and tools.
      But basically it has:</p>
    <ul>
      <li>Zephyr SDK (0.16.8)</li>
      <li>All the system packages needed for Zephyr</li>
      <li>Python3 and pip packages (including <a href="https://docs.zephyrproject.org/latest/develop/west/index.html"
          rel="nofollow">west</a>)</li>
      <li>Oh My Zsh</li>
      <li>VSCode Extensions</li>
    </ul>
    <p>Check out the <a href=".devcontainer/devcontainer.json">devcontainer.json</a> if you want to see the exact setup.
      To keep it compatible with non-vscode users, I kept the configuration minimal. I highly encourage you to modify
      the file to your needs. There are tons of customizations you can do with devcontainers.</p>
    <h4>Using the container</h4>
    <p>The fastest way to start is to pull and run the image I prepared from my GitHub Container Registry with the
      following command:</p>
    <div class="highlight highlight-source-shell">
      <pre
        class="notranslate">docker run -it --name zephyr-dev -v zephyr-volume:/workdir ghcr.io/arifbalik/zephyr-dev:latest</pre>
    </div>
    <p>This should drop you into a shell with the Zephyr SDK and all the tools installed.</p>
    <h4>VSCode Remote Containers</h4>
    <p>Easiest method to work in a container is to use the <code class="notranslate">Remote - Containers</code>
      extension in VSCode. You can open the project folder in VSCode and click on the blue icon in the bottom left
      corner or with <code class="notranslate">ctrl + shift + p</code> and select <code
        class="notranslate">Attach to Running Container...</code> and select the container you just started.</p>
    <h4>Building the container (optional)</h4>
    <p>The building requires additional tools like <a href="https://nodejs.org/en" rel="nofollow">node</a>, <a
        href="https://www.npmjs.com/" rel="nofollow">npm</a> and <a
        href="https://www.npmjs.com/package/@devcontainers/cli" rel="nofollow">devcontainers package</a>:</p>
    <p>First install the package;</p>
    <div class="highlight highlight-source-shell">
      <pre class="notranslate">npm install -g @devcontainers/cli</pre>
    </div>
    <p>Then build the container with the following command:</p>
    <div class="highlight highlight-source-shell">
      <pre
        class="notranslate">devcontainer up --config /path/to/devcontainer.json --workspace-folder /path/to/your/workspace</pre>
    </div>
    <h2>Getting Started</h2>
    <p>Now that we have a system we can build on. We'll use the <code class="notranslate">west</code> tool to get the
      zephyr repository and start implementing.</p>
    <h3>West Workspaces</h3>
    <p>Assuming we want to contribute to the open-source project, we will develop inside the Zephyr source, so the T1
      topology is what will be used here, but personally I use free standing application workspaces for professional
      work, T3 topology to be more specific.</p>
    <p>Zephyr calls its workspaces <code class="notranslate">west workspaces</code>. And there are 3 main workspace
      types:</p>
    <ul>
      <li>Zephyr source as a workspace (T1)</li>
      <li>Zephyr application as a workspace (T2)</li>
      <li>Custom workspace with multiple Zephyr applications (you guessed it..)</li>
    </ul>
    <p>More information on them can be found <a href="https://docs.zephyrproject.org/latest/guides/west/workspaces.html"
        rel="nofollow">here</a>.</p>
    <p>Inside the container, we can start by initializing a workspace with the following command:</p>
    <div class="highlight highlight-source-shell">
      <pre class="notranslate">west init</pre>
    </div>
    <p>This will create a <code class="notranslate">.west</code> directory and clone zephyr repository into the <code
        class="notranslate">/workdir</code> which is mounted as volume and its persistent. What also is required is the
      Zephyr modules and tools, update the workspace with the following command:</p>
    <div class="highlight highlight-source-shell">
      <pre class="notranslate">west update</pre>
    </div>
    <p>This will fetch all source code that is outside of the Zephyr repository but needed to build an application, like
      the <code class="notranslate">hal_stm32</code> and <code class="notranslate">mcuboot</code> repositories.</p>
    <div class="markdown-alert markdown-alert-warning">
      <p class="markdown-alert-title"><svg class="octicon octicon-alert mr-2" viewBox="0 0 16 16" version="1.1"
          width="16" height="16" aria-hidden="true">
          <path
            d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z">
          </path>
        </svg>Warning</p>
      <p>Zephyr version is <code class="notranslate">v3.7.0</code> at the time of writing this document and it has a a
        bug that has been patched by me but is not in the v3.7.0, therefore if you want to be where I was when this
        document is written, check out to the <a
          href="https://github.com/zephyrproject-rtos/zephyr/commit/10fa1eab50ac54e41bf75ab0ad01daa4bd25ba13"><code
            class="notranslate">10fa1eab50ac54e41bf75ab0ad01daa4bd25ba13</code></a> hash of the <code
          class="notranslate">zephyr</code> repository, inside <code class="notranslate">zephyr/west.yml</code> file, or
        apply the patch yourself.</p>
    </div>
    <p>This may take some time and it will load a ton of modules we won't need, therefore I highly recommend using a T2
      or T3 topology for your projects. Once the update is done, a similar file structure should appear in the
      workspace;</p>
    <div class="highlight highlight-source-shell">
      <pre class="notranslate"><span class="pl-c1">.</span>
├── bootloader
├── modules
├── tools
├── .west
└── zephyr</pre>
    </div>
    <h2>Device Driver Development</h2>
    <p><a target="_blank" rel="noopener noreferrer" href="doc-assets/stm32u083c-dk.jpg"><img
          src="doc-assets/stm32u083c-dk.jpg" alt="STM32U083C Development Kit" style="max-width: 100%;"></a></p>
    <p>Recently I had my hands on a <a href="https://www.st.com/en/evaluation-tools/stm32u083c-dk.html"
        rel="nofollow">devkit for STMicroelectronic's U0 series microcontrollers</a>, and one peripheral I was
      interested was the TSC peripheral in this MCU. This is a peripheral used for capacitive touch sensing
      applications, buttons, sliders and things like that can be implemented with this peripheral (Notice the touch
      surface in the bottom right corner, it is a bare electrode and a 1mm insulating surface on top) You can implement
      a touch sensing application by using a PWM and an ADC maybe with comparator but this peripheral is very simple and
      does all that and a little bit more and offloads the CPU.</p>
    <p>Conveniently Zephyr does not have a driver for this peripheral. So I will write one here.</p>
    <h3>Understanding the Hardware</h3>
    <p>This section goes a little bit into the details of the hardware we are working with. If you are not interested in
      this part or you already know the terminology you can skip to the next section.</p>
    <p>If you haven't worked with a capacitive touch sensing application before, allow me to tell you that it is not as
      easy as it seems when integrating touch sensing into a product end-to-end. Especially if you have stricter
      requirements for your application, like electrically noisy environments, or any industrial spec really immediately
      starts to complicate things and EMC becomes a big issue.</p>
    <p>A capacitive touch point is usually just a piece of conductive material, like a PCB pad. This piece of pad is
      leveraged to create a capacitive coupling with the human body, so you have to make a sandwich of these two
      conductive surfaces, (often a plastic is always in between the finger and the plate) forming a capacitor.</p>
    <p>Then this means we can charge the capacitor and do funky things with it, for example we can say that the
      capacitance changes when a finger is present than when it is not, and this can be used to detect a touch.</p>
    <p>Of course this is just one very specific setup with a single ended electrode, there are many setups and ways to
      do this, what we will specifically talk here is called Surface Charge Transfer (SCT) method, which is what this
      peripheral does.</p>
    <h4>Surface Charge Transfer</h4>
    <p><a target="_blank" rel="noopener noreferrer" href="doc-assets/electrode.png"><img src="doc-assets/electrode.png"
          alt="Electrode" style="max-width: 100%;"></a></p>
    <p>The dotted capacitor in the figure above represents the capacitor of the electrode we just made with a finder and
      a conductive patch with an insulating layer in between.</p>
    <p>This method does not continuously check the voltage of this electrode, instead an external capacitor (in ranges
      from 1pf to couple hundreds of pf) called <code class="notranslate">sampling capactior</code> is used to transfer
      some charge in the electrode to this new capacitor (<code class="notranslate">Cs</code> in the figure above), this
      makes the readings much more repeatable and reliable.</p>
    <p>ST TSC in particular calls this combo a <code class="notranslate">group</code> and gives each group two extra
      channels for more custom applications. Each group has to have 1 sampling capacitor channel and at least one IO
      channel to function properly. These IO channels do not produce a value each, instead each channel is used to
      charge the same sampling capacitor, so a group will produce only one count value no matter the IO channel count.
      ST gives the example of a crude proximity sensor by placing two or more electrodes near each other.</p>
    <p><a target="_blank" rel="noopener noreferrer" href="doc-assets/sct.png"><img src="doc-assets/sct.png"
          alt="SCT Method" style="max-width: 100%;"></a></p>
    <p>This charge transfer duration is pretty small (and of course programmable), so it does not fill the sampling
      capacitor right away, the peripheral needs to perform many of these charge transfer cycles and count it. Counting
      is stopped when this count reaches a certain threshold, which the peripheral then throws a <code
        class="notranslate">max count error</code> interrupt, or the voltage on this charged <code
        class="notranslate">sample</code> capacitor is reached a voltage level (again, programmable) before the max
      count is reached, peripheral then throws an <code class="notranslate">end of acquisition</code> interrupt which
      than you can read and find out how many cycles it took to reach this voltage level. And this will directly be
      correlated to the capacitance of the electrode, which is directly correlated to the presence of a finger.</p>
    <p><a target="_blank" rel="noopener noreferrer" href="doc-assets/sct-cycle.png"><img src="doc-assets/sct-cycle.png"
          alt="STM32 TSC SCT Cycle" style="max-width: 100%;"></a></p>
    <p>As I mentioned above touch sensing get really messy in noisy environments, so running these cycles and very fast
      at a fixed interval would not be very wise because the signal would pick up harmonics of the noise and you would
      get false positives and whatnot. Therefore the peripheral has a feature called <code
        class="notranslate">spread spectrum</code> which adds variation to charge transfer cycles.</p>
    <p>This is a very smart and robust way of detecting a touch. Above you can see the full cycle. I got this image and
      most of all information about this hardware from the <a
        href="https://www.st.com/resource/en/reference_manual/rm0503-stm32u0-series-advanced-armbased-32bit-mcus-stmicroelectronics.pdf"
        rel="nofollow">reference manual <code class="notranslate">RM0503</code> of the STM32U0 series
        microcontrollers</a>.</p>
    <h3>Registers and Configurations</h3>
    <p>After we understand the Surface Charge Transfer method we can start to see what can we configure. Functional
      diagrams is a good way to start.</p>
    <p><a target="_blank" rel="noopener noreferrer" href="doc-assets/tsc-functional-diagram.png"><img
          src="doc-assets/tsc-functional-diagram.png" alt="STM32 TSC Functional Diagram" style="max-width: 100%;"></a>
    </p>
    <p>We can see that we have two different sections which can be clocked at different speeds, one is for generating
      the charge pulses and other is for spread spectrum which generates a value that feeds into the pulse generator.
      Something we did not talked about yet is <code class="notranslate">SYNC</code> signal, which is an external signal
      which triggers pulse generator to start acquisition in addition to the software trigger the driver will use.</p>
    <p>Pulse generator commands the IO, setting their modes and function while the acquisition is running and it will
      store the group results in separate 14-bit values in <code class="notranslate">IOGXCR</code> (IO Group X Counter
      Register).</p>
    <h4>Reset and Clock Configuration</h4>
    <p>This is a memory mapped peripheral like most all peripherals in STM32 microcontrollers. And often the first thing
      to do is to reset the peripheral (optional) and enable it. For STM32 MCU's the RCC (Reset and Clock Controller)
      peripheral is able to do this, so first peripheral to work with is the RCC.</p>
    <p>The TSC peripheral gets it's clock from the AHB clock, we expect this clock to be initialized by other drivers,
      what this driver has to do is to set some bits to perform reset and enable operations. Reference manual gives all
      the information we would need.</p>
    <details>
      <summary> RCC AHBRSTR (RCC AHB Reset Register Bits 24) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"><strong>31:25</strong></th>
              <th align="center"><strong>24</strong></th>
              <th align="center"><strong>23:0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">TSCRST</td>
              <td align="center">-</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">Touch sensing controller reset</td>
              <td align="center">-</td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center">-</td>
              <td align="center"><code class="notranslate">0</code>: No effect<br><code class="notranslate">1</code>:
                Reset TSC</td>
              <td align="center">-</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <details>
      <summary> RCC AHBENR (RCC AHB Enable Register Bits 24) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"><strong>31:25</strong></th>
              <th align="center"><strong>24</strong></th>
              <th align="center"><strong>23:0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">TSCEN</td>
              <td align="center">-</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">Touch sensing controller clock enable</td>
              <td align="center">-</td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center">-</td>
              <td align="center"><code class="notranslate">0</code>: TSC clock disabled<br><code
                  class="notranslate">1</code>: TSC clock enabled</td>
              <td align="center">-</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <p>As you can see ST conveniently named the registers and put the relevant bits in the same position for both
      registers (24th bit). So this means whenever we write 1 to the 24th bit of the <code
        class="notranslate">RCC register base address + register_offset</code> (<code class="notranslate">0x28</code>
      for reset and <code class="notranslate">0x48</code> for enable) we can reset and enable the peripheral.</p>
    <h4>GPIO Configuration</h4>
    <p>This is the second peripheral before we get to the TSC peripheral. The pins we will use for the TSC should be
      configured through the GPIO peripheral. Thankfully Zephyr provides a good subsystem and abstraction for this which
      we will see later.</p>
    <p>There is also some registers in the TSC peripheral that we need to configure. First of all we have to specify
      which channels are used for what, and which groups are enabled. We will use different registers for each of these
      settings.</p>
    <p>When no acquisition is ongoing, the state of the IO channels are in <code
        class="notranslate">default mode</code>. And TSC peripheral offers an option to set the default mode of the IO
      channels. This can be floating, push-pull-low. The register for this is <code class="notranslate">CR</code>
      (Control Register) and the bit position is 4;</p>
    <details>
      <summary> TSC CR (TSC Control Register Bit 4) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"><strong>31:5</strong></th>
              <th align="center"><strong>4</strong></th>
              <th align="center"><strong>3:0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">IODEF</td>
              <td align="center">-</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">IO default mode</td>
              <td align="center">-</td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center">-</td>
              <td align="center"><code class="notranslate">0</code>: Push-pull-low<br><code
                  class="notranslate">1</code>: Floating</td>
              <td align="center">-</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <p>We use <code class="notranslate">IOCCR</code> (IO Channel Control Register) and <code
        class="notranslate">IOSCR</code> (IO Sampling Control Register) registers for electrodes and sampling capacitors
      respectively.</p>
    <details>
      <summary> TSC IOCCR (TSC IO Channel Control Register) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"><strong>31:28</strong></th>
              <th align="center"><strong>27:0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">Gx_IOy</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">IO channel y of group x</td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center">-</td>
              <td align="center"><code class="notranslate">0</code>: Disabled<br><code class="notranslate">1</code>: IO
                used as channel mode</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <details>
      <summary> TSC IOSCR (TSC IO Sampling Control Register) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"><strong>31:28</strong></th>
              <th align="center"><strong>27:0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">Gx_IOy</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">IO channel y of group x</td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center">-</td>
              <td align="center"><code class="notranslate">0</code>: Disabled<br><code class="notranslate">1</code>: IO
                sampling mode</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <p>And finally <code class="notranslate">IOGCSR</code> (IO Group Control Status Register) to enable the group.</p>
    <details>
      <summary> TSC IOGCSR (TSC IO Group Control Status Register) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"><strong>31:7</strong></th>
              <th align="center"><strong>6:0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">GxS</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">Analog I/O group x enable</td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center">-</td>
              <td align="center"><code class="notranslate">0</code>: Disabled<br><code class="notranslate">1</code>:
                Enabled</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <h4>TSC Clock Prescaler Configuration</h4>
    <p>The clock enters the TSC IP from the AHB clock, this clock goes to many other peripherals so it is not a good
      idea to change the AHB clock rate for the TSC peripheral as the first and only thing. Instead we have a clock
      pre-scaler value to divide clock further before it enters the TSC. User manuals tells us the location of this
      register that controls this.</p>
    <details>
      <summary> TSC CR (TSC Control Register Bits 15 and 14:12) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"><strong>15</strong></th>
              <th align="center"><strong>14:12</strong></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center">SSPSC</td>
              <td align="center">PGPSC[2:0]</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center">Spread spectrum prescaler</td>
              <td align="center">Pulse generator prescaler</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"><code class="notranslate">0</code>: <code class="notranslate">fHCLK</code><br><code
                  class="notranslate">1</code>: <code class="notranslate">fHCLK /2</code></td>
              <td align="center"><code class="notranslate">000</code>: <code
                  class="notranslate">fHCLK</code><br>...<br><code class="notranslate">111</code>: <code
                  class="notranslate">fHCLK /128</code></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <p>There are two clock settings</p>
    <ul>
      <li><code class="notranslate">PGPSC</code> (Pulse Generator Prescaler) and it is a 3-bit value, and each
        represents a different division factor.adjust the clock rate for the TSC peripheral.</li>
      <li><code class="notranslate">SSPSC</code> (Spread Spectrum Prescaler) and it is a 1-bit value. <code
          class="notranslate">0: AHB/1</code> and <code class="notranslate">1: AHB/2</code>.</li>
    </ul>
    <p>Defining the clock finally gives us the full cycle duration for one charge transfer cycle. In <code
        class="notranslate">U0</code> series this can be from 500ns to 2us.</p>
    <h4>TSC Pulse Generator Configuration</h4>
    <p>This section is the heart of the peripheral configuration and there are a few settings we can adjust;</p>
    <ul>
      <li>Charging duration</li>
      <li>Transfer Duration</li>
      <li>Max Cycle Count</li>
    </ul>
    <details>
      <summary> TSC CR (TSC Control Register Bits 31:28, 27:24 and 7:5) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"><strong>31:28</strong></th>
              <th align="center"><strong>27:24</strong></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"><strong>7:5</strong></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center">CTPH[3:0]</td>
              <td align="center">CTPL[3:0]</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center">MCV[2:0]</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center">Charge transfer pulse high</td>
              <td align="center">Charge transfer pulse low</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center">Max count value</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"><code class="notranslate">0000</code>: 1x tPGCLK<br><code
                  class="notranslate">...</code><br><code class="notranslate">1111</code>: 16x tPGCLK</td>
              <td align="center"><code class="notranslate">0000</code>: 1x tPGCLK<br><code
                  class="notranslate">...</code><br><code class="notranslate">1111</code>: 16x tPGCLK</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"><code class="notranslate">000</code>: 255<br><code class="notranslate">001</code>:
                511<br><code class="notranslate">...</code><br><code class="notranslate">110</code>: 16383</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <p>Charging and transfer durations are denoted as <code class="notranslate">CTPH</code> (Charge Transfer Pulse High)
      and <code class="notranslate">CTPL</code> (Charge Transfer Pulse Low) respectively. These are 4-bit values and can
      be adjusted from 1 to 16 clock cycles. These values are used to charge the external capacitor and transfer the
      charge to the sample capacitor.</p>
    <p>Max cycle count is a 3-bit value and each represents a different count value. This is a safety feature where TSC
      can not fill the capacitor enough to reach the voltage threshold, so it stops the cycle and throws an interrupt.
    </p>
    <h4>TSC Spread Spectrum Configuration</h4>
    <details>
      <summary> TSC CR (TSC Control Register Bits 23:17 and 16) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"><strong>23:17</strong></th>
              <th align="center"><strong>16</strong></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center">SSD[6:0]</td>
              <td align="center">SSE</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center">Spread spectrum deviation</td>
              <td align="center">Spread spectrum enable</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"><code class="notranslate">0000000</code>: 1x tSSCLK<br><code
                  class="notranslate">...</code><br><code class="notranslate">1111111</code>: 128x tSSCLK</td>
              <td align="center"><code class="notranslate">0</code>: Disabled<br><code class="notranslate">1</code>:
                Enabled</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <p>Spread spectrum has 9-bits for configuration in the <code class="notranslate">CR</code> register. The pre-scaler
      bit is already set, so rest if a 1-bit enable and 7-bit deviation value.The deviation value represents the maximum
      deviation of the charge transfer pulse in spread spectrum clock cycles.</p>
    <h4>TSC SYNC Configuration</h4>
    <p>There are only two bits related to this setting, one is for selecting the polarity and the other is for enabling
      the SYNC signal.</p>
    <details>
      <summary> TSC CR (TSC Control Register Bits 4 and 3) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"><strong>3</strong></th>
              <th align="center"><strong>2</strong></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
              <th align="center"></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center">SYNCPOL</td>
              <td align="center">SYNC Enable</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center">Synchronization pin polarity</td>
              <td align="center">Synchronization enable</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"><code class="notranslate">0</code>: Falling edge only<br><code
                  class="notranslate">1</code>: Rising edge and high level</td>
              <td align="center"><code class="notranslate">0</code>: Disabled<br><code class="notranslate">1</code>:
                Enabled</td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
              <td align="center"></td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <h4>TSC Interrupts</h4>
    <p>There are only 2 interrupts, <code class="notranslate">EOAF</code> (End of Acquisition Flag) and <code
        class="notranslate">MCEF</code> (Max Count Error Flag). These are set when the voltage threshold is reached or
      the max cycle count is reached respectively. They are enabled through a different register called <code
        class="notranslate">IER</code> (Interrupt Enable Register).</p>
    <details>
      <summary> TSC IER (TSC Interrupt Enable Register Bits 1 and 0) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"><strong>31:2</strong></th>
              <th align="center"><strong>1</strong></th>
              <th align="center"><strong>0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">MCEIE</td>
              <td align="center">EOAIE</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">Max count error interrupt enable</td>
              <td align="center">End of acquisition interrupt enable</td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center">-</td>
              <td align="center"><code class="notranslate">0</code>: Disabled<br><code class="notranslate">1</code>:
                Enabled</td>
              <td align="center"><code class="notranslate">0</code>: Disabled<br><code class="notranslate">1</code>:
                Enabled</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <div class="markdown-alert markdown-alert-note">
      <p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1"
          width="16" height="16" aria-hidden="true">
          <path
            d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
          </path>
        </svg>Note</p>
      <p>There is also a setting to adjust the voltage threshold for the end of acquisition, but this is done using a
        different comparator peripheral, for the sake of simplicity we will not use this feature.</p>
    </div>
    <h4>How to Read the Count Value</h4>
    <p>Before we start reading the <code class="notranslate">START</code> bit in the <code class="notranslate">CR</code>
      register should be set to start the acquisition. After the acquisition is done, the peripheral will throw an
      interrupt or we can poll the <code class="notranslate">EOAF</code> bit in the <code class="notranslate">ISR</code>
      register to check if the acquisition is done. Then we can read the status of each group with <code
        class="notranslate">IOGSR</code> and see if that group has finished the acquisition. If it has we can read the
      count value from the <code class="notranslate">IOGXCR</code> register.</p>
    <details>
      <summary> TSC CR (TSC Control Register Bits 0) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"><strong>31:1</strong></th>
              <th align="center"><strong>0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">START</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">Start acquisition</td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center">-</td>
              <td align="center"><code class="notranslate">0</code>: No effect<br><code class="notranslate">1</code>:
                Start acquisition</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <details>
      <summary> TSC ISR (TSC Interrupt Status Register Bits 1 and 0) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"><strong>31:2</strong></th>
              <th align="center"><strong>1</strong></th>
              <th align="center"><strong>0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">MCEF</td>
              <td align="center">EOAF</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">Max count error flag</td>
              <td align="center">End of acquisition flag</td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center">-</td>
              <td align="center"><code class="notranslate">0</code>: No error<br><code class="notranslate">1</code>:
                Error</td>
              <td align="center"><code class="notranslate">0</code>: No end of acquisition<br><code
                  class="notranslate">1</code>: End of acquisition</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <details>
      <summary> TSC IOGCSR (TSC IO Group Control Status Register) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"></th>
              <th align="center"><strong>31:23</strong></th>
              <th align="center"><strong>22:16</strong></th>
              <th align="center"><strong>15:0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">GxS</td>
              <td align="center">-</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">Analog I/O group x status</td>
              <td align="center">-</td>
            </tr>
            <tr>
              <td align="center"><strong>Values</strong></td>
              <td align="center">-</td>
              <td align="center"><code class="notranslate">0</code>: Ongoing<br><code class="notranslate">1</code>:
                Complete</td>
              <td align="center">-</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <details>
      <summary> TSC IOGXCR (TSC IO Group X Counter Register) </summary>
      <markdown-accessiblity-table>
        <table role="table">
          <thead>
            <tr>
              <th align="center"><strong>Bit</strong></th>
              <th align="center"><strong>31:14</strong></th>
              <th align="center"><strong>13:0</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center"><strong>Name</strong></td>
              <td align="center">-</td>
              <td align="center">CT[13:0]</td>
            </tr>
            <tr>
              <td align="center"><strong>Desc.</strong></td>
              <td align="center">-</td>
              <td align="center">Counter value</td>
            </tr>
          </tbody>
        </table>
      </markdown-accessiblity-table>
    </details>
    <p>There are some other minor settings which I will not go into detail because it does not concern the driver
      implementation. But here is the complete map of the TSC peripheral registers.</p>
    <details>
      <summary> STM32U0 TSC Peripheral Registers </summary>
      <p><a target="_blank" rel="noopener noreferrer" href="doc-assets/tsc-registers.png"><img
            src="doc-assets/tsc-registers.png" alt="STM32U0 TSC Registers" style="max-width: 100%;"></a></p>
    </details>
    <h3>Hardware Configuration</h3>
    <p><a target="_blank" rel="noopener noreferrer" href="doc-assets/tsc-sch.png"><img src="doc-assets/tsc-sch.png"
          alt="STM32 TSC SCH" style="max-width: 100%;"></a></p>
    <p>The <a href="https://www.st.com/resource/en/schematic_pack/mb1933-u083c-c02-schematic.pdf"
        rel="nofollow">development kit schematic</a> shows the implementation is for one electrode (<code
        class="notranslate">TKEY</code>) and one sampling capacitor (<code class="notranslate">TKEY_CS</code>), so we
      will stick with that.</p>
    <p>Notice how they actually used an extra group for another electrode and called it <code
        class="notranslate">shield</code> and connected to the end of the electrode to the ground. This is a trick often
      used to further reduce EMI and noise. Only difference this has over an electrode is this is not selected for
      acqusition. This is not related to the driver implementation so I will not go into detail.</p>
    <p>The pins and their alternate functions are as follows:</p>
    <markdown-accessiblity-table>
      <table role="table">
        <thead>
          <tr>
            <th align="center"><strong>GPIO Pin</strong></th>
            <th align="center"><strong>GPIO Alternate Function</strong></th>
            <th align="center"><strong>TSC Group</strong></th>
            <th align="center"><strong>TSC IO Number</strong></th>
            <th align="center"><strong>Function</strong></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="center">PD10</td>
            <td align="center">AF9</td>
            <td align="center">6</td>
            <td align="center">1</td>
            <td align="center">TKey CS</td>
          </tr>
          <tr>
            <td align="center">PD11</td>
            <td align="center">AF9</td>
            <td align="center">6</td>
            <td align="center">2</td>
            <td align="center">TKey</td>
          </tr>
          <tr>
            <td align="center">PB12</td>
            <td align="center">AF9</td>
            <td align="center">1</td>
            <td align="center">1</td>
            <td align="center">Shield Electrode</td>
          </tr>
          <tr>
            <td align="center">PB13</td>
            <td align="center">AF9</td>
            <td align="center">1</td>
            <td align="center">2</td>
            <td align="center">Shield Electrode Sampling Capacitor</td>
          </tr>
        </tbody>
      </table>
    </markdown-accessiblity-table>
    <p>I talk more about this in the next section, but this is the hardware we will work with.</p>
    <h3>Device Tree Nodes and Bindings</h3>
    <p>One of the first things to do is to create a device tree binding to describe our hardware before the
      implementation starts. The concept of device trees are not new and is used in Linux for many years, so it may be
      familiar to some of you, but for those who are unfamiliar, it is a JSON-like file that describes a hardware node
      in a system called <code class="notranslate">device-tree</code>, this allows for decoupling the hardware from the
      source code so that software may run independent of the hardware it is running on, meaning the API won't change if
      you change the hardware.</p>
    <p>To know more about device trees check out the <a href="https://www.devicetree.org/" rel="nofollow">official
        documentation</a>.</p>
    <p>To sketch a design lets thinker about a node for the hardware above. This is an attempt to create a definition
      that will contain all hardware related information in a single node for this peripheral.</p>
    <pre lang="dts" class="notranslate"><code class="notranslate">tsc : tsc@40024000 {
  compatible = "st,stm32-tsc";
  reg = &lt;0x40024000 0x400&gt;;
  clocks = &lt;&amp;rcc STM32_CLOCK_BUS_AHB1 0x01000000&gt;;
  resets = &lt;&amp;rctl STM32_RESET(AHB1, 24U)&gt;;
  interrupts = &lt;21 0&gt;;
};
</code></pre>
    <p>This simple node seems pretty self-explanatory, it has the most generic properties common to almost all ST -or
      ARM really- compatible peripherals, a register space, clock, reset and interrupt. The node describes a TSC node
      with the label <code class="notranslate">tsc</code> and at the address <code class="notranslate">0x40024000</code>
      which corresponds to the beginning of address space of the TSC module in <code class="notranslate">STM32U0x</code>
      series microcontrollers, this is the most fundamental information we should have about a memory-mapped io. We can
      see this information is encoded twice (both in definition with <code class="notranslate">@</code> symbol and with
      <code class="notranslate">reg</code> property). We can also see the entire memory mapped region is 1KB (<code
        class="notranslate">0x400</code>), it's clock is connected to the <code class="notranslate">AHB1</code> (24th
      bit <code class="notranslate">0x01000000</code> of the AHB control register), also it has a reset line again at
      the bit position 24 in the corresponding reset controller control register (created with <code
        class="notranslate">STM32_RESET</code> macro). In the vector table the position offset of its interrupt is <code
        class="notranslate">21</code> and has <code class="notranslate">0</code> priority. Another very important
      property is the <code class="notranslate">compatible</code> property, this is a string that describes the driver
      that will handle this node, in other words, this node information will be passed to a driver that declares itself
      as <code class="notranslate">st,stm32-tsc</code> compatible. Very neat!</p>
    <p>A <code class="notranslate">node binding</code> is any property of a node, described in a file, a <code
        class="notranslate">yaml</code> file in our case, so to make our <code class="notranslate">st,stm32-tsc</code>
      node work we need to create a binding file for it, so that we can enforce out properties and rules about those
      properties. And there are strict rules to follow about the location of these files and the naming conventions. The
      binding files must be in the <code class="notranslate">dts/bindings</code> directory of workspace or application
      root, board directories or in modules. We will create our own in the workspace root.</p>
    <p>The naming convention for the binding files are usually <code class="notranslate">vendor,driver.yaml</code>
      (<code class="notranslate">vendor</code> is optional for generic drivers) and usually they reside in subfolders
      for better organization. So we will create ours in <code class="notranslate">misc</code> folder and put the
      binding there.</p>
    <p>And create the <code class="notranslate">st,stm32-tsc.yaml</code> file with the following content:</p>
    <div class="highlight highlight-source-yaml">
      <pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> zephyr/dts/bindings/misc/st,stm32-tsc.yaml</span>

<span class="pl-ent">description</span>: <span class="pl-s">STM32 Tocuh Sensing Controller (TSC) driver</span>

<span class="pl-ent">compatible</span>: <span class="pl-s"><span class="pl-pds">"</span>st,stm32-tsc<span class="pl-pds">"</span></span>

<span class="pl-ent">include</span>: <span class="pl-s">[base.yaml, reset-device.yaml]</span>

<span class="pl-ent">properties</span>:
  <span class="pl-ent">reg</span>:
    <span class="pl-ent">required</span>: <span class="pl-c1">true</span>
  <span class="pl-ent">clocks</span>:
    <span class="pl-ent">required</span>: <span class="pl-c1">true</span>
  <span class="pl-ent">resets</span>:
    <span class="pl-ent">required</span>: <span class="pl-c1">true</span>
  <span class="pl-ent">interrupts</span>:
    <span class="pl-ent">required</span>: <span class="pl-c1">true</span></pre>
    </div>
    <p>as you can tell from the file, all the properties are included from other files Zephyr provides for us, this file
      only makes some of them required. Their definition can be seen in one of these included files; <a
        href="https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/bindings/base/base.yaml"><code
          class="notranslate">base.yaml</code></a></p>
    <div class="highlight highlight-source-yaml">
      <pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> zephyr/dts/bindings/base/base.yaml</span>
<span class="pl-ent">properties</span>:
  <span class="pl-ent">compatible</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">string-array</span>
    <span class="pl-ent">required</span>: <span class="pl-c1">true</span>
    <span class="pl-ent">description</span>: <span class="pl-s">compatible strings</span>

  <span class="pl-ent">reg</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">array</span>
    <span class="pl-ent">description</span>: <span class="pl-s">register space</span>

  <span class="pl-ent">interrupts</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">array</span>
    <span class="pl-ent">description</span>: <span class="pl-s">interrupts for device</span>

  <span class="pl-s">...</span></pre>
    </div>
    <p>This binding file will make sure we have the properties we need, and they are parsed correctly for the relevant
      hardware node with the matching <code class="notranslate">compatible</code> property.</p>
    <p>Again these documents are quite verbose and easy to read and maintain, so that's good. They can also get pretty
      messy if you don't do it right, so please follow the <a
        href="https://docs.zephyrproject.org/latest/guides/dts/bindings.html" rel="nofollow">official documentation</a>
      for more information.</p>
    <p>Of course up to this point we only included and set up bindings for the information to enable the peripheral
      (<code class="notranslate">reg</code>, <code class="notranslate">clocks</code>, <code
        class="notranslate">resets</code> and <code class="notranslate">interrupts</code>), but we also have to
      configure it, which requires additional bindings. We went into detail in the section <a
        href="#understanding-the-hardware">Understanding the Hardware</a> so I will not go into detail here, but
      basically we will need the following information to set up a TSC peripheral:</p>
    <ul>
      <li>IO pins for the electrodes and sampling capacitors</li>
      <li>Pulse generator prescaler value</li>
      <li>Spread spectrum prescaler, deviation and enable</li>
      <li>Charge transfer pulse high and low values</li>
      <li>Max count value</li>
      <li>SYNC signal polarity and enable</li>
    </ul>
    <h4>Pin Control</h4>
    <p>We discussed how configuring the physical pins is a job of another peripheral, <code
        class="notranslate">pintcrl-device.yaml</code> provides some bindings to allow generic nodes to provide pin
      configuration information. It is called <code class="notranslate">pinctrl-X</code> where <code
        class="notranslate">X</code> is the number of the pin group. Take a look at the property;</p>
    <div class="highlight highlight-source-yaml">
      <pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> zephyr/dts/bindings/pinctrl-device.yaml</span>
<span class="pl-ent">pinctrl-0</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">phandles</span>
    <span class="pl-ent">description</span>: <span class="pl-s">|</span>
<span class="pl-s">      Pin configuration/s for the first state. Content is specific to the</span>
<span class="pl-s">      selected pin controller driver implementation.</span>
<span class="pl-s"></span>
<span class="pl-s"></span>...

<span class="pl-ent">pinctrl-x</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">phandles</span>
    <span class="pl-ent">description</span>: <span class="pl-s">|</span>
<span class="pl-s">      Pin configuration/s for the x-th state. Content is specific to the</span>
<span class="pl-s">      selected pin controller driver implementation.</span>
<span class="pl-s"></span><span class="pl-ent">pinctrl-names</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">string-array</span>
    <span class="pl-ent">description</span>: <span class="pl-s">|</span>
<span class="pl-s">      Names for the provided states. The number of names needs to match the</span>
<span class="pl-s">      number of states.</span></pre>
    </div>
    <p>A pin configuration can change based on whether the device is running or in sleep mode to preserve power. So we
      can have multiple states for the pin configuration, separated by the <code
        class="notranslate">pinctrl-names</code> property. It usually is <code class="notranslate">default</code> and
      <code class="notranslate">sleep</code> but can be anything. The <code class="notranslate">phandles</code> property
      is just a reference to another node, so we can point to other nodes which will include the pin information,
      defined somewhere else.</p>
    <p>To have this binding required in our <code class="notranslate">st,stm32-tsc.yaml</code> file we just need to add
      the following lines:</p>
    <div class="highlight highlight-source-yaml">
      <pre class="notranslate"><span class="pl-ent">properties</span>:
  <span class="pl-s">...</span>
  <span class="pl-ent">pinctrl-0</span>:
    <span class="pl-ent">required</span>: <span class="pl-c1">true</span>
  <span class="pl-ent">pinctrl-names</span>:
    <span class="pl-ent">required</span>: <span class="pl-c1">true</span></pre>
    </div>
    <p>The use of this binding in the driver implementation will be discussed in the next sections. But the following
      snippet can give you a glimpse of how it can be used in a device tree node.;</p>
    <pre lang="dts" class="notranslate"><code class="notranslate">&amp;node {
  pinctrl-0 = &lt;&amp;pin_d12_af9&gt;;
  pinctrl-names = "default";
};

&amp;pinctrl {
  pin_d12_af9: pinconfig1 {
    pinmux = &lt;STM32_PINMUX('D', 12, AF9)&gt;;
    drive-open-drain;
  };
};
</code></pre>
    <p>The <code class="notranslate">&amp;</code> symbol works very similar to a pointer in C, in this example we are
      referencing already existing nodes (through labels; <code class="notranslate">node-label: node-name</code>) and
      altering them (<code class="notranslate">node</code> and <code class="notranslate">pinctrl</code>) in the device
      tree. <code class="notranslate">STM32_PINMUX</code> is just a C macro and literally coming from an included header
      file. We can supply the pin, its function and additional properties like <code
        class="notranslate">push-pull</code> or <code class="notranslate">open-drain</code>. And passing the definition
      of these <code class="notranslate">pinctrl</code> nodes to the <code class="notranslate">node</code> node will
      make sure the pins are configured correctly when the driver is loaded.</p>
    <p>So based on this let's define the pins and their functions for this development kit. <a
        href="#hardware-configuration">Schematic tells us</a> there is two pins used in this board, one is a shield
      electrode and the other is the touch electrode itself, of course each with their own sampling capacitor pins. 4 in
      total. These pins are also belong to a group, ST choose group 1 and group 6 for these pins and they nicely provide
      a table for the pins in the <a
        href="https://www.st.com/resource/en/user_manual/um3292-discovery-kit-with-stm32u083mc-mcu-stmicroelectronics.pdf"
        rel="nofollow">UM3292</a> user manual. I also talked about them in the <a
        href="#hardware-configuration">Hardware Configuration</a> section.</p>
    <p>Also In the reference manual we can get the information about which alternate function is used for the TSC group
      configuration for that specific pin, conveniently all of them are <code class="notranslate">AF9</code> for these
      pins. So we can define them in the device tree as follows;</p>
    <pre lang="dts" class="notranslate"><code class="notranslate">&amp;pinctrl {
  tsc_shield_pb12: tsc_shield_pb12 {
    pinmux = &lt;STM32_PINMUX('D', 12, AF9)&gt;;
    drive-open-drain;
  };
  tsc_shield_cs_pb13: tsc_shield_cs_pb13 {
    pinmux = &lt;STM32_PINMUX('D', 13, AF9)&gt;;
  };
  tsc_g6_io1_pd10: tsc_g6_io1_pd10 {
    pinmux = &lt;STM32_PINMUX('D', 10, AF9)&gt;; // TKey CS pin
    drive-open-drain;
  };
  tsc_g6_io2_pd11: tsc_g6_io2_pd11 {
    pinmux = &lt;STM32_PINMUX('D', 11, AF9)&gt;; // TKey Pin
  };
};
</code></pre>
    <p>And later we will provide these pins to the TSC node in the device tree;</p>
    <pre lang="dts" class="notranslate"><code class="notranslate">&amp;tsc {
  pinctrl-0 = &lt;&amp;tsc_shield_pb12 &amp;tsc_shield_cs_pb13 &amp;tsc_g6_io1_pd10 &amp;tsc_g6_io2_pd11&gt;;
  pinctrl-names = "default";
};
</code></pre>
    <p>and use this information to set up the GPIO pins in the driver implementation.</p>
    <p>It is important to define these pins inside the <code class="notranslate">pinctrl</code> parent node so we can
      use the bindings like <code class="notranslate">drive-open-drain</code> and <code
        class="notranslate">pinmux</code> in the child nodes. This node is provided by your vendor in the <code
        class="notranslate">soc</code> device tree file, this file and many other will be included in the final device
      tree file, so many overlays can be used to configure the hardware, SOC DTS files &gt; Board DTS files &gt;
      Application DTS files &gt; Final DTS file.</p>
    <h4>Other Bindings</h4>
    <p>Now we only deal with bindings with basic types, like <code class="notranslate">int</code>, <code
        class="notranslate">enum</code>, <code class="notranslate">string</code> and <code
        class="notranslate">boolean</code>.</p>
    <h5>Pulse Generator Prescaler</h5>
    <p>The pulse generator prescaler is a 3-bit value as discussed in the <a
        href="#tsc-pulse-generator-configuration">Registers and Configurations</a> section, so it can be defined as an
      enum in the binding file.</p>
    <div class="highlight highlight-source-yaml">
      <pre
        class="notranslate"><span class="pl-ent">pulse-generator-prescaler</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">int</span>
    <span class="pl-ent">default</span>: <span class="pl-c1">2</span>
    <span class="pl-ent">description</span>: <span class="pl-s">|</span>
<span class="pl-s">      Prescaler for the pulse generator clock (t_pgclk=f_hclk/prescaler).</span>
<span class="pl-s">      The prescaler is used to generate the charge transfer pulse.</span>
<span class="pl-s">      0: f_hclk/1</span>
<span class="pl-s">      1: f_hclk/2</span>
<span class="pl-s">      2: f_hclk/4</span>
<span class="pl-s">      3: f_hclk/8</span>
<span class="pl-s">      4: f_hclk/16</span>
<span class="pl-s">      5: f_hclk/32</span>
<span class="pl-s">      6: f_hclk/64</span>
<span class="pl-s">      7: f_hclk/128</span>
<span class="pl-s"></span>    <span class="pl-ent">enum</span>: <span class="pl-s">[0, 1, 2, 3, 4, 5, 6, 7]</span></pre>
    </div>
    <h5>Charge Transfer Pulse High and Low</h5>
    <p>These are 4-bit values, this too can be defined as integer enum.</p>
    <div class="highlight highlight-source-yaml">
      <pre
        class="notranslate">  <span class="pl-ent">ctph</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">int</span>
    <span class="pl-ent">default</span>: <span class="pl-c1">2</span>
    <span class="pl-ent">description</span>: <span class="pl-s">|</span>
<span class="pl-s">      Number of cycles for the high state of the </span>
<span class="pl-s">      charge transfer pulse (1 to 16 cycles of t_pgclk).</span>
<span class="pl-s"></span>    <span class="pl-ent">enum</span>: <span class="pl-s">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span>

  <span class="pl-ent">ctpl</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">int</span>
    <span class="pl-ent">default</span>: <span class="pl-c1">2</span>
    <span class="pl-ent">description</span>: <span class="pl-s">|</span>
<span class="pl-s">      Number of cycles for the low state of the </span>
<span class="pl-s">      charge transfer pulse (1 to 16 cycles of t_pgclk).</span>
<span class="pl-s"></span>    <span class="pl-ent">enum</span>: <span class="pl-s">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span></pre>
    </div>
    <h5>Max Count Value</h5>
    <p>This is a 3-bit value, we can define it as an integer enum.</p>
    <div class="highlight highlight-source-yaml">
      <pre
        class="notranslate"><span class="pl-ent">max-count-value</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">int</span>
    <span class="pl-ent">default</span>: <span class="pl-c1">5</span>
    <span class="pl-ent">description</span>: <span class="pl-s">|</span>
<span class="pl-s">      Max number of charge transfer pulses before max count error is generated.</span>
<span class="pl-s">      0: 255</span>
<span class="pl-s">      1: 511</span>
<span class="pl-s">      2: 1023</span>
<span class="pl-s">      3: 2047</span>
<span class="pl-s">      4: 4095</span>
<span class="pl-s">      5: 8191</span>
<span class="pl-s">      6: 16383</span>
<span class="pl-s">      7: 32767</span>
<span class="pl-s"></span>    <span class="pl-ent">enum</span>: <span class="pl-s">[0, 1, 2, 3, 4, 5, 6, 7]</span></pre>
    </div>
    <h5>Spread Spectrum</h5>
    <p>The spread spectrum prescaler is a 1-bit value, it should be easy to define.</p>
    <div class="highlight highlight-source-yaml">
      <pre class="notranslate"><span class="pl-ent">spread-spectrum-prescaler</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">int</span>
    <span class="pl-ent">description</span>: <span class="pl-s">Spread spectrum clock prescaler (t_ssclk)</span>
    <span class="pl-ent">enum</span>:
      - <span class="pl-c1">1</span>
      - <span class="pl-c1">2</span></pre>
    </div>
    <p>and to enable it we can define a boolean property.</p>
    <div class="highlight highlight-source-yaml">
      <pre class="notranslate">  <span class="pl-ent">spread-spectrum</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">boolean</span>
    <span class="pl-ent">description</span>: <span class="pl-s">Spread spectrum enable</span></pre>
    </div>
    <p>These boolean properties are easy to use;</p>
    <pre lang="dts" class="notranslate"><code class="notranslate">&amp;tsc {
  spread-spectrum;
  spread-spectrum-prescaler = &lt;2&gt;;
};
</code></pre>
    <p>We also need to define the deviation value for the spread spectrum, it can have a value from 0 to 127. But for
      convenience we will start from 1 and offset it in the driver implementation.</p>
    <div class="highlight highlight-source-yaml">
      <pre
        class="notranslate"><span class="pl-ent">spread-spectrum-deviation</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">int</span>
    <span class="pl-ent">default</span>: <span class="pl-c1">1</span>
    <span class="pl-ent">description</span>: <span class="pl-s">Spread spectrum deviation (1 to 128 cycles of t_ssclk)</span></pre>
    </div>
    <h5>SYNC Signal</h5>
    <p>We have two properties for the SYNC signal, one is for the polarity and the other is for the enable.</p>
    <div class="highlight highlight-source-yaml">
      <pre
        class="notranslate"><span class="pl-ent">synced-acquisition</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">boolean</span>
    <span class="pl-ent">description</span>: <span class="pl-s">|</span>
<span class="pl-s">      Synchronized acquisition enable. Acquisition starts when START bit and signal on sync pin.</span>
<span class="pl-s">      You have to provide a pinctrl for the sync pin.</span>
<span class="pl-s"></span>
<span class="pl-s"></span>  <span class="pl-ent">syncpol-rising</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">boolean</span>
    <span class="pl-ent">description</span>: <span class="pl-s">Rising synchronization pin polarity, instead of falling</span></pre>
    </div>
    <p>I choose to use a boolean property for the polarity it could also be a string enum, but I think this is more
      readable.</p>
    <h5>IO Default Mode</h5>
    <p>IO mode is 1-bit value, it can be either floating or driven low (default).</p>
    <div class="highlight highlight-source-yaml">
      <pre class="notranslate">  <span class="pl-ent">iodef-float</span>:
    <span class="pl-ent">type</span>: <span class="pl-s">boolean</span>
    <span class="pl-ent">description</span>: <span class="pl-s">|</span>
<span class="pl-s">      I/Os are floating when not used for acquisition.</span>
<span class="pl-s">      If not set, I/Os are driven low.</span></pre>
    </div>
    <h4>Child Nodes and Bindings</h4>
    <p>We talked about the group logic in the <a href="#understanding-the-hardware">Understanding the Hardware</a>
      section. Once we enable the TSC peripheral, we should also enable groups and channels within those groups for
      acquisition. Device tree offers a way to describe these as child nodes of the TSC node. Lets say we can define a
      group node as follows;</p>
    <pre lang="dts" class="notranslate"><code class="notranslate">&amp;tsc {
  group1 {
    group = &lt;1&gt;;
    use-as-shield;****
    channel-ios = &lt;2&gt;;
    sampling-io = &lt;1&gt;;
  };

  group6 {
    group = &lt;6&gt;;
    channel-ios = &lt;2&gt;;
    sampling-io = &lt;1&gt;;
  };
};
</code></pre>
    <p>So this nodes inside the <code class="notranslate">tsc</code> node are called child nodes, and in our case they
      give us information about the group index, channel and sampling io pin bits and one more property to use the group
      as shield (basically configure the group but do not acquire a value from it). We can define these nodes in the
      binding file as follows;</p>
    <div class="highlight highlight-source-yaml">
      <pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> zephyr/dts/bindings/misc/st,stm32-tsc.yaml</span>
<span class="pl-ent">properties</span>:
  <span class="pl-s">...</span>

<span class="pl-ent">child-binding</span>:
  <span class="pl-ent">description</span>: <span class="pl-s">STM32 TSC group configuration</span>
  <span class="pl-ent">properties</span>:
    <span class="pl-ent">group</span>:
      <span class="pl-ent">type</span>: <span class="pl-s">int</span>
      <span class="pl-ent">required</span>: <span class="pl-c1">true</span>
      <span class="pl-ent">description</span>: <span class="pl-s">Group number (0 to 7)</span>
      <span class="pl-ent">enum</span>: <span class="pl-s">[0, 1, 2, 3, 4, 5, 6, 7]</span>

    <span class="pl-ent">channel-ios</span>:
      <span class="pl-ent">type</span>: <span class="pl-s">int</span>
      <span class="pl-ent">description</span>: <span class="pl-s">Channel I/Os to be enabled</span>
      <span class="pl-ent">enum</span>: <span class="pl-s">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span>

    <span class="pl-ent">sampling-io</span>:
      <span class="pl-ent">type</span>: <span class="pl-s">int</span>
      <span class="pl-ent">required</span>: <span class="pl-c1">true</span>
      <span class="pl-ent">description</span>: <span class="pl-s">Channel to be selected for sampling</span>
      <span class="pl-ent">enum</span>: <span class="pl-s">[1, 2, 4, 8]</span>

    <span class="pl-ent">use-as-shield</span>:
      <span class="pl-ent">type</span>: <span class="pl-s">boolean</span>
      <span class="pl-ent">description</span>: <span class="pl-s">|</span>
<span class="pl-s">        Use channel as shield. This configures group but </span>
<span class="pl-s">        does not enable it for acqusition. channel-io is used </span>
<span class="pl-s">        as shield pin and can only have values 1, 2, 4 or 8.</span></pre>
    </div>
    <p>This information unfortunately can not be extracted from the pin information, so child nodes like these are
      required to configure and acquire data from the TSC peripheral.</p>
    <h4>Final Binding File and Device Tree Nodes</h4>
    <p>For the device tree, we will have two definitions in two different files. The first definition is the core
      information about the peripheral, and is the same for all <code class="notranslate">U0</code> series
      microcontrollers. Therefore it has to be inside the main <code class="notranslate">stm32u0.dtsi</code> file which
      all stm32u0 based boards include (device tree files can be nested and included in each other).</p>
    <p>This file already exists in upstream Zephyr, under <a
        href="https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm/st/u0/stm32u0.dtsi"><code
          class="notranslate">dts/arm/st/u0/stm32u0.dtsi</code></a>, we just need to modify it.</p>
    <pre lang="dts" class="notranslate"><code class="notranslate"># zephyr/dts/arm/st/u0/stm32u0.dtsi

soc {
  tsc: tsc@40024000 {
    compatible = "st,stm32-tsc";
    reg = &lt;0x40024000 0x400&gt;;
    clocks = &lt;&amp;rcc STM32_CLOCK_BUS_AHB1 0x01000000&gt;;
    resets = &lt;&amp;rctl STM32_RESET(AHB1, 24U)&gt;;
    interrupts = &lt;21 0&gt;;
    interrupt-names = "global";
    status = "disabled";
    };
};
</code></pre>
    <p>We define the node and let it be disabled by default so our driver wont be compiled into the application until
      <code class="notranslate">status</code> is set to <code class="notranslate">okay</code>.</p>
    <p>The second definition is in the development kit specific file, <code class="notranslate">stm32u083c-dk.dts</code>
      in our case, this file again is defined in the upstream Zephyr, under <a
        href="https://github.com/zephyrproject-rtos/zephyr/blob/main/boards/st/stm32u083c_dk/stm32u083c_dk.dts"><code
          class="notranslate">boards/st/stm32u083c_dk/stm32u083c_dk.dts</code></a>. This file will contain the
      information about the pins and the groups we will use in the TSC peripheral along with the pin configuration.</p>
    <div class="markdown-alert markdown-alert-note">
      <p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1"
          width="16" height="16" aria-hidden="true">
          <path
            d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
          </path>
        </svg>Note</p>
      <p>You can also define these in the <a
          href="https://docs.zephyrproject.org/latest/build/dts/howtos.html#use-devicetree-overlays"
          rel="nofollow">device tree overlay file</a> in your application, and avoid modifying files inside Zephyr
        source, but since we already have a demo board definition we will use that.</p>
      <details>
        <summary> If you want to use an overlay it would look something like this; </summary>
        <pre lang="dts" class="notranslate"><code class="notranslate">include "...";
&amp;soc {
  tsc: tsc@40024000 {
    status = "okay";
    clocks = &lt;&amp;rcc STM32_CLOCK_BUS_AHB1 0x01000000&gt;;
    resets = &lt;&amp;rctl STM32_RESET(AHB1, 24U)&gt;;
    interrupts = &lt;21 0&gt;;
    pinctrl-0 = &lt;&amp;tsc_shield_pb12 &amp;tsc_shield_cs_pb13 &amp;tsc_g6_io1_pd10 &amp;tsc_g6_io2_pd11&gt;;
    pinctrl-names = "default";
    spread-spectrum;
    spread-spectrum-prescaler = &lt;2&gt;;
    spread-spectrum-deviation = &lt;100&gt;;
    g1 {
      group = &lt;1&gt;;
      use-as-shield;
      channel-ios = &lt;2&gt;;
      sampling-io = &lt;1&gt;;
    };
    g6 {
      group = &lt;6&gt;;
      channel-ios = &lt;2&gt;;
      sampling-io = &lt;1&gt;;
    };
  };
};

&amp;pinctrl {
   tsc_shield_pb12: tsc_shield_pb12 {
    pinmux = &lt;STM32_PINMUX('D', 12, AF9)&gt;;
    drive-open-drain;
  };
   tsc_shield_cs_pb13: tsc_shield_cs_pb13 {
    pinmux = &lt;STM32_PINMUX('D', 13, AF9)&gt;;
  };
   tsc_g6_io1_pd10: tsc_g6_io1_pd10 {
    pinmux = &lt;STM32_PINMUX('D', 10, AF9)&gt;; // TKey CS pin
    drive-open-drain;
  };
   tsc_g6_io2_pd11: tsc_g6_io2_pd11 {
    pinmux = &lt;STM32_PINMUX('D', 11, AF9)&gt;; // TKey Pin
  };
};
</code></pre>
      </details>
    </div>
    <pre lang="dts" class="notranslate"><code class="notranslate"># zephyr/boards/st/stm32u083c_dk/stm32u083c_dk.dts

#include &lt;zephyr/dt-bindings/misc/stm32-tsc-defines.h&gt; 

&amp;tsc {
  status = "disabled";
  pinctrl-0 = &lt;&amp;tsc_shield_pb12 &amp;tsc_shield_cs_pb13 &amp;tsc_g6_io1_pd10 &amp;tsc_g6_io2_pd11&gt;;
  pinctrl-names = "default";
  spread-spectrum;
  spread-spectrum-prescaler = &lt;2&gt;;
  spread-spectrum-deviation = &lt;100&gt;;

  g1 {
    group = &lt;1&gt;;
    use-as-shield;
    channel-ios = &lt;2&gt;;
    sampling-io = &lt;1&gt;;
  };

  g6 {
    group = &lt;6&gt;;
    channel-ios = &lt;2&gt;;
    sampling-io = &lt;1&gt;;
  };
};

&amp;pinctrl {
   tsc_shield_pb12: tsc_shield_pb12 {
    pinmux = &lt;STM32_PINMUX('D', 12, AF9)&gt;;
    drive-open-drain;
  };
   tsc_shield_cs_pb13: tsc_shield_cs_pb13 {
    pinmux = &lt;STM32_PINMUX('D', 13, AF9)&gt;;
  };
   tsc_g6_io1_pd10: tsc_g6_io1_pd10 {
    pinmux = &lt;STM32_PINMUX('D', 10, AF9)&gt;; // TKey CS pin
    drive-open-drain;
  };
   tsc_g6_io2_pd11: tsc_g6_io2_pd11 {
    pinmux = &lt;STM32_PINMUX('D', 11, AF9)&gt;; // TKey Pin
  };
};
</code></pre>
    <p>The peripheral and the groups are defined as child nodes of the TSC node. Pins are supplied and spread spectrum
      feature is enabled and configured. The <code class="notranslate">status</code> property is set to <code
        class="notranslate">disabled</code> by default, users will be able to enable this in application overlay file.
    </p>
    <p>Notice how this information could only be given in the development kit specific file instead of the soc
      definition, because the pins are different in every board. And other bindings are also application specific.</p>
    <p>When device tree compiler compiles all the device tree files into one final device tree, we get the following
      node;</p>
    <pre lang="dts" class="notranslate"><code class="notranslate">/ {
  soc {
    pinctrl {
      ...
      tsc_shield_pb12: tsc_shield_pb12 {
        pinmux = &lt; 0x789 &gt;;
        drive-open-drain;
        phandle = &lt; 0x10 &gt;;
      };
      tsc_shield_cs_pb13: tsc_shield_cs_pb13 {
        pinmux = &lt; 0x7a9 &gt;;
        phandle = &lt; 0x11 &gt;;
      };
      tsc_g6_io1_pd10: tsc_g6_io1_pd10 {
        pinmux = &lt; 0x749 &gt;;
        drive-open-drain;
        phandle = &lt; 0x12 &gt;;
      };
      tsc_g6_io2_pd11: tsc_g6_io2_pd11 {
        pinmux = &lt; 0x769 &gt;;
        phandle = &lt; 0x13 &gt;;
      };
    };
    tsc: tsc@40024000 {
      compatible = "st,stm32-tsc";
      reg = &lt; 0x40024000 0x400 &gt;;
      clocks = &lt; &amp;rcc 0x48 0x1000000 &gt;;
      resets = &lt; &amp;rctl 0x518 &gt;;
      interrupts = &lt; 0x15 0x0 &gt;;
      status = "disabled";
      pinctrl-0 = &lt; &amp;tsc_shield_pb12 &amp;tsc_shield_cs_pb13 &amp;tsc_g6_io1_pd10 &amp;tsc_g6_io2_pd11 &gt;;
      pinctrl-names = "default";
      spread-spectrum;
      spread-spectrum-prescaler = &lt; 0x2 &gt;;
      spread-spectrum-deviation = &lt; 0x64 &gt;;
      g1 {
        group = &lt; 0x1 &gt;;
        use-as-shield;
        channel-ios = &lt; 0x2 &gt;;
        sampling-io = &lt; 0x1 &gt;;
      };
      g6 {
        group = &lt; 0x6 &gt;;
        channel-ios = &lt; 0x2 &gt;;
        sampling-io = &lt; 0x1 &gt;;
      };
    };
  }
}
</code></pre>
    <p>All files included and all macros expanded, this is the final device tree node that will be converted to a header
      file (instead of a binary blob used in Linux) containing all this information as C defines, so they will take up
      no space if not used. This generated header file can not be used directly as it is pretty verbose and hard to
      read;</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-c">// devicetree_generated.h</span>

...

<span class="pl-c">/*</span>
<span class="pl-c"> * Devicetree node: /soc/tsc@40024000</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * Node identifier: DT_N_S_soc_S_tsc_40024000</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * Binding (compatible = st,stm32-tsc):</span>
<span class="pl-c"> *   /workdir/zephyr/dts/bindings/misc/st,stm32-tsc.yaml</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * (Descriptions have moved to the Devicetree Bindings Index</span>
<span class="pl-c"> * in the documentation.)</span>
<span class="pl-c"> */</span>

<span class="pl-c">/* Node's full path: */</span>
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_PATH</span> "/soc/tsc@40024000"

<span class="pl-c">/* Node's name with unit-address: */</span>
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_FULL_NAME</span> "tsc@40024000"

<span class="pl-c">/* Node parent (/soc) identifier: */</span>
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_PARENT</span> DT_N_S_soc

<span class="pl-c">/* Macros for properties that are special in the specification: */</span>
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_REG_NUM</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_REG_IDX_0_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_REG_IDX_0_VAL_ADDRESS</span> 1073889280 /* 0x40024000 */
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_REG_IDX_0_VAL_SIZE</span> 1024 /* 0x400 */
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_RANGES_NUM</span> 0
<span class="pl-k">#define</span> <span class="pl-en">DT_N_S_soc_S_tsc_40024000_FOREACH_RANGE</span>(<span class="pl-s1">fn</span>) 
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_NUM</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_irq</span> 21
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_irq_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_priority</span> 0
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_priority_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_CONTROLLER</span> DT_N_S_soc_S_interrupt_controller_e000e100
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_LEVEL</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_NAME_global_VAL_irq</span> DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_irq
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_NAME_global_VAL_irq_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_NAME_global_VAL_priority</span> DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_priority
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_NAME_global_VAL_priority_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_IRQ_NAME_global_CONTROLLER</span> DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_CONTROLLER
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_COMPAT_MATCHES_st_stm32_tsc</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_COMPAT_VENDOR_IDX_0_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_COMPAT_VENDOR_IDX_0</span> "STMicroelectronics"
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_COMPAT_MODEL_IDX_0_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_COMPAT_MODEL_IDX_0</span> "stm32-tsc"
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_STATUS_okay</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_resets_LEN</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_resets_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_pulse_generator_prescaler</span> 2
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_pulse_generator_prescaler_ENUM_IDX</span> 2
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_pulse_generator_prescaler_ENUM_VAL_2_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_pulse_generator_prescaler_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_ctph</span> 2
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_ctph_ENUM_IDX</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_ctph_ENUM_VAL_2_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_ctph_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_ctpl</span> 2
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_ctpl_ENUM_IDX</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_ctpl_ENUM_VAL_2_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_ctpl_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_spread_spectrum</span> 0
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_spread_spectrum_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_spread_spectrum_deviation</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_spread_spectrum_deviation_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_max_count_value</span> 5
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_max_count_value_ENUM_IDX</span> 5
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_max_count_value_ENUM_VAL_5_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_max_count_value_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_iodef_float</span> 0
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_iodef_float_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_synced_acquisition</span> 0
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_synced_acquisition_EXISTS</span> 1
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_syncpol_rising</span> 0
<span class="pl-k">#define</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_syncpol_rising_EXISTS</span> 1

...</pre>
    </div>
    <p>The values are not meant to be accessed directly by us, instead <a
        href="https://docs.zephyrproject.org/latest/build/dts/api-usage.html" rel="nofollow">a macro library</a> is used
      to get the values programmatically. In my opinion this part needs a rework because it is very hard to trace macros
      when something is not right and you want to debug, but I think Zephyr is already working on a revised solution.
    </p>
    <p>An example of how to access these values can be seen below;</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/devicetree.h&gt;</span>

<span class="pl-en">DT_PROP</span>(<span class="pl-en">DT_NODELABEL</span>(<span class="pl-s1">tsc</span>), <span class="pl-s1">pulse_generator_prescaler</span>); <span class="pl-c">// 2</span></pre>
    </div>
    <h3>Plumbing Device Tree to Driver Code</h3>
    <p>We have a binding file that defines the information the driver would need to work with a general STM32 TSC
      peripheral, and we have a device tree node that describes a specific instance of this peripheral. Now we need to
      write a driver that will use this information to configure and use the peripheral. From now on the idea is that
      this hardware node can be inside any ARM Cortex-M based STM32 microcontroller, and we will be able to use the same
      driver for all of them. Also our code wont only run on a specific hardware node, but instead may work on any
      hardware node that has the same properties (same <code class="notranslate">compatible</code> property in the
      device tree), so multiple TSC hardware can be used in the same application even though ST has no MCU with such
      feature, it's best practice to write drivers this way in case ST releases a new MCU with multiple TSC peripherals.
    </p>
    <p>We therefore need to store all these information in a struct inside our MCU, preferably in flash memory so it
      won't take up any RAM.</p>
    <h4>Device Tree Macros</h4>
    <p>Zephyr provides us with a set of macros to access the device tree properties in the generated header file. These
      are usually harder to debug when something goes wrong but it makes everything compile-time. To use it we need to
      include the API from <code class="notranslate">zephyr/include/zephyr/devicetree.h</code>.;</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/devicetree.h&gt;</span></pre>
    </div>
    <h4>Register Base Address</h4>
    <p>The memory address is the first thing we care about. it will be a 32-bit pointer to the base address of the TSC
      peripheral and can be casted to a pointer to a struct that represents the TSC peripheral memory layout.</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-k">#define</span> <span class="pl-en">TSC_BASE</span>(<span class="pl-s1">node</span>) ((TSC_TypeDef *)DT_INST_REG_ADDR(node))</pre>
    </div>
    <p>So <code class="notranslate">TSC_BASE</code> macro takes a node and calls Zephyr macro <code
        class="notranslate">DT_INST_REG_ADDR</code> to get the <code class="notranslate">reg</code> property of the
      node, which is the base address of the peripheral. This is a pointer to the memory mapped registers of the
      peripheral, we than cast it to a pointer to a struct that represents the TSC peripheral memory layout and we have
      the peripheral ready to use.</p>
    <div class="markdown-alert markdown-alert-note">
      <p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1"
          width="16" height="16" aria-hidden="true">
          <path
            d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
          </path>
        </svg>Note</p>
      <p>Since we are using a multi-instance compatible driver, we use instances, therefore we use the macro <code
          class="notranslate">DT_INST_REG_ADDR</code> instead of <code class="notranslate">DT_REG_ADDR</code> which is
        used for single instance drivers. when using <code class="notranslate">_INST</code> macros we need to provide
        <code class="notranslate">DT_DRV_COMPAT</code> in the beggining of the driver source file later when we create
        the driver.</p>
    </div>
    <p><code class="notranslate">TSC_TypeDef</code> is provided by ST and is defined as a simple struct;</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">typedef</span> <span class="pl-k">struct</span>
{
  <span class="pl-k">volatile</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">CR</span>;            <span class="pl-c">/*!&lt; TSC control register,                                     Address offset: 0x00 */</span>
  <span class="pl-k">volatile</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">IER</span>;           <span class="pl-c">/*!&lt; TSC interrupt enable register,                            Address offset: 0x04 */</span>
  <span class="pl-k">volatile</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">ICR</span>;           <span class="pl-c">/*!&lt; TSC interrupt clear register,                             Address offset: 0x08 */</span>
  <span class="pl-k">volatile</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">ISR</span>;           <span class="pl-c">/*!&lt; TSC interrupt status register,                            Address offset: 0x0C */</span>
  <span class="pl-k">volatile</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">IOHCR</span>;         <span class="pl-c">/*!&lt; TSC I/O hysteresis control register,                      Address offset: 0x10 */</span>
  <span class="pl-smi">uint32_t</span>      <span class="pl-c1">RESERVED1</span>;     <span class="pl-c">/*!&lt; Reserved,                                                 Address offset: 0x14 */</span>
  <span class="pl-k">volatile</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">IOASCR</span>;        <span class="pl-c">/*!&lt; TSC I/O analog switch control register,                   Address offset: 0x18 */</span>
  <span class="pl-smi">uint32_t</span>      <span class="pl-c1">RESERVED2</span>;     <span class="pl-c">/*!&lt; Reserved,                                                 Address offset: 0x1C */</span>
  <span class="pl-k">volatile</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">IOSCR</span>;         <span class="pl-c">/*!&lt; TSC I/O sampling control register,                        Address offset: 0x20 */</span>
  <span class="pl-smi">uint32_t</span>      <span class="pl-c1">RESERVED3</span>;     <span class="pl-c">/*!&lt; Reserved,                                                 Address offset: 0x24 */</span>
  <span class="pl-k">volatile</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">IOCCR</span>;         <span class="pl-c">/*!&lt; TSC I/O channel control register,                         Address offset: 0x28 */</span>
  <span class="pl-smi">uint32_t</span>      <span class="pl-c1">RESERVED4</span>;     <span class="pl-c">/*!&lt; Reserved,                                                 Address offset: 0x2C */</span>
  <span class="pl-k">volatile</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">IOGCSR</span>;        <span class="pl-c">/*!&lt; TSC I/O group control status register,                    Address offset: 0x30 */</span>
  <span class="pl-k">volatile</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">IOGXCR</span>[<span class="pl-c1">8</span>];     <span class="pl-c">/*!&lt; TSC I/O group x counter register,                         Address offset: 0x34-50 */</span>
} <span class="pl-smi">TSC_TypeDef</span>;</pre>
    </div>
    <p>Pretty simple and efficient so far. This macro will expand into a simple pointer to the memory mapped registers
      of the TSC peripheral after preprocessor does its job.</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate">((<span class="pl-smi">TSC_TypeDef</span> <span class="pl-c1">*</span>)<span class="pl-s1">DT_N_S_soc_S_tsc_40024000_REG_IDX_0_VAL_ADDRESS</span>) <span class="pl-c">// 0x40024000</span></pre>
    </div>
    <h4>Clock and Reset Control</h4>
    <p>We now need the <code class="notranslate">clocks</code> property to get the device responsible for clock control
      in the system, we already passed the clock controller <code class="notranslate">RCC</code> as a reference to the
      TSC device node.</p>
    <p>Clock and reset control is common to ARM based MCUs so Zephyr provides a <a
        href="https://docs.zephyrproject.org/latest/hardware/peripherals/clock_control.html" rel="nofollow">Clock
        Control Peripheral API</a> to vendors to develop their own clock and reset control drivers. We can use this API
      to enable the clock for the TSC peripheral.</p>
    <p>Here is the API to enable the clock for a subsystem (TSC in our case);</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-c">/* zephyr/drivers/clock_control.h */</span>

<span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-en">clock_control_on</span> ( <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>, <span class="pl-smi">clock_control_subsys_t</span>  <span class="pl-s1">sys</span> );</pre>
    </div>
    <p>This means we can just pass a generic <code class="notranslate">device</code> that has been defined in the device
      tree <code class="notranslate">clocks</code> property to the generic <code
        class="notranslate">clock_control_on</code> with the peripheral and bus information and it will do the job for
      us. The <code class="notranslate">sys</code> argument is the opaque data to the Clock Control Peripheral API (void
      pointer) and will be passed to the API implementer that will cast and use the data to enable the clock for the TSC
      peripheral, this corresponds to the <code class="notranslate">STM32_CLOCK_BUS_AHB1 (0x48)</code> and <code
        class="notranslate">0x01000000</code> value in the device tree node. We can extract these values on our own but
      ST provides a nice macro to do this for us.</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/clock_control/stm32_clock_control.h&gt;</span>

<span class="pl-k">#define</span> <span class="pl-en">TSC_CLOCK</span>(<span class="pl-s1">node</span>) (struct stm32_pclken) STM32_CLOCK_INFO(0, node);</pre>
    </div>
    <p>This macro will expand into more device tree macros and will give us the clock information for the TSC
      peripheral.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-c">/* zepryr/include/drivers/clock_control/stm32_clock_control.h */</span>

<span class="pl-k">#define</span> <span class="pl-en">STM32_CLOCK_INFO</span>(<span class="pl-s1">clk_index</span>, <span class="pl-s1">node_id</span>)    \
 {        \
 .enr = DT_CLOCKS_CELL_BY_IDX(node_id, clk_index, bits),  \
 .bus = DT_CLOCKS_CELL_BY_IDX(node_id, clk_index, bus)  \
 }</pre>
    </div>
    <div class="markdown-alert markdown-alert-note">
      <p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1"
          width="16" height="16" aria-hidden="true">
          <path
            d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
          </path>
        </svg>Note</p>
      <p>We are only using one clock for this peripheral but multiple can be defined, in that case a different macro
        <code class="notranslate">STM32_DT_INST_CLOCKS</code> is used instead.</p>
    </div>
    <p>Which will expand into;</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate">{
  .<span class="pl-s1">enr</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_clocks_IDX_0_VAL_bus</span> <span class="pl-c">// 0x48</span>
  .<span class="pl-c1">bus</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_clocks_IDX_0_VAL_bits</span> <span class="pl-c">// 0x1000000</span>
}</pre>
    </div>
    <p>Reset control is even simpler, we again use the <code class="notranslate">resets</code> property to get the
      device responsible for reset control in the system, and we can use the same API to reset the TSC peripheral. We
      will use the <a href="https://docs.zephyrproject.org/latest/hardware/peripherals/reset.html" rel="nofollow">Reset
        Controller Peripheral API</a> to reset the TSC peripheral.</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/reset.h&gt;</span>

<span class="pl-k">#define</span> <span class="pl-en">TSC_RESET</span>(<span class="pl-s1">node</span>) (const struct reset_dt_spec *) RESET_DT_SPEC_INST_GET_OR(node, NULL)</pre>
    </div>
    <p>This macro will get the <code class="notranslate">resets</code> property if it exists, <code
        class="notranslate">NULL</code> otherwise. This is a pointer to the reset controller device that will be used to
      reset the TSC peripheral. And <a href="https://docs.zephyrproject.org/apidoc/latest/structreset__dt__spec.html"
        rel="nofollow"><code class="notranslate">reset_dt_spec</code></a> is a struct that contains the reset controller
      device and the reset line number, <code class="notranslate">24</code> in our case.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">struct</span> <span class="pl-smi">reset_dt_spec</span> {
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-c1">dev</span>;
  <span class="pl-smi">uint32_t</span> <span class="pl-c1">line_num</span>;
};</pre>
    </div>
    <p>So this will expand into</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate">(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">reset_dt_spec</span> <span class="pl-c1">*</span>) { .<span class="pl-c1">dev</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_resets</span>, .<span class="pl-c1">line_num</span> <span class="pl-c1">=</span> <span class="pl-c1">24</span> }</pre>
    </div>
    <p>With this struct we can use variety of reset control APIs to reset the TSC peripheral.</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-c">/* zephyr/include/drivers/reset.h */</span>
<span class="pl-smi">int</span> <span class="pl-en">reset_status_dt</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">reset_dt_spec</span> <span class="pl-c1">*</span><span class="pl-s1">spec</span>, <span class="pl-smi">uint8_t</span> <span class="pl-c1">*</span><span class="pl-s1">status</span>);
<span class="pl-smi">int</span> <span class="pl-en">reset_line_assert_dt</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">reset_dt_spec</span> <span class="pl-c1">*</span><span class="pl-s1">spec</span>);
<span class="pl-smi">int</span> <span class="pl-en">reset_line_deassert_dt</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">reset_dt_spec</span> <span class="pl-c1">*</span><span class="pl-s1">spec</span>);
<span class="pl-smi">int</span> <span class="pl-en">reset_line_toggle_dt</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">reset_dt_spec</span> <span class="pl-c1">*</span><span class="pl-s1">spec</span>)</pre>
    </div>
    <h4>Pin Controller</h4>
    <p>This is another peripheral we have to deal with, again Zephyr has a <a
        href="https://docs.zephyrproject.org/latest/hardware/pinctrl/index.html" rel="nofollow">Pin Controller
        Peripheral API</a> to handle the pin configuration. We can use this API to configure the pins for the TSC
      peripheral.</p>
    <p>This is a little tricky because the pin controller configs needs to be defined, but there is a macro for it too.
    </p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/pinctrl.h&gt;</span>

<span class="pl-k">#define</span> <span class="pl-en">TSC_PINCTRL_DEFINE</span>(<span class="pl-s1">node</span>) PINCTRL_DT_INST_DEFINE(node)
<span class="pl-k">#define</span> <span class="pl-en">TSC_PINCTRL</span>(<span class="pl-s1">node</span>) ((const struct pinctrl_dev_config *) PINCTRL_DT_INST_DEV_CONFIG_GET(node))</pre>
    </div>
    <p>We can then use this struct to apply all the pin states at runtime.</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-smi">int</span> <span class="pl-en">pinctrl_apply_state</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">pinctrl_dev_config</span> <span class="pl-c1">*</span><span class="pl-s1">config</span>, <span class="pl-smi">uint8_t</span> <span class="pl-s1">id</span>)</pre>
    </div>
    <p><code class="notranslate">id</code> is the pin control name property, <code
        class="notranslate">default (0)</code> in our case.</p>
    <h4>Group Configurations</h4>
    <p>From now on we only have basic types and need no additional subsystem or peripheral API.</p>
    <p>A driver instance can have many groups, so lets define a struct to hold the group configurations.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_group_config</span>
{
  <span class="pl-smi">uint8_t</span> <span class="pl-c1">group</span>;
  <span class="pl-smi">uint8_t</span> <span class="pl-c1">channel_ios</span>;
  <span class="pl-smi">uint8_t</span> <span class="pl-c1">sampling_io</span>;
  <span class="pl-smi">bool</span> <span class="pl-c1">use_as_shield</span>;
};</pre>
    </div>
    <p>To fill this struct we need to access the child nodes of the TSC node in the device tree.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_GROUP</span>(<span class="pl-s1">node</span>) 
  { 
    .<span class="pl-s1">group</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-s1">node</span>, <span class="pl-s1">group</span>), 
    .<span class="pl-c1">channel_ios</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-s1">node</span>, <span class="pl-s1">channel_ios</span>), 
    .<span class="pl-c1">sampling_io</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-s1">node</span>, <span class="pl-s1">sampling_io</span>), 
    .<span class="pl-c1">use_as_shield</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-s1">node</span>, <span class="pl-s1">use_as_shield</span>), 
  },</pre>
    </div>
    <p>This macro will expand into the following code;</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate">{
  .<span class="pl-s1">group</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_group</span>,
  .<span class="pl-c1">channel_ios</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_channel_ios</span>,
  .<span class="pl-c1">sampling_io</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_sampling_io</span>,
  .<span class="pl-c1">use_as_shield</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_use_as_shield</span>,
},</pre>
    </div>
    <p>To define multiple of these, Zephyr provides a macro <code
        class="notranslate">DT_INST_FOREACH_CHILD_STATUS_OKAY</code> that will iterate over all the child nodes of a
      parent node and call a function for each child node that has a status of <code class="notranslate">okay</code>.
    </p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_GROUPS</span>(<span class="pl-s1">node</span>) (const struct stm32_tsc_group_config[]) { 
  <span class="pl-en">DT_INST_FOREACH_CHILD_STATUS_OKAY</span>(<span class="pl-s1">node</span>, <span class="pl-c1">STM32_TSC_GROUP</span>) 
}</pre>
    </div>
    <p>This will eventually expand into;</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate">(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_group_config</span>[]) {
  {
    .<span class="pl-c1">group</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_group</span>,
    .<span class="pl-c1">channel_ios</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_channel_ios</span>,
    .<span class="pl-c1">sampling_io</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_sampling_io</span>,
    .<span class="pl-c1">use_as_shield</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_use_as_shield</span>,
  },
  {
    .<span class="pl-c1">group</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g6_group</span>,
    .<span class="pl-c1">channel_ios</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g6_channel_ios</span>,
    .<span class="pl-c1">sampling_io</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g6_sampling_io</span>,
    .<span class="pl-c1">use_as_shield</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g6_use_as_shield</span>,
  }
}</pre>
    </div>
    <h4>TSC Configuration</h4>
    <p>Finally we need a struct to hold all the information about the TSC peripheral, including the base address, clock
      and reset control, pin controller, group configurations and other properties.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span>
{
  <span class="pl-smi">TSC_TypeDef</span> <span class="pl-c1">*</span><span class="pl-c1">tsc</span>;
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_pclken</span> <span class="pl-c1">*</span><span class="pl-c1">pclken</span>;
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">reset_dt_spec</span> <span class="pl-c1">*</span><span class="pl-c1">reset</span>;
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">pinctrl_dev_config</span> <span class="pl-c1">*</span><span class="pl-c1">pcfg</span>;
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_group_config</span> <span class="pl-c1">*</span><span class="pl-c1">groups</span>;
  <span class="pl-smi">uint8_t</span> <span class="pl-c1">groups_size</span>;
  <span class="pl-smi">uint8_t</span> <span class="pl-c1">pgpsc</span>;
  <span class="pl-smi">uint8_t</span> <span class="pl-c1">ctph</span>;
  <span class="pl-smi">uint8_t</span> <span class="pl-c1">ctpl</span>;
  <span class="pl-smi">uint8_t</span> <span class="pl-c1">sscpsc</span>;
  <span class="pl-smi">uint8_t</span> <span class="pl-c1">ssd</span>;
  <span class="pl-smi">uint8_t</span> <span class="pl-c1">max_count</span>;
  <span class="pl-smi">bool</span> <span class="pl-c1">spread_spectrum</span>;
  <span class="pl-smi">bool</span> <span class="pl-c1">sync_acq</span>;
  <span class="pl-smi">bool</span> <span class="pl-c1">sync_pol</span>;
  <span class="pl-smi">bool</span> <span class="pl-c1">iodef_float</span>;

  <span class="pl-smi">void</span> (<span class="pl-c1">*</span><span class="pl-c1">irq_func</span>)(<span class="pl-smi">void</span>);
};</pre>
    </div>
    <h4>Putting it all together</h4>
    <p>Once we put it all together we get a big initialization macro (backlashes are omitted for readability);</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-k">#define</span> <span class="pl-en">TSC_GROUP</span>(<span class="pl-s1">node</span>) 
  { 
    .<span class="pl-s1">group</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-s1">node</span>, <span class="pl-s1">group</span>), 
    .<span class="pl-c1">channel_ios</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-s1">node</span>, <span class="pl-s1">channel_ios</span>), 
    .<span class="pl-c1">sampling_io</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-s1">node</span>, <span class="pl-s1">sampling_io</span>), 
    .<span class="pl-c1">use_as_shield</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-s1">node</span>, <span class="pl-s1">use_as_shield</span>), 
  },

<span class="pl-k">#define</span> <span class="pl-en">TSC_GROUPS</span>(<span class="pl-s1">node</span>) 
  (const struct stm32_tsc_group_config[]) { 
    <span class="pl-en">DT_INST_FOREACH_CHILD_STATUS_OKAY</span>(<span class="pl-s1">node</span>, <span class="pl-c1">STM32_TSC_GROUP</span>) 
  }

<span class="pl-k">#define</span> <span class="pl-en">TSC_BASE</span>(<span class="pl-s1">node</span>) ((TSC_TypeDef *)DT_INST_REG_ADDR(node))
<span class="pl-k">#define</span> <span class="pl-en">TSC_CLOCK</span>(<span class="pl-s1">node</span>) (struct stm32_pclken) STM32_CLOCK_INFO(0, node)
<span class="pl-k">#define</span> <span class="pl-en">TSC_RESET</span>(<span class="pl-s1">node</span>) (const struct reset_dt_spec) RESET_DT_SPEC_INST_GET_OR(node, NULL)
<span class="pl-k">#define</span> <span class="pl-en">TSC_PINCTRL_DEFINE</span>(<span class="pl-s1">node</span>) PINCTRL_DT_INST_DEFINE(node)
<span class="pl-k">#define</span> <span class="pl-en">TSC_PINCTRL</span>(<span class="pl-s1">node</span>) ((const struct pinctrl_dev_config *) PINCTRL_DT_INST_DEV_CONFIG_GET(node))

<span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_INIT</span>(<span class="pl-s1">node</span>)

  static void stm32_tsc_irq_init_##node(void){
    <span class="pl-en">IRQ_CONNECT</span>(<span class="pl-en">DT_INST_IRQN</span>(<span class="pl-s1">node</span>), <span class="pl-en">DT_INST_IRQ</span>(<span class="pl-s1">node</span>, <span class="pl-s1">priority</span>), <span class="pl-s1">stm32_tsc_isr</span>, <span class="pl-en">DEVICE_DT_INST_GET</span>(<span class="pl-s1">node</span>), <span class="pl-c1">0</span>);
    <span class="pl-en">irq_enable</span>(<span class="pl-en">DT_INST_IRQN</span>(<span class="pl-s1">node</span>));
  };

  <span class="pl-en">TSC_PINCTRL_DEFINE</span>(<span class="pl-s1">node</span>);

  <span class="pl-k">static</span> <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_group_config</span> <span class="pl-s1">groups</span>[] <span class="pl-c1">=</span> <span class="pl-en">TSC_GROUPS</span>(<span class="pl-s1">node</span>);

  <span class="pl-k">static</span> <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-s1">tsc_config</span>#<span class="pl-k">#node</span> <span class="pl-c1">=</span> 
  {
    .<span class="pl-c1">tsc</span> <span class="pl-c1">=</span> <span class="pl-en">TSC_BASE</span>(<span class="pl-s1">node</span>),
    .<span class="pl-c1">pclken</span> <span class="pl-c1">=</span> <span class="pl-en">TSC_CLOCK</span>(<span class="pl-s1">node</span>),
    .<span class="pl-c1">reset</span> <span class="pl-c1">=</span> <span class="pl-en">TSC_RESET</span>(<span class="pl-s1">node</span>),
    .<span class="pl-c1">pcfg</span> <span class="pl-c1">=</span> <span class="pl-en">TSC_PINCTRL</span>(<span class="pl-s1">node</span>),
    .<span class="pl-c1">groups</span> <span class="pl-c1">=</span> <span class="pl-s1">groups</span>,
    .<span class="pl-c1">groups_size</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_CHILD_NUM_STATUS_OKAY</span>(<span class="pl-s1">groups</span>),
    .<span class="pl-c1">pgpsc</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_PROP_OR</span>(<span class="pl-s1">node</span>, <span class="pl-s1">pulse_generator_prescaler</span>, <span class="pl-c1">2</span>),
    .<span class="pl-c1">ctph</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_PROP_OR</span>(<span class="pl-s1">node</span>, <span class="pl-s1">ctph</span>, <span class="pl-c1">2</span>),
    .<span class="pl-c1">ctpl</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_PROP_OR</span>(<span class="pl-s1">node</span>, <span class="pl-s1">ctpl</span>, <span class="pl-c1">2</span>),
    .<span class="pl-c1">sscpsc</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_PROP_OR</span>(<span class="pl-s1">node</span>, <span class="pl-s1">spread_spectrum_prescaler</span>, <span class="pl-c1">1</span>),
    .<span class="pl-c1">ssd</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_PROP_OR</span>(<span class="pl-s1">node</span>, <span class="pl-s1">spread_spectrum_deviation</span>, <span class="pl-c1">1</span>),
    .<span class="pl-c1">max_count</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_PROP_OR</span>(<span class="pl-s1">node</span>, <span class="pl-s1">max_count_value</span>, <span class="pl-c1">5</span>),
    .<span class="pl-c1">spread_spectrum</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_PROP_OR</span>(<span class="pl-s1">node</span>, <span class="pl-s1">spread_spectrum</span>, false),
    .<span class="pl-c1">sync_acq</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_PROP_OR</span>(<span class="pl-s1">node</span>, <span class="pl-s1">synced_acquisition</span>, false),
    .<span class="pl-c1">sync_pol</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_PROP_OR</span>(<span class="pl-s1">node</span>, <span class="pl-s1">syncpol_rising</span>, false),
    .<span class="pl-c1">iodef_float</span> <span class="pl-c1">=</span> <span class="pl-en">DT_INST_PROP_OR</span>(<span class="pl-s1">node</span>, <span class="pl-s1">iodef_float</span>, false),
    .<span class="pl-c1">irq_func</span> <span class="pl-c1">=</span> <span class="pl-s1">stm32_tsc_irq_init_</span>#<span class="pl-k">#node</span>,
  };

  <span class="pl-en">DEVICE_DT_INST_DEFINE</span>(<span class="pl-s1">node</span>, <span class="pl-s1">stm32_tsc_init</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">stm32_tsc_cfg_</span>#<span class="pl-k">#node</span>, <span class="pl-c1">POST_KERNEL</span>, <span class="pl-c1">CONFIG_KERNEL_INIT_PRIORITY_DEFAULT</span>, <span class="pl-c1">NULL</span>);</pre>
    </div>
    <p>When Zephyr starts booting, it will call all drivers' initialization functions, so when we enter <code
        class="notranslate">main()</code> we will have everything ready for our application. To enable Zephyr to pick up
      our driver and call it before main <code class="notranslate">DEVICE_DT_INST_DEFINE</code> is used. This macro has
      parameters <code class="notranslate">node_id</code>, initialization function, power management function (<code
        class="notranslate">NULL</code> for us), a pointer to device data in RAM (<code class="notranslate">NULL</code>
      for us), a pointer to device data in FLASH (cast to void pointer as we will see in <a
        href="#peripheral-apis">Peripheral API</a> section), initialization level, initialization priority, and a
      pointer to a device API structure (<code class="notranslate">NULL</code> for us).</p>
    <p>What all the device tree was is to be able to fill this struct. We have defined the binding file, written the
      node and generated the <code class="notranslate">devicetree_generated.h</code> file and got all the data we need.
    </p>
    <p>For this specific node if we call <code class="notranslate">STM32_TSC_INIT</code> with our node, the generated
      code will look like this;</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">stm32_tsc_irq_init_0</span>(<span class="pl-smi">void</span>){
  <span class="pl-en">IRQ_CONNECT</span>(<span class="pl-c1">21</span>, <span class="pl-c1">0</span>, <span class="pl-s1">stm32_tsc_isr</span>, <span class="pl-en">DEVICE_DT_INST_GET</span>(<span class="pl-c1">0</span>), <span class="pl-c1">0</span>);
  <span class="pl-en">irq_enable</span>(<span class="pl-c1">21</span>);
};

<span class="pl-k">static</span> <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_group_config</span> <span class="pl-s1">groups</span>[] <span class="pl-c1">=</span> 
{
  {
    .<span class="pl-c1">group</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_group</span>,
    .<span class="pl-c1">channel_ios</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_channel_ios</span>,
    .<span class="pl-c1">sampling_io</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_sampling_io</span>,
    .<span class="pl-c1">use_as_shield</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g1_use_as_shield</span>,
  },
  {
    .<span class="pl-c1">group</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g6_group</span>,
    .<span class="pl-c1">channel_ios</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g6_channel_ios</span>,
    .<span class="pl-c1">sampling_io</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g6_sampling_io</span>,
    .<span class="pl-c1">use_as_shield</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_g6_use_as_shield</span>,
  }
};

<span class="pl-k">static</span> <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-s1">tsc_config</span> <span class="pl-c1">=</span> 
{
  .<span class="pl-c1">tsc</span> <span class="pl-c1">=</span> (<span class="pl-smi">TSC_TypeDef</span> <span class="pl-c1">*</span>)<span class="pl-s1">DT_N_S_soc_S_tsc_40024000_REG_IDX_0_VAL_ADDRESS</span>,
  .<span class="pl-c1">pclken</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_clocks</span>,
  .<span class="pl-c1">reset</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_resets</span>,
  .<span class="pl-c1">groups</span> <span class="pl-c1">=</span> <span class="pl-s1">groups</span>,
  .<span class="pl-c1">irq_func</span> <span class="pl-c1">=</span> <span class="pl-s1">tsc_isr</span>,
  .<span class="pl-c1">groups_size</span> <span class="pl-c1">=</span> <span class="pl-c1">2</span>,
  .<span class="pl-c1">pgpsc</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_pulse_generator_prescaler</span>,
  .<span class="pl-c1">ctph</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_ctph</span>,
  .<span class="pl-c1">ctpl</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_ctpl</span>,
  .<span class="pl-c1">sscpsc</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_spread_spectrum_prescaler</span>,
  .<span class="pl-c1">ssd</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_spread_spectrum_deviation</span>,
  .<span class="pl-c1">max_count</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_max_count_value</span>,
  .<span class="pl-c1">spread_spectrum</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_spread_spectrum</span>,
  .<span class="pl-c1">sync_acq</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_synced_acquisition</span>,
  .<span class="pl-c1">sync_pol</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_syncpol_rising</span>,
  .<span class="pl-c1">iodef_float</span> <span class="pl-c1">=</span> <span class="pl-s1">DT_N_S_soc_S_tsc_40024000_P_iodef_float</span>,
  .<span class="pl-c1">irq_func</span> <span class="pl-c1">=</span> <span class="pl-s1">stm32_tsc_irq_init_0</span>,
};

<span class="pl-c">/* device defininition code */</span></pre>
    </div>
    <p>This is very roughly what ends up happening after preprocessor does its job.</p>
    <h5>Interrupts</h5>
    <p>One important thing not mentioned here is interrupts. We defined in the node that the interrupts are at position
      <code class="notranslate">21</code> and the priority is <code class="notranslate">0</code>. Zephyr has a <a
        href="https://docs.zephyrproject.org/latest/kernel/services/interrupts.html" rel="nofollow">nice API</a> to
      connect interrupts to ISRs and enable them. In this implementation all interrupts are connected to <code
        class="notranslate">stm32_tsc_isr</code> function, which is a generic interrupt service routine, and it will
      take a parameter of type <code class="notranslate">const struct device *</code> (provided by passing <code
        class="notranslate">DEVICE_DT_INST_GET</code> to <code class="notranslate">ISR_CONNECT</code> ) so we will be
      able to serve multiple instances of the TSC peripheral with the same ISR. So if we call <code
        class="notranslate">stm32_tsc_irq_init_0</code> function, it will connect the interrupt to the ISR and enable
      it.</p>
    <p>I plan to be able to enable and disable interrupts from the Kconfig files which what Zephyr uses to configure the
      kernel at compile time.</p>
    <h3>Device Driver Implementation</h3>
    <p>Now that we have our device tree node and binding ready, data plumbed to the driver, and the device defined, we
      can start writing the driver code.</p>
    <p>We will again start by creating a directory for our driver in the workspace in the <code
        class="notranslate">zephyr/drivers/misc</code> folder for a cohesive folder structure. These are not mandatory
      but it is good practice to keep things organized.</p>
    <p>We can start writing the code right away. I'll just create <code class="notranslate">stm32_tsc.c</code> file in
      the <code class="notranslate">drivers/misc/stm32_tsc</code> directory.</p>
    <p>I like to start with the <code class="notranslate">DT_DRV_COMPAT</code> macro to define the compatible string for
      the driver, this is the same string we used in the binding file but special characters are replaced with
      underscores. And include the plumbing code so we can have the data ready.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-c">/* zephyr/drivers/misc/stm32_tsc/stm32_tsc.c */</span>

<span class="pl-k">#define</span> <span class="pl-c1">DT_DRV_COMPAT</span> st_stm32_tsc

<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/irq.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/devicetree.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/reset.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/pinctrl.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/clock_control/stm32_clock_control.h&gt;</span>

<span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_group_config</span> {
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>  <span class="pl-c1">group</span>;
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>  <span class="pl-c1">channel_ios</span>;
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>  <span class="pl-c1">sampling_io</span>;
 <span class="pl-k">const</span> <span class="pl-smi">bool</span>     <span class="pl-c1">use_as_shield</span>;
 <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">zephyr_code</span>;
};

<span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> {
 <span class="pl-smi">TSC_TypeDef</span>       <span class="pl-c1">*</span><span class="pl-c1">tsc</span>;
 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_prcc_deven</span>     <span class="pl-c1">pclken</span>;
 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">reset_dt_spec</span>      <span class="pl-c1">reset</span>;
 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">pinctrl_dev_config</span>     <span class="pl-c1">*</span><span class="pl-c1">pcfg</span>;
 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_group_config</span> <span class="pl-c1">*</span><span class="pl-c1">groups</span>;
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>        <span class="pl-c1">groups_size</span>;

 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>        <span class="pl-c1">pgpsc</span>;
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>        <span class="pl-c1">ctph</span>;
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>        <span class="pl-c1">ctpl</span>;
 <span class="pl-k">const</span> <span class="pl-smi">bool</span>        <span class="pl-c1">spread_spectrum</span>;
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>        <span class="pl-c1">sscpsc</span>;
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>        <span class="pl-c1">ssd</span>;
 <span class="pl-k">const</span> <span class="pl-smi">uint16_t</span>        <span class="pl-c1">max_count</span>;
 <span class="pl-k">const</span> <span class="pl-smi">bool</span>        <span class="pl-c1">iodef</span>;
 <span class="pl-k">const</span> <span class="pl-smi">bool</span>        <span class="pl-c1">sync_acq</span>;
 <span class="pl-k">const</span> <span class="pl-smi">bool</span>        <span class="pl-c1">sync_pol</span>;
 <span class="pl-smi">void</span> (<span class="pl-c1">*</span><span class="pl-c1">irq_func</span>)(<span class="pl-smi">void</span>);
};

<span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_GROUP</span>(<span class="pl-s1">node</span>)                                 \
  {                                                           \
    .group = DT_PROP(node, group),                            \
    .channel_ios = DT_PROP(node, channel_ios),                \
    .sampling_io = DT_PROP(node, sampling_io),                \
    .use_as_shield = DT_PROP(node, use_as_shield),            \
  },

<span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_GROUPS</span>(<span class="pl-s1">node</span>)                                \
  (const struct stm32_tsc_group_config[]) {                   \
    DT_INST_FOREACH_CHILD_STATUS_OKAY(node, STM32_TSC_GROUP)  \
  }

<span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_BASE</span>(<span class="pl-s1">node</span>) ((TSC_TypeDef *)DT_INST_REG_ADDR(node))
<span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_CLOCK</span>(<span class="pl-s1">node</span>) (const struct stm32_pclken) STM32_CLOCK_INFO(0, DT_DRV_INST(node))
<span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_RESET</span>(<span class="pl-s1">node</span>) (const struct reset_dt_spec) RESET_DT_SPEC_INST_GET_OR(node, NULL)
<span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_PINCTRL_DEFINE</span>(<span class="pl-s1">node</span>) PINCTRL_DT_INST_DEFINE(node)
<span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_PINCTRL</span>(<span class="pl-s1">node</span>) ((const struct pinctrl_dev_config *) PINCTRL_DT_INST_DEV_CONFIG_GET(node))

<span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_INIT</span>(<span class="pl-s1">node</span>)                                                                                        \
                                                                                                                    \
  static void stm32_tsc_irq_init_##node(void) {                                                                     \
    IRQ_CONNECT(DT_INST_IRQN(node), DT_INST_IRQ(node, priority), stm32_tsc_isr, DEVICE_DT_INST_GET(node), 0);       \
    irq_enable(DT_INST_IRQN(node));                                                                                 \
  };                                                                                                                \
                                                                                                                    \
  STM32_TSC_PINCTRL_DEFINE(node);                                                                                   \
                                                                                                                    \
  static const struct stm32_tsc_group_config groups[] = STM32_TSC_GROUPS(node);                                     \
                                                                                                                    \
  static const struct stm32_tsc_config tsc_config##node =                                                           \
  {                                                                                                                 \
  .tsc = STM32_TSC_BASE(node),                                                                                      \
  .pclken = STM32_TSC_CLOCK(node),                                                                                  \
  .reset = STM32_TSC_RESET(node),                                                                                   \
  .pcfg = STM32_TSC_PINCTRL(node),                                                                                  \
  .groups = groups,                                                                                                 \
  .groups_size = DT_INST_CHILD_NUM_STATUS_OKAY(node),                                                               \
  .pgpsc = DT_INST_PROP_OR(node, pulse_generator_prescaler, 2),                                                     \
  .ctph = DT_INST_PROP_OR(node, ctph, 2),                                                                           \
  .ctpl = DT_INST_PROP_OR(node, ctpl, 2),                                                                           \
  .spread_spectrum = DT_INST_PROP_OR(node, spread_spectrum, false),                                                 \
  .sscpsc = DT_INST_PROP_OR(node, spread_spectrum_prescaler, 1),                                                    \
  .ssd = DT_INST_PROP_OR(node, spread_spectrum_deviation, 1),                                                       \
  .max_count = DT_INST_PROP_OR(node, max_count_value, 5),                                                           \
  .iodef = DT_INST_PROP_OR(node, iodef_float, false),                                                               \
  .sync_acq = DT_INST_PROP_OR(node, synced_acquisition, false),                                                     \
  .sync_pol = DT_INST_PROP_OR(node, syncpol_rising, false),                                                         \
  };                                                                                                                \
                                                                                                                    \
  DEVICE_DT_INST_DEFINE(node, stm32_tsc_init, NULL, NULL, &amp;tsc_config##node, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, NULL);

<span class="pl-c1">DT_INST_FOREACH_STATUS_OKAY</span>(<span class="pl-smi">STM32_TSC_INIT</span>)</pre>
    </div>
    <p><code class="notranslate">DT_INST_FOREACH_STATUS_OKAY</code> is another macro which will iterate over all the
      instances of the driver in the device tree and call the function for each instance that has a status of <code
        class="notranslate">okay</code>.</p>
    <p>We already defined in some parts of the code that we will use functions named <code
        class="notranslate">stm32_tsc_isr</code> and <code class="notranslate">stm32_tsc_init</code> so we need to
      define them. But before doing that a little info about peripheral and subsystem APIs so we can initialize TSC
      related configurations using other devices like <code class="notranslate">RCC</code>, <code
        class="notranslate">GPIO</code>, <code class="notranslate">NVIC</code>, etc.</p>
    <h4>Peripheral and Subsystem APIs</h4>
    <p>Peripheral APIs are generic Zephyr APIs that defines a common interface for general "peripherals", like GPIO,
      PWM, I2C, SPI, etc. These APIs are implemented by the SoC specific HALs so we don't have to change our application
      code, or driver code, if we change the hardware. We will be only dealing with the Zephyr APIs and it will do the
      plumbing for us.</p>
    <p>These peripheral APIs are usually pretty nice and complete, for example check out the comprehensive GPIO
      Peripheral API <a href="https://docs.zephyrproject.org/latest/doxygen/html/group__gpio__interface.html"
        rel="nofollow">documentation</a>.</p>
    <p>To use any GPIO in Zephyr we just need to include the header file and use the API.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;zepryr/drivers/gpio.h&gt;</span>

<span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">void</span>)
{
    <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span> <span class="pl-c1">=</span> <span class="pl-c1">NULL</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">ret</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;

    <span class="pl-s1">dev</span> <span class="pl-c1">=</span> <span class="pl-en">device_get_binding</span>(<span class="pl-s">"GPIO_0"</span>);
    <span class="pl-k">if</span> (!<span class="pl-s1">dev</span>) {
        <span class="pl-en">k_panic</span>(<span class="pl-s">"Could not get GPIO device\n"</span>);
        <span class="pl-k">return</span>;
    }

    <span class="pl-s1">ret</span> <span class="pl-c1">=</span> <span class="pl-en">gpio_pin_configure</span>(<span class="pl-s1">dev</span>, <span class="pl-c1">0</span>, <span class="pl-c1">GPIO_INPUT</span> | <span class="pl-c1">GPIO_ACTIVE_HIGH</span>);
    <span class="pl-k">if</span> (<span class="pl-s1">ret</span>) {
        <span class="pl-en">k_panic</span>(<span class="pl-s">"Could not configure GPIO pin 0\n"</span>);
        <span class="pl-k">return</span>;
    }

    ...
}</pre>
    </div>
    <p>Once we are able to get a <code class="notranslate">device</code> struct, we can then pass it to its respective
      API. Notice how <code class="notranslate">struct device</code> is just a generic struct, in fact if we look at the
      definition of it we see a really abstract structure:</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-c">/**</span>
<span class="pl-c"> * @brief Runtime device structure (in ROM) per driver instance</span>
<span class="pl-c"> */</span>
<span class="pl-k">struct</span> <span class="pl-smi">device</span> {
 <span class="pl-c">/** Name of the device instance */</span>
 <span class="pl-k">const</span> <span class="pl-smi">char</span> <span class="pl-c1">*</span><span class="pl-c1">name</span>;
 <span class="pl-c">/** Address of device instance config information */</span>
 <span class="pl-k">const</span> <span class="pl-smi">void</span> <span class="pl-c1">*</span><span class="pl-c1">config</span>;
 <span class="pl-c">/** Address of the API structure exposed by the device instance */</span>
 <span class="pl-k">const</span> <span class="pl-smi">void</span> <span class="pl-c1">*</span><span class="pl-c1">api</span>;
 <span class="pl-c">/** Address of the common device state */</span>
 <span class="pl-k">struct</span> <span class="pl-smi">device_state</span> <span class="pl-c1">*</span><span class="pl-c1">state</span>;
 <span class="pl-c">/** Address of the device instance private data */</span>
 <span class="pl-smi">void</span> <span class="pl-c1">*</span><span class="pl-c1">data</span>;

  ...
};</pre>
    </div>
    <p><code class="notranslate">config</code>, <code class="notranslate">api</code> and <code
        class="notranslate">data</code> are all adapters (void pointers) to whatever any "device" wants. And if we look
      at the <code class="notranslate">gpio_pin_configure</code> function you see after some checking it calls the
      actual driver that was described in the device tree of the hardware we are using, which was connected to this
      adapter at boot time, by the device tree macros. We will see this in detail in the next section.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-smi">int</span> <span class="pl-en">gpio_pin_configure</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">port</span>,
     <span class="pl-smi">gpio_pin_t</span> <span class="pl-s1">pin</span>,
     <span class="pl-smi">gpio_flags_t</span> <span class="pl-s1">flags</span>)
{
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">gpio_driver_api</span> <span class="pl-c1">*</span><span class="pl-s1">api</span> <span class="pl-c1">=</span>
    (<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">gpio_driver_api</span> <span class="pl-c1">*</span>)<span class="pl-s1">port</span><span class="pl-c1">-&gt;</span><span class="pl-c1">api</span>;

  ...
  
 <span class="pl-k">return</span> <span class="pl-s1">api</span><span class="pl-c1">-&gt;</span><span class="pl-en">pin_configure</span>(<span class="pl-s1">port</span>, <span class="pl-s1">pin</span>, <span class="pl-s1">flags</span>);
}</pre>
    </div>
    <p>So the <code class="notranslate">void *api</code> was assigned to the device structure by the actual vendor
      driver at boot time and again dereferenced here by the API to get the address of the actual driver function which
      does the actual configuration. So probably the vendor driver will look into the <code
        class="notranslate">config</code> field or the <code class="notranslate">data</code> field to get the actual
      hardware registers and do the configuration.</p>
    <p>Strong opinion time; C allowed this kind of abstraction all along, but nobody dared to implement it. I think this
      was the framework industry needed for a long time, and Zephyr did it right. So hats off to the Zephyr team for
      this.</p>
    <p>The peripheral APIs this driver will use are;</p>
    <ul>
      <li><a href="https://docs.zephyrproject.org/latest/hardware/peripherals/clock_control.html" rel="nofollow">Clock
          Control</a></li>
      <li><a href="https://docs.zephyrproject.org/latest/hardware/peripherals/reset.html" rel="nofollow">Reset
          Controller</a></li>
      <li><a href="https://docs.zephyrproject.org/latest/hardware/pinctrl/index.html" rel="nofollow">Pin Controller</a>
      </li>
      <li><a href="https://docs.zephyrproject.org/latest/kernel/services/interrupts.html" rel="nofollow">Interrupts</a>
      </li>
    </ul>
    <p>There are also subsystems, they are pretty similar to peripherals in terms of their use but the difference is
      that they do not rely on hardware. Things like console or file systems. One subsystem this driver can use is the
      <a href="https://docs.zephyrproject.org/latest/services/input/index.html#input" rel="nofollow">Input
        Subsystem</a>. This subsystem is used for anything that is an input, usually touch screens, buttons, etc. We can
      use this subsystem to get the touch input from the TSC peripheral.</p>
    <h4>Reset API</h4>
    <p>Since we will be using another device we should check if it was initialized before using it. Zephyr has a
      function for this</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/device.h&gt;</span>

<span class="pl-smi">void</span> <span class="pl-en">stm32_tsc_init</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>)
{
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-c1">*</span><span class="pl-s1">config</span> <span class="pl-c1">=</span> <span class="pl-s1">dev</span><span class="pl-c1">-&gt;</span><span class="pl-c1">config</span>;
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-k">const</span>  <span class="pl-s1">rcc_dev</span> <span class="pl-c1">=</span> <span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-c1">STM32_CLOCK_CONTROL_NODE</span>);

  <span class="pl-k">if</span> (!<span class="pl-en">device_is_ready</span>(<span class="pl-s1">rcc_dev</span>))
  {
    <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"TSC@%p: clock and reset controller device not ready"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>);
    <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">ENODEV</span>;
  }

}</pre>
    </div>
    <p>First thing to do is to get the devices and configs we will use. In this case this device's config point to a
      memory location that holds the <code class="notranslate">struct stm32_tsc_config</code> we defined earlier, so we
      will cast the <code class="notranslate">dev-&gt;config</code>, which was a void pointer to this struct and use it.
      Another one is the <code class="notranslate">rcc_dev</code> which is the clock and reset controller device we will
      use to reset the TSC peripheral. <code class="notranslate">STM32_CLOCK_CONTROL_NODE</code> is defined in <code
        class="notranslate">stm32_clock_control.h</code> and points to the device tree node that holds the clock and
      reset controller information.</p>
    <p>After this we will use <code class="notranslate">reset_line_toggle_dt</code> from the reset API to reset the TSC
      peripheral, so the peripheral values are at their defaults.</p>
    <div class="markdown-alert markdown-alert-note">
      <p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1"
          width="16" height="16" aria-hidden="true">
          <path
            d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
          </path>
        </svg>Note</p>
      <p>Also a subsystem called <code class="notranslate">Log</code> is used here, but since it is irrelevant, I will
        not discuss it. Please find more information about it in the <a
          href="https://docs.zephyrproject.org/latest/services/logging/index.html" rel="nofollow">Zephyr
          Documentation</a>.</p>
    </div>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/reset.h&gt;</span>

<span class="pl-smi">void</span> <span class="pl-en">stm32_tsc_init</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>)
{
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-c1">*</span><span class="pl-s1">config</span> <span class="pl-c1">=</span> <span class="pl-s1">dev</span><span class="pl-c1">-&gt;</span><span class="pl-c1">config</span>;
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-k">const</span>  <span class="pl-s1">rcc_dev</span> <span class="pl-c1">=</span> <span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-c1">STM32_CLOCK_CONTROL_NODE</span>);

  ...

  <span class="pl-smi">int</span> <span class="pl-s1">ret</span> <span class="pl-c1">=</span> <span class="pl-en">reset_line_toggle_dt</span>(<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">reset</span>);
  <span class="pl-k">if</span> (<span class="pl-s1">ret</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span>)
  {
    <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"Failed to reset TSC@%p (%d)"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>, <span class="pl-s1">ret</span>);
    <span class="pl-k">return</span> <span class="pl-s1">ret</span>;
  }
}</pre>
    </div>
    <h4>Clock Control API</h4>
    <p>Then we will use the clock control API to enable the clock for the TSC peripheral.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/clock_control.h&gt;</span>

<span class="pl-smi">void</span> <span class="pl-en">stm32_tsc_init</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>)
{
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-c1">*</span><span class="pl-s1">config</span> <span class="pl-c1">=</span> <span class="pl-s1">dev</span><span class="pl-c1">-&gt;</span><span class="pl-c1">config</span>;
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-k">const</span>  <span class="pl-s1">rcc_dev</span> <span class="pl-c1">=</span> <span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-c1">STM32_CLOCK_CONTROL_NODE</span>);

  ...

  <span class="pl-s1">ret</span> <span class="pl-c1">=</span> <span class="pl-en">clock_control_on</span>(<span class="pl-s1">rcc_dev</span>, (<span class="pl-s1">clock_control_subsys_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">pclken</span>);
  <span class="pl-k">if</span> (<span class="pl-s1">ret</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span>)
  {
    <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"Failed to enable clock for TSC@%p (%d)"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>, <span class="pl-s1">ret</span>);
    <span class="pl-k">return</span> <span class="pl-s1">ret</span>;
  }
}</pre>
    </div>
    <h4>Pin Controller API</h4>
    <p>And finally we will use the pin controller API to configure the pins for the TSC peripheral.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/pinctrl.h&gt;</span>

<span class="pl-smi">void</span> <span class="pl-en">stm32_tsc_init</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>)
{
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-c1">*</span><span class="pl-s1">config</span> <span class="pl-c1">=</span> <span class="pl-s1">dev</span><span class="pl-c1">-&gt;</span><span class="pl-c1">config</span>;
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-k">const</span>  <span class="pl-s1">rcc_dev</span> <span class="pl-c1">=</span> <span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-c1">STM32_CLOCK_CONTROL_NODE</span>);

  ...

  <span class="pl-s1">ret</span> <span class="pl-c1">=</span> <span class="pl-en">pinctrl_apply_state</span>(<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">pcfg</span>, <span class="pl-c1">PINCTRL_STATE_DEFAULT</span>);
  <span class="pl-k">if</span> (<span class="pl-s1">ret</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span>)
  {
    <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"Failed to configure TSC@%p pins (%d)"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>, <span class="pl-s1">ret</span>);
    <span class="pl-k">return</span> <span class="pl-s1">ret</span>;
  }
}</pre>
    </div>
    <p>This will be all for now for the peripheral APIs, the rest of it is just memory writes and reads to/from the TSC
      peripheral registers and finally calling the interrupt enable function we defined earlier in <code
        class="notranslate">STM32_TSC_INIT</code>, which makes this final code for the <code
        class="notranslate">stm32_tsc_init</code> function.</p>
    <h4>stm32_tsc_init</h4>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;soc.h&gt;</span>

<span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-en">stm32_tsc_init</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>)
{
 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-c1">*</span><span class="pl-s1">config</span> <span class="pl-c1">=</span> <span class="pl-s1">dev</span><span class="pl-c1">-&gt;</span><span class="pl-c1">config</span>;
 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-k">const</span>     <span class="pl-s1">rcc_dev</span> <span class="pl-c1">=</span> <span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-c1">STM32_CLOCK_CONTROL_NODE</span>);

 <span class="pl-smi">int</span>          <span class="pl-s1">ret</span>;

 <span class="pl-k">if</span> (!<span class="pl-en">device_is_ready</span>(<span class="pl-s1">rcc_dev</span>))
 {
  <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"TSC@%p: clock and reset controller device not ready"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>);
  <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">ENODEV</span>;
 }

 <span class="pl-c">/* reset TSC values to default */</span>
 <span class="pl-s1">ret</span> <span class="pl-c1">=</span> <span class="pl-en">reset_line_toggle_dt</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">reset</span>);
 <span class="pl-k">if</span> (<span class="pl-s1">ret</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span>)
 {
  <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"Failed to reset TSC@%p (%d)"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>, <span class="pl-s1">ret</span>);
  <span class="pl-k">return</span> <span class="pl-s1">ret</span>;
 }

 <span class="pl-s1">ret</span> <span class="pl-c1">=</span> <span class="pl-en">clock_control_on</span>(<span class="pl-s1">rcc_dev</span>, (<span class="pl-s1">clock_control_subsys_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">pclken</span>);
 <span class="pl-k">if</span> (<span class="pl-s1">ret</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span>)
 {
  <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"Failed to enable clock for TSC@%p (%d)"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>, <span class="pl-s1">ret</span>);
  <span class="pl-k">return</span> <span class="pl-s1">ret</span>;
 }

 <span class="pl-s1">ret</span> <span class="pl-c1">=</span> <span class="pl-en">pinctrl_apply_state</span>(<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">pcfg</span>, <span class="pl-c1">PINCTRL_STATE_DEFAULT</span>);
 <span class="pl-k">if</span> (<span class="pl-s1">ret</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span>)
 {
  <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"Failed to configure TSC@%p pins (%d)"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>, <span class="pl-s1">ret</span>);
  <span class="pl-k">return</span> <span class="pl-s1">ret</span>;
 }

 <span class="pl-c">/* set ctph (bits 31:28) and ctpl (bits 27:24) */</span>
 <span class="pl-en">sys_set_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, (((<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ctph</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>) &lt;&lt; <span class="pl-c1">4</span>) | (<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ctpl</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>)) &lt;&lt; <span class="pl-s1">TSC_CR_CTPL_Pos</span>);

 <span class="pl-c">/* set spread spectrum deviation (bits 23:17) */</span>
 <span class="pl-en">sys_set_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ssd</span> &lt;&lt; <span class="pl-s1">TSC_CR_SSD_Pos</span>);

 <span class="pl-c">/* set pulse generator prescaler (bits 14:12) */</span>
 <span class="pl-en">sys_set_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">pgpsc</span> &lt;&lt; <span class="pl-s1">TSC_CR_PGPSC_Pos</span>);

 <span class="pl-c">/* set max count value (bits 7:5) */</span>
 <span class="pl-en">sys_set_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">max_count</span> &lt;&lt; <span class="pl-s1">TSC_CR_MCV_Pos</span>);

 <span class="pl-c">/* set spread spectrum prescaler (bit 15) */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">sscpsc</span> <span class="pl-c1">==</span> <span class="pl-c1">2</span>)
  <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, <span class="pl-s1">TSC_CR_SSPSC_Pos</span>);

 <span class="pl-c">/* set sync bit polarity */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">sync_pol</span>)
  <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, <span class="pl-s1">TSC_CR_SYNCPOL_Pos</span>);

 <span class="pl-c">/* set sync acquisition */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">sync_acq</span>)
  <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, <span class="pl-s1">TSC_CR_AM_Pos</span>);

 <span class="pl-c">/* set I/O default mode */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">iodef</span>)
  <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, <span class="pl-s1">TSC_CR_IODEF_Pos</span>);

 <span class="pl-c">/* set spread spectrum */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">spread_spectrum</span>)
  <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, <span class="pl-s1">TSC_CR_SSE_Pos</span>);

 <span class="pl-c">/* group configuration */</span>
 <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">groups_size</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>)
 {
  <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_group_config</span> <span class="pl-c1">*</span><span class="pl-s1">group</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">groups</span>[<span class="pl-s1">i</span>];

  <span class="pl-k">if</span> (<span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">channel_ios</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">sampling_io</span>)
  {
   <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"TSC@%p: group %d has the same channel and sampling I/O"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>, <span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">group</span>);
   <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">EINVAL</span>;
  }

  <span class="pl-c">/* if use_as_shield is true, the channel I/Os are used as shield, and can only have values 1,2,4,8 */</span>
  <span class="pl-k">if</span> (<span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">use_as_shield</span> <span class="pl-c1">&amp;&amp;</span>
      <span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">channel_ios</span> <span class="pl-c1">!=</span> <span class="pl-c1">1</span> <span class="pl-c1">&amp;&amp;</span>
      <span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">channel_ios</span> <span class="pl-c1">!=</span> <span class="pl-c1">2</span> <span class="pl-c1">&amp;&amp;</span>
      <span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">channel_ios</span> <span class="pl-c1">!=</span> <span class="pl-c1">4</span> <span class="pl-c1">&amp;&amp;</span>
      <span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">channel_ios</span> <span class="pl-c1">!=</span> <span class="pl-c1">8</span>)
  {
   <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"TSC@%p: group %d is used as shield, but has invalid channel I/Os. Can only have one"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>, <span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">group</span>);
   <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">EINVAL</span>;
  }

  <span class="pl-c">/* each group only has 4 configurable I/O */</span>
<span class="pl-k">#define</span> <span class="pl-en">GET_GROUP_BITS</span>(<span class="pl-s1">val</span>) (uint32_t)(((val) &amp; 0x0f) &lt;&lt; ((group-&gt;group - 1) * 4))

  <span class="pl-c">/* clear schmitt trigger hysteresis for enabled I/Os */</span>
  <span class="pl-en">sys_clear_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOHCR</span>, <span class="pl-en">GET_GROUP_BITS</span>(<span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">channel_ios</span> | <span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">sampling_io</span>));

  <span class="pl-c">/* set channel I/Os */</span>
  <span class="pl-en">sys_set_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOCCR</span>, <span class="pl-en">GET_GROUP_BITS</span>(<span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">channel_ios</span>));

  <span class="pl-c">/* set sampling I/O */</span>
  <span class="pl-en">sys_set_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOSCR</span>, <span class="pl-en">GET_GROUP_BITS</span>(<span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">sampling_io</span>));

  <span class="pl-c">/* enable group */</span>
  <span class="pl-k">if</span> (!<span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">use_as_shield</span>)
   <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOGCSR</span>, <span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">group</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>);
 }

 <span class="pl-c">/* disable interrupts */</span>
 <span class="pl-en">sys_clear_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IER</span>, <span class="pl-c1">TSC_IER_EOAIE</span> | <span class="pl-c1">TSC_IER_MCEIE</span>);

 <span class="pl-c">/* clear interrupts */</span>
 <span class="pl-en">sys_set_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ICR</span>, <span class="pl-c1">TSC_ICR_EOAIC</span> | <span class="pl-c1">TSC_ICR_MCEIC</span>);

 <span class="pl-c">/* enable peripheral */</span>
 <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, <span class="pl-s1">TSC_CR_TSCE_Pos</span>);

<span class="pl-k">#if</span> <span class="pl-en">IS_ENABLED</span>(<span class="pl-c1">CONFIG_STM32_TSC_INTERRUPT</span>)
 <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-en">irq_func</span>();
<span class="pl-k">#endif</span>

 <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre>
    </div>
    <p>The functions like <code class="notranslate">sys_set_bits</code> and <code
        class="notranslate">sys_clear_bits</code> are just memory writes to the peripheral registers and definitions
      like <code class="notranslate">TSC_IER_EOAIE</code> or <code class="notranslate">TSC_CR_IODEF_Pos</code> are taken
      from the SOC specific header file, which gets included with <code class="notranslate">soc.h</code> which
      corresponds to the <code class="notranslate">stm32u083xx.h</code> file in this case.</p>
    <p>If you noticed the interrupt is only enabled when there is a definition called <code
        class="notranslate">CONFIG_STM32_TSC_INTERRUPT</code>. We will not define it in this file instead it will be
      defined globally by the Zephyr build system when parsing Kconfig files which we will see in the next section.</p>
    <h4>TSC Peripheral API</h4>
    <p>This is not quite a set-and-forget type of a driver. Application implementer should start the acquisition.
      Therefore the driver should expose some functions to interact with the TSC peripheral.</p>
    <p>Header files are resided in <code class="notranslate">include</code> directory of the Zephyr source, therefore
      this driver will be in <code class="notranslate">zephyr/include/drivers/misc/stm32_tsc.h</code>.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-c">/* zephyr/include/drivers/misc/stm32_tsc.h */</span>

<span class="pl-k">#ifndef</span> <span class="pl-c1">ZEPHYR_DRIVERS_MISC_STM32_TSC_H_</span>
<span class="pl-k">#define</span> <span class="pl-c1">ZEPHYR_DRIVERS_MISC_STM32_TSC_H_</span>

<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/types.h&gt;</span>

<span class="pl-smi">void</span> <span class="pl-en">stm32_tsc_start</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>);
<span class="pl-smi">int</span>  <span class="pl-en">stm32_tsc_poll_for_acquisition</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>, <span class="pl-smi">k_timeout_t</span> <span class="pl-s1">timeout</span>);
<span class="pl-smi">int</span>  <span class="pl-en">stm32_tsc_read</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>, <span class="pl-smi">uint8_t</span> <span class="pl-s1">group</span>, <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">value</span>);

<span class="pl-k">#endif</span> <span class="pl-c">/* ZEPHYR_DRIVERS_MISC_STM32_TSC_H_ */</span></pre>
    </div>
    <p>This API is as simple as it can get. All functions require a <code class="notranslate">device</code> to work.
      <code class="notranslate">stm32_tsc_start</code> will start the acquisition, and if interrupt is enabled it should
      put the acquisition value to the input subsystem, or user can poll and read manually.</p>
    <h4>TSC Peripheral API Implementation</h4>
    <h5>stm32_tsc_start</h5>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-smi">void</span> <span class="pl-en">stm32_tsc_start</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>)
{
 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-c1">*</span><span class="pl-s1">config</span> <span class="pl-c1">=</span> <span class="pl-s1">dev</span><span class="pl-c1">-&gt;</span><span class="pl-c1">config</span>;

 <span class="pl-c">/* clear interrupts */</span>
 <span class="pl-en">sys_set_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ICR</span>, <span class="pl-c1">TSC_ICR_EOAIC</span> | <span class="pl-c1">TSC_ICR_MCEIC</span>);

<span class="pl-k">#if</span> <span class="pl-en">IS_ENABLED</span>(<span class="pl-c1">CONFIG_STM32_TSC_INTERRUPT</span>)
 <span class="pl-c">/* enable end of acquisition and max count error interrupts */</span>
 <span class="pl-en">sys_set_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IER</span>, <span class="pl-c1">TSC_IER_EOAIE</span> | <span class="pl-c1">TSC_IER_MCEIE</span>);
<span class="pl-k">#endif</span>

 <span class="pl-c">/* start acquisition */</span>
 <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>, <span class="pl-s1">TSC_CR_START_Pos</span>);
}</pre>
    </div>
    <p>This is discussed in the previous sections, we clear and enable interrupts if enabled, only only set a bit to
      start the acquisition.</p>
    <h5>stm32_tsc_poll_for_acquisition</h5>
    <p>When error or acquisition occurs the <code class="notranslate">ISR</code> register bits are set. Driver will
      check those and return if the bits are set (clearing them before returning) or a timeout occurs.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-smi">int</span> <span class="pl-en">stm32_tsc_poll_for_acquisition</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>, <span class="pl-smi">k_timeout_t</span> <span class="pl-s1">timeout</span>)
{
 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-c1">*</span><span class="pl-s1">config</span> <span class="pl-c1">=</span> <span class="pl-s1">dev</span><span class="pl-c1">-&gt;</span><span class="pl-c1">config</span>;
 <span class="pl-smi">uint32_t</span>         <span class="pl-s1">status</span>;
 <span class="pl-smi">uint32_t</span>         <span class="pl-s1">start_tick</span> <span class="pl-c1">=</span> <span class="pl-en">sys_clock_tick_get_32</span>();

 <span class="pl-k">do</span>
 {
  <span class="pl-s1">status</span> <span class="pl-c1">=</span> <span class="pl-en">sys_read32</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ISR</span>);

  <span class="pl-k">if</span> (<span class="pl-en">sys_clock_tick_get_32</span>() <span class="pl-c1">-</span> <span class="pl-s1">start_tick</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">timeout</span>.<span class="pl-c1">ticks</span>)
  {
   <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"TSC@%p: timeout"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>);
   <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">ETIMEDOUT</span>;
  }

 } <span class="pl-k">while</span> (!(<span class="pl-s1">status</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">TSC_ISR_EOAF</span>) <span class="pl-c1">&amp;&amp;</span> !(<span class="pl-s1">status</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">TSC_ISR_MCEF</span>));

 <span class="pl-k">if</span> (<span class="pl-s1">status</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">TSC_ISR_MCEF</span>)
 {
  <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ICR</span>, <span class="pl-s1">TSC_ICR_MCEIC_Pos</span>);
  <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"TSC@%p: max count error"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>);
  <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">EIO</span>;
 }

 <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ICR</span>, <span class="pl-s1">TSC_ICR_EOAIC_Pos</span>);

 <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre>
    </div>
    <h5>stm32_tsc_read</h5>
    <p>Reading is also straightforward, we just read the data register of the TSC group.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-smi">int</span> <span class="pl-en">stm32_tsc_read</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>, <span class="pl-smi">uint8_t</span> <span class="pl-s1">group</span>, <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">value</span>)
{
 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-c1">*</span><span class="pl-s1">config</span> <span class="pl-c1">=</span> <span class="pl-s1">dev</span><span class="pl-c1">-&gt;</span><span class="pl-c1">config</span>;

 <span class="pl-c">/* make sure group starts with 1 and can go max to IOGXCR count */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">value</span> <span class="pl-c1">==</span> <span class="pl-c1">NULL</span> <span class="pl-c1">||</span> <span class="pl-s1">group</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">1</span> <span class="pl-c1">||</span> <span class="pl-s1">group</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">8</span>)
  <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">EINVAL</span>;

 <span class="pl-c1">*</span><span class="pl-s1">value</span> <span class="pl-c1">=</span> <span class="pl-en">sys_read32</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOGXCR</span>[<span class="pl-s1">group</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>]);

 <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre>
    </div>
    <h5>stm32_tsc_isr</h5>
    <p>This function just disables the interrupts and checks for errors just like in the polling function, and if there
      is no error it reads the values and reports them to the input subsystem.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">stm32_tsc_isr</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">dev</span>)
{
 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_config</span> <span class="pl-c1">*</span><span class="pl-s1">config</span> <span class="pl-c1">=</span> <span class="pl-s1">dev</span><span class="pl-c1">-&gt;</span><span class="pl-c1">config</span>;

 <span class="pl-c">/* disable interrupts */</span>
 <span class="pl-en">sys_clear_bits</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IER</span>, <span class="pl-c1">TSC_IER_EOAIE</span> | <span class="pl-c1">TSC_IER_MCEIE</span>);

 <span class="pl-k">if</span> (<span class="pl-en">sys_test_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ISR</span>, <span class="pl-s1">TSC_ISR_MCEF_Pos</span>))
 {
  <span class="pl-c">/* clear max count error flag */</span>
  <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ICR</span>, <span class="pl-s1">TSC_ICR_MCEIC_Pos</span>);
  <span class="pl-en">LOG_ERR</span>(<span class="pl-s">"TSC@%p: max count error"</span>, <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>);
  <span class="pl-en">LOG_HEXDUMP_DBG</span>(<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span>, <span class="pl-k">sizeof</span>(<span class="pl-s1">TSC_TypeDef</span>), <span class="pl-s">"TSC Registers"</span>);
  <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">EIO</span>;
 }

 <span class="pl-k">if</span> (<span class="pl-en">sys_test_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ISR</span>, <span class="pl-s1">TSC_ISR_EOAF_Pos</span>))
 {
  <span class="pl-c">/* clear end of acquisition flag */</span>
  <span class="pl-en">sys_set_bit</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ICR</span>, <span class="pl-s1">TSC_ICR_EOAIC_Pos</span>);

  <span class="pl-c">/* read values */</span>
  <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">groups_size</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>)
  {
   <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">stm32_tsc_group_config</span> <span class="pl-c1">*</span><span class="pl-s1">group</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">groups</span>[<span class="pl-s1">i</span>];
   <span class="pl-smi">uint32_t</span>        <span class="pl-s1">group_bit</span> <span class="pl-c1">=</span> <span class="pl-en">BIT</span>(<span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">group</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>) &lt;&lt; <span class="pl-c1">16</span>;

   <span class="pl-k">if</span> (<span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOGCSR</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">group_bit</span>)
   {
    <span class="pl-smi">int32_t</span> <span class="pl-s1">count_value</span> <span class="pl-c1">=</span> <span class="pl-en">sys_read32</span>((<span class="pl-s1">mem_addr_t</span>)<span class="pl-c1">&amp;</span><span class="pl-s1">config</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOGXCR</span>[<span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">group</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>]);
    <span class="pl-en">input_report</span>(<span class="pl-s1">dev</span>, <span class="pl-c1">INPUT_EV_DEVICE</span>, <span class="pl-s1">group</span><span class="pl-c1">-&gt;</span><span class="pl-c1">zephyr_code</span>, <span class="pl-s1">count_value</span>, true, <span class="pl-c1">K_FOREVER</span>);
   }
  }
 }
}</pre>
    </div>
    <h3>Integration into the Build System</h3>
    <p>Zephyr uses Kconfig and CMake to decide if it will compile and link our source code. So this driver needs to
      integrate itself into this build system.</p>
    <p>In total 2 new files need to be created and 2 more needs editing.</p>
    <ul>
      <li><code class="notranslate">zephyr/drivers/misc/stm32_tsc/CMakeLists.txt</code> for the driver source</li>
      <li><code class="notranslate">zephyr/drivers/misc/stm32_tsc/Kconfig</code> for the driver configuration</li>
      <li><code class="notranslate">zephyr/drivers/misc/CMakeLists.txt</code> for the driver inclusion</li>
      <li><code class="notranslate">zephyr/drivers/misc/Kconfig</code> for the driver inclusion</li>
    </ul>
    <p>First thing this driver needs is to have a <code class="notranslate">CMakeLists.txt</code> and <code
        class="notranslate">Kconfig</code> file where the driver source is;</p>
    <h4>Source CMakeLists.txt</h4>
    <div class="highlight highlight-source-cmake">
      <pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> zephyr/drivers/misc/stm32_tsc/CMakeLists.txt</span>
zephyr_library()
zephyr_library_sources(stm32_tsc.c)</pre>
    </div>
    <p>This will add this as a Zephyr library and include the <code class="notranslate">stm32_tsc.c</code> file in the
      build system.</p>
    <h4>Source Kconfig</h4>
    <p>For the Kconfig file, we will create a <code class="notranslate">Kconfig</code> file in the same directory as the
      <code class="notranslate">CMakeLists.txt</code> file.</p>
    <pre lang="Kconfig" class="notranslate"><code class="notranslate"># zephyr/drivers/misc/stm32_tsc/Kconfig
config STM32_TSC
 bool "STM32 TSC driver"
 depends on DT_HAS_ST_STM32_TSC_ENABLED
 help
   Enable driver for STM32 TSC peripheral.

if STM32_TSC

config STM32_TSC_INTERRUPT
 bool "Use interrupt for STM32 TSC"
 default y
 help
   Use interrupt for STM32 TSC peripheral.

endif
</code></pre>
    <p>Kconfig files are easy to read, and in this one we have only two configurations. The first one is to enable the
      driver, and the second one is to enable the interrupt. The first one depends on <code
        class="notranslate">DT_HAS_ST_STM32_TSC_ENABLED</code> which requires many more configs to make sure we run on
      <code class="notranslate">STM32</code> and in the system we have a TSC peripheral.</p>
    <h4>Zephyr CMakeLists.txt</h4>
    <p>But the driver did not used <code class="notranslate">STM32_TSC</code> anywhere, so how does Zephyr know to
      include this driver in the build? This is done in the <code
        class="notranslate">zephyr/drivers/misc/CMakeLists.txt</code> file. We strategically placed these in subfolders,
      and these subfolders have their own <code class="notranslate">Kconfig</code> and <code
        class="notranslate">CMakeLists.txt</code> files. So that subdirs are accumulated as a chain. Therefore this
      drivers needs to be made aware to the parent directory.</p>
    <div class="highlight highlight-source-cmake">
      <pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> zephyr/drivers/misc/CMakeLists.txt</span>
add_subdirectory_ifdef(CONFIG_STM32_TSC stm32_tsc)</pre>
    </div>
    <p>This is where the definition in the Kconfig file is used. If <code class="notranslate">CONFIG_STM32_TSC</code> is
      defined, then the <code class="notranslate">stm32_tsc</code> directory will be included in the build. The <code
        class="notranslate">CONFIG_</code> prefix is attached to every configuration in the Kconfig file.</p>
    <h4>Zephyr Kconfig</h4>
    <p>Same has to be done with Kconfig but without the conditional inclusion.</p>
    <pre lang="Kconfig" class="notranslate"><code class="notranslate"># zephyr/drivers/misc/Kconfig
menu "Miscellaneous Drivers"
...
source "drivers/misc/stm32_tsc/Kconfig"
endmenu
</code></pre>
    <h2>How Do We Test This?</h2>
    <p>Zephyr has an extensive testing and emulation framework, allowing us to do all kinds of tricks to confidently say
      our code works. And without even running it on a real hardware. Of course for this memory mapped peripheral
      driver, we would have to emulate the entire TSC peripheral, which is outside of the scope of this document, but I
      plan to write on emulation frameworks in the future.</p>
    <p>But first, lets test it on the real hardware.</p>
    <h3>Building</h3>
    <p>The driver is written but there also needs to be an application to test it, we could create a new application but
      lets use an existing one. The <a
        href="https://docs.zephyrproject.org/latest/samples/subsys/input/input_dump/README.html" rel="nofollow">Input
        Dump</a> example is a good candidate for this. It is a simple application that reads every input event and
      prints it to the console.</p>
    <p>One change we need to edit in this application is to start the acquisition of the TSC peripheral, since it needed
      to be manually started.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-c">/* zephyr/samples/subsys/input/input_dump/src/main.c */</span>

<span class="pl-k">#include</span> <span class="pl-s">&lt;stdio.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/kernel.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/misc/stm32_tsc/stm32_tsc.h&gt;</span>

<span class="pl-smi">int</span> <span class="pl-en">main</span>(<span class="pl-smi">void</span>)
{
 <span class="pl-en">printf</span>(<span class="pl-s">"Input sample started\n"</span>);

 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_dev</span> <span class="pl-c1">=</span> <span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-en">DT_NODELABEL</span>(<span class="pl-s1">tsc</span>));

 <span class="pl-k">if</span> (!<span class="pl-en">device_is_ready</span>(<span class="pl-s1">tsc_dev</span>))
 {
  <span class="pl-en">printf</span>(<span class="pl-s">"TSC device is not ready\n"</span>);
  <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">ENODEV</span>;
 }

 <span class="pl-k">while</span> (<span class="pl-c1">1</span>)
 {
  <span class="pl-c">/* This will start the acqusition and print the readings to input subsystem */</span>
  <span class="pl-en">stm32_tsc_start</span>(<span class="pl-s1">tsc_dev</span>);

    <span class="pl-c">/* You can alternatively disable interrupts and</span>
<span class="pl-c">   * poll for acquisition completion. */</span>
<span class="pl-k">#if</span> !<span class="pl-en">IS_ENABLED</span>(<span class="pl-c1">CONFIG_STM32_TSC_INTERRUPT</span>)
  <span class="pl-smi">int</span> <span class="pl-s1">ret</span> <span class="pl-c1">=</span> <span class="pl-en">stm32_tsc_poll_for_acquisition</span>(<span class="pl-s1">tsc_dev</span>, <span class="pl-en">K_MSEC</span>(<span class="pl-c1">100</span>));
  <span class="pl-k">if</span> (<span class="pl-s1">ret</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span>)
  {
   <span class="pl-en">printf</span>(<span class="pl-s">"Failed to poll for acquisition\n"</span>);
   <span class="pl-k">return</span> <span class="pl-s1">ret</span>;
  }

  <span class="pl-smi">uint32_t</span> <span class="pl-s1">value</span>;
  <span class="pl-s1">ret</span> <span class="pl-c1">=</span> <span class="pl-en">stm32_tsc_read</span>(<span class="pl-s1">tsc_dev</span>, <span class="pl-c1">6</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">value</span>);
  <span class="pl-k">if</span> (<span class="pl-s1">ret</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span>)
  {
   <span class="pl-en">printf</span>(<span class="pl-s">"Failed to read TSC\n"</span>);
   <span class="pl-k">return</span> <span class="pl-s1">ret</span>;
  }

  <span class="pl-en">printf</span>(<span class="pl-s">"TSC value: %u\n"</span>, <span class="pl-s1">value</span>);
<span class="pl-k">#endif</span>

  <span class="pl-en">k_msleep</span>(<span class="pl-c1">100</span>);
 }

 <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre>
    </div>
    <p>If you remember we kept the <code class="notranslate">status</code> of TSC at <code
        class="notranslate">disabled</code> in the device tree, so we need to change it to <code
        class="notranslate">okay</code> in the application overlay to be able to use it in the application.</p>
    <pre lang="devicetree" class="notranslate"><code class="notranslate">/* zephyr/samples/subsys/input/input_dump/boards/stm32u083c_dk.overlay */

&amp;tsc {
 status = "okay";
};
</code></pre>
    <p>Now all its left is to enable the driver in the config file of the application.</p>
    <pre lang="Kconfig" class="notranslate"><code class="notranslate"># zephyr/samples/subsys/input/input_dump/prj.conf
CONFIG_STM32_TSC=y
</code></pre>
    <p>after all these changes, west is ready to build the application.</p>
    <div class="highlight highlight-source-shell">
      <pre class="notranslate">west build -b stm32u083c_dk zephyr/samples/subsys/input/input_dump</pre>
    </div>
    <h3>Flashing</h3>
    <h4>Linux</h4>
    <p>If your host is Linux, you can use USB pass-through to flash the device. For this the devcontainer should be
      started with host's USB bus.</p>
    <p>There are several ways to do this but one way is to add it in <code class="notranslate">devcontainer.json</code>
    </p>
    <div class="highlight highlight-source-json">
      <pre
        class="notranslate"><span class="pl-ent">"mounts"</span>: [<span class="pl-s"><span class="pl-pds">"</span>type=bind,source=/dev/bus/usb,target=/dev/bus/usb<span class="pl-pds">"</span></span>]</pre>
    </div>
    <h4>Windows</h4>
    <p>If your host is Windows, USB pass-through is not possible. But you can use USB/IP to share the USB device with
      the container. This is a bit more complicated but it is possible. Please read the <a
        href="https://learn.microsoft.com/en-us/windows/wsl/connect-usb" rel="nofollow">Microsoft's documentation</a> on
      how to do this.</p>
    <h4>OSX</h4>
    <p>I am not sure if USB pass-through is possible, but USB/IP is currently unavailable on OSX. In this case you are
      on your own. I recommend pulling the files from the volume and flashing on the host with vendor tools, or opening
      an openOCD remote server and connecting to it inside the container.</p>
    <p>After starting the container with a mount or USB/IP, you can flash the device with the following command.</p>
    <div class="highlight highlight-source-shell">
      <pre class="notranslate">west flash</pre>
    </div>
    <p>and if you connect to the USB Serial port with a terminal emulator (115200bps), we should see the input events
      printed on the console.</p>
    <div class="highlight highlight-source-shell">
      <pre class="notranslate"><span class="pl-k">***</span> Booting Zephyr OS build 5466949aefaf <span class="pl-k">***</span>
Input sample started
I: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1813
I: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1803
I: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1801
I: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1811
I: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1820
I: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1815</pre>
    </div>
    <p>How do we know which group's value is this? From the <a href="#hardware-configuration">schematic</a> it is
      connected to the group 6, but as you can see the <code class="notranslate">code</code> field for this input event
      is <code class="notranslate">2</code>, and that is the <code class="notranslate">zephyr,code</code> field in the
      device tree. So we can check the <code class="notranslate">zephyr,code</code> field of the group 6 in the device
      tree and see it is <code class="notranslate">2</code>.</p>
    <h3>Integration Testing</h3>
    <p>This step can be done at the beginning of the driver implementation to make sure the driver works as expected.
      This is called <a href="https://en.wikipedia.org/wiki/Test-driven_development" rel="nofollow">TDD</a> (Test Driven
      Development) and it is a good practice to write tests before writing the actual code. But for the sake of this
      document I'll write the tests here. These tests can also be used to test the further modifications to the driver
      to make sure there is no regression in the driver when a change is made.</p>
    <h4>What to Test?</h4>
    <p>There are two main options that can be tested in this driver. One is to test the driver API and its behavior, and
      the other is to test the actual register states for this peripheral, and see if it matches the device tree
      configuration.</p>
    <p>Our initial tests kept interrupt enabled, but in the integration tests we should test with and without this
      feature; <code class="notranslate">CONFIG_STM32_TSC_INTERRUPT</code>.</p>
    <h4>Test Plan</h4>
    <p>Here I outline the simple test plan for this driver. This might seem not enough to some, but should cover most
      cases.</p>
    <ul>
      <li>Test MMIO
        <ul>
          <li>Check if the registers are set correctly</li>
        </ul>
      </li>
      <li>Test the driver API (interrupt)
        <ul>
          <li>Start the acquisition</li>
          <li>Test if input events are reported</li>
        </ul>
      </li>
      <li>Test the driver API (polling)
        <ul>
          <li>Start the acquisition</li>
          <li>Poll for acquisition</li>
          <li>Read the values</li>
        </ul>
      </li>
    </ul>
    <h4>Test Application</h4>
    <p>A test application (or a test suite as Zephyr calls it) is just another application that can either run on the
      host or on the target. Only difference is the inclusion of the <code class="notranslate">ztest</code> library and
      the test functions with an additional <code class="notranslate">testcase.yml</code> file for the test runner (<a
        href="https://docs.zephyrproject.org/latest/develop/test/twister.html" rel="nofollow">twister</a>) to pick up
      the application as a test.</p>
    <p>I'll create a new application in the <code class="notranslate">tests/drivers/misc/stm32_tsc</code> directory and
      add my files there.</p>
    <h5>CMakeLists.txt</h5>
    <p>This is just a generic cmake file that used in any other application cmake file.</p>
    <div class="highlight highlight-source-cmake">
      <pre
        class="notranslate"><span class="pl-c"><span class="pl-c">#</span> zephyr/tests/drivers/misc/stm32_tsc/CMakeLists.txt</span>
<span class="pl-c1">cmake_minimum_required</span>(<span class="pl-k">VERSION</span> 3.20.0)
<span class="pl-c1">find_package</span>(Zephyr <span class="pl-k">REQUIRED</span> <span class="pl-k">HINTS</span> <span class="pl-smi">$ENV{ZEPHYR_BASE}</span>)
<span class="pl-c1">project</span>(stm32_tsc)

<span class="pl-c1">FILE</span>(<span class="pl-k">GLOB</span> app_sources src/*.c)
<span class="pl-c1">target_sources</span>(app <span class="pl-k">PRIVATE</span> <span class="pl-smi">${app_sources}</span>)</pre>
    </div>
    <h5>prj.conf</h5>
    <p>Since we do not have any emulator for TSC peripheral, we will run all the tests on the hardware.</p>
    <pre lang="conf" class="notranslate"><code class="notranslate"># tests/drivers/misc/stm32_tsc/prj.conf
CONFIG_STM32_TSC=y
CONFIG_ZTEST=y
CONFIG_INPUT=y
CONFIG_INPUT_MODE_SYNCHRONOUS=y
</code></pre>
    <p>This enables the driver and the test framework, and also the input subsystem to be able to test input events.</p>
    <h5>Device tree overlays</h5>
    <p>This devicetree modification is to make sure we use different values for the configuration than the reset values
      of the TSC peripheral, so that we can hit the parts of our code that sets the registers.</p>
    <p>This includes using <code class="notranslate">synced acquisition</code> as discussed in the <a
        href="#hardware-configuration">Hardware Configuration</a> section. This requires two different additional pin
      configurations, one for the sync input pin and the other one is to trigger the sync pin. In the following example
      I've used generic <a href="https://docs.zephyrproject.org/latest/build/dts/zephyr-user-node.html"
        rel="nofollow"><code class="notranslate">zephyr,user</code></a> node to define the trigger pin, which I
      arbitrarily chose to be <code class="notranslate">GPIOA 10</code> which is exposed in my development kit.</p>
    <p>And for the sync pin, I've used <code class="notranslate">PD2</code> but this is not an arbitrary pin and it has
      been chosen with the help of the <a href="https://www.st.com/resource/en/datasheet/stm32u083kc.pdf"
        rel="nofollow">MCU datasheet</a>. Luckily this pin is also exposed in my development kit.</p>
    <p>Since we are overwriting <code class="notranslate">pinctrl-0</code> property, we have to re-supply the previous
      channel pins, we do not have to re define them as they will be defined in the original <code
        class="notranslate">.dts</code> file.</p>
    <pre lang="devicetree" class="notranslate"><code class="notranslate">/* zephyr/tests/drivers/misc/stm32_tsc/boards/stm32u083c_dk.overlay */
#include &lt;zephyr/dt-bindings/misc/stm32-tsc-defines.h&gt;

/ {
    zephyr,user {
        /* This will be used to trigger the SYNC pin high and low programmatically. They have to be connected with a jumper cable */
        signal-gpios = &lt;&amp;gpioa 10 GPIO_ACTIVE_HIGH&gt;;
    };
};

&amp;tsc {
    status = "okay";

    pinctrl-0 = &lt;&amp;tsc_shield_pb12 &amp;tsc_shield_cs_pb13 &amp;tsc_g6_io1_pd10 &amp;tsc_g6_io2_pd11 &amp;syncpin&gt;;
    pinctrl-names = "default";

    pulse-generator-prescaler = &lt;TSC_PG_PRESC_DIV128&gt;;

    spread-spectrum;
    spread-spectrum-prescaler = &lt;2&gt;;
    spread-spectrum-deviation = &lt;10&gt;;

    max-count-value = &lt;TSC_MCV_16383&gt;; 

    synced-acquisition;
    syncpol-rising;
};

&amp;pinctrl {
  syncpin: syncpin_pd2 {
    pinmux = &lt;STM32_PINMUX('D', 2, AF9)&gt;;
    drive-open-drain;
  };
};
</code></pre>
    <p>This devicetree modification will make sure the driver will be utilized to its full extent.</p>
    <h5>testcase.yml</h5>
    <p>This file is searched when the test runner twister is run. There is a pretty comprehensive <a
        href="https://docs.zephyrproject.org/latest/develop/test/twister.html" rel="nofollow">documentation</a> on how
      to write this file.</p>
    <p>Here we will use a pretty simple one.</p>
    <div class="highlight highlight-source-yaml">
      <pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> zephyr/tests/drivers/misc/stm32_tsc/testcase.yml</span>
<span class="pl-ent">tests</span>:
  <span class="pl-ent">drivers.misc.stm32_tsc</span>:
    <span class="pl-ent">tags</span>: <span class="pl-s">drivers misc stm32 tsc</span>
    <span class="pl-ent">filter</span>: <span class="pl-s">dt_compat_enabled("st,stm32-tsc")</span>
  <span class="pl-ent">drivers.misc.stm32_tsc_poll</span>:
    <span class="pl-ent">tags</span>: <span class="pl-s">drivers misc stm32 tsc poll</span>
    <span class="pl-ent">filter</span>: <span class="pl-s">dt_compat_enabled("st,stm32-tsc")</span>
    <span class="pl-ent">extra_args</span>: <span class="pl-s">CONFIG_STM32_TSC_INTERRUPT=n</span></pre>
    </div>
    <p>We can define multiple tests in a single file and each will be built, flashed and run separately. In this case
      I've defined two tests with two different configurations. These tests are called <code
        class="notranslate">drivers.misc.stm32_tsc</code> and <code
        class="notranslate">drivers.misc.stm32_tsc_poll</code>. The first one will test the driver with interrupt
      enabled and the second one will test the driver with polling enabled. There are also properties like <code
        class="notranslate">tags</code> which twister uses to scope and run multiple tests and <code
        class="notranslate">filter</code> which is used to figure out if the test should be run or not. In this case the
      test will only run if the device tree node <code class="notranslate">st,stm32-tsc</code> is enabled.</p>
    <h4>Test Cases</h4>
    <h5>Test Setup</h5>
    <p>We want to run a setup function before each test, and define out test suite first.</p>
    <div class="highlight highlight-source-c">
      <pre
        class="notranslate"><span class="pl-c">/* zephyr/tests/drivers/misc/stm32_tsc/src/main.c */</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/device.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/gpio.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/drivers/misc/stm32_tsc/stm32_tsc.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/kernel.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;zephyr/ztest.h&gt;</span>

<span class="pl-k">#if</span> <span class="pl-en">DT_HAS_COMPAT_STATUS_OKAY</span>(<span class="pl-s1">st_stm32_tsc</span>)
  <span class="pl-k">#define</span> <span class="pl-c1">TSC_NODE</span> DT_INST(0, st_stm32_tsc)
<span class="pl-k">#else</span>
  <span class="pl-k">#error</span> "Define a TSC device"
<span class="pl-k">#endif</span>

<span class="pl-k">#define</span> <span class="pl-c1">ZEPHYR_USER_NODE</span> DT_PATH(zephyr_user)

<span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">gpio_dt_spec</span> <span class="pl-s1">signal</span> <span class="pl-c1">=</span>
  <span class="pl-en">GPIO_DT_SPEC_GET</span>(<span class="pl-c1">ZEPHYR_USER_NODE</span>, <span class="pl-s1">signal_gpios</span>);

<span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-c1">*</span><span class="pl-en">stm32_tsc_setup</span>(<span class="pl-smi">void</span>)
{
  <span class="pl-en">zassert_true</span>(<span class="pl-en">device_is_ready</span>(<span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-c1">TSC_NODE</span>)), <span class="pl-s">"STM32 TSC device is not ready"</span>);
  <span class="pl-en">zexpect_ok</span>(<span class="pl-en">gpio_pin_configure_dt</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">signal</span>, <span class="pl-c1">GPIO_OUTPUT_INACTIVE</span>), <span class="pl-s">"Failed to configure signal pin"</span>);
  <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
}

<span class="pl-en">ZTEST_SUITE</span>(<span class="pl-s1">stm32_tsc</span>, <span class="pl-c1">NULL</span>, <span class="pl-s1">stm32_tsc_setup</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>);</pre>
    </div>
    <p>You can return a special data struct to be used in your tests by returning it in the setup function. Also you can
      define a teardown function to run after each test. I kept them <code class="notranslate">NULL</code> for now.</p>
    <p>Please find more information about the <code class="notranslate">ztest</code> library in the <a
        href="https://docs.zephyrproject.org/latest/develop/test/ztest.html" rel="nofollow">Ztest documentation</a>.</p>
    <h5>First Test Case</h5>
    <p>A simple test case has the following structure;</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-en">ZTEST</span>(<span class="pl-s1">test_suite_name</span>, <span class="pl-s1">test_testname</span>)
{
  <span class="pl-c">/* Test code */</span>
}</pre>
    </div>
    <p>By this definition lets keep the first test simple and just check if the device is ready (<code
        class="notranslate">stm32_tsc_init</code> function returns 0).</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-c">/* zephyr/tests/drivers/misc/stm32_tsc/src/main.c */</span>
<span class="pl-en">ZTEST</span>(<span class="pl-s1">stm32_tsc</span>, <span class="pl-s1">test_1_device_ready</span>)
{
  <span class="pl-en">zassert_true</span>(<span class="pl-en">device_is_ready</span>(<span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-c1">TSC_NODE</span>)), <span class="pl-s">"STM32 TSC device is not ready"</span>);
}</pre>
    </div>
    <h5>Test MMIO</h5>
    <p>The first thing we will test is the <code class="notranslate">CR</code> register of the TSC peripheral, this
      register is where most of the configuration is done except for the group configurations, which we will test in the
      next test.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-c">/* zephyr/tests/drivers/misc/stm32_tsc/src/main.c */</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;soc.h&gt;</span>
<span class="pl-en">ZTEST</span>(<span class="pl-s1">stm32_tsc</span>, <span class="pl-s1">test_2_cr_reg</span>)
{
 <span class="pl-smi">TSC_TypeDef</span>  <span class="pl-c1">*</span><span class="pl-s1">tsc</span> <span class="pl-c1">=</span> (<span class="pl-smi">TSC_TypeDef</span> <span class="pl-c1">*</span>)<span class="pl-en">DT_REG_ADDR</span>(<span class="pl-c1">TSC_NODE</span>);
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>;
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>   <span class="pl-s1">pgpsc</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-s1">pulse_generator_prescaler</span>);
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>   <span class="pl-s1">ctph</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-s1">ctph</span>);
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>   <span class="pl-s1">ctpl</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-s1">ctpl</span>);
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>   <span class="pl-s1">ssd</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP_OR</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-s1">spread_spectrum_deviation</span>, <span class="pl-c1">0</span>);
 <span class="pl-k">const</span> <span class="pl-smi">bool</span>   <span class="pl-s1">spread_spectrum</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP_OR</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-s1">spread_spectrum</span>, false);
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>   <span class="pl-s1">sscpsc</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP_OR</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-s1">spread_spectrum_prescaler</span>, <span class="pl-c1">0</span>);
 <span class="pl-k">const</span> <span class="pl-smi">uint8_t</span>   <span class="pl-s1">max_count</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP_OR</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-s1">max_count_value</span>, <span class="pl-c1">0</span>);
 <span class="pl-k">const</span> <span class="pl-smi">bool</span>   <span class="pl-s1">iodef</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP_OR</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-s1">iodef_float</span>, false);
 <span class="pl-k">const</span> <span class="pl-smi">bool</span>   <span class="pl-s1">sync_pol</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP_OR</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-s1">syncpol_rising</span>, false);
 <span class="pl-k">const</span> <span class="pl-smi">bool</span>   <span class="pl-s1">sync_acq</span> <span class="pl-c1">=</span> <span class="pl-en">DT_PROP_OR</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-s1">synced_acquisition</span>, false);

 <span class="pl-c">/* check charge transfer pulse high value (bits 31:28) */</span>
 <span class="pl-en">zassert_equal</span>((<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_CTPL_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_CTPL_Pos</span>, <span class="pl-s1">ctph</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>, <span class="pl-s">"CTPH value is not correct, expected %d, got %d"</span>, <span class="pl-s1">ctph</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>, (<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_CTPL_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_CTPL_Pos</span>);

 <span class="pl-c">/* check charge transfer pulse low value (bits 27:24) */</span>
 <span class="pl-en">zassert_equal</span>((<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_CTPL_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_CTPL_Pos</span>, <span class="pl-s1">ctpl</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>, <span class="pl-s">"CTPL value is not correct, expected %d, got %d"</span>, <span class="pl-s1">ctpl</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>, (<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_CTPL_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_CTPL_Pos</span>);

 <span class="pl-c">/* check spread spectrum deviation value (bits 23:17) */</span>
 <span class="pl-en">zassert_equal</span>((<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_SSD_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_SSD_Pos</span>, <span class="pl-s1">ssd</span>, <span class="pl-s">"SSD value is not correct, expected %d, got %d"</span>, <span class="pl-s1">ssd</span>, (<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_SSD_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_SSD_Pos</span>);

 <span class="pl-c">/* check spread spectrum enable bit (bit 16) */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">spread_spectrum</span>)
  <span class="pl-en">zexpect_true</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_SSE_Msk</span>);
 <span class="pl-k">else</span>
  <span class="pl-en">zexpect_false</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_SSE_Msk</span>);

 <span class="pl-c">/* check spread spectrum prescaler value (bits 15) */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">sscpsc</span> <span class="pl-c1">==</span> <span class="pl-c1">2</span>)
  <span class="pl-en">zexpect_true</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_SSPSC_Msk</span>);
 <span class="pl-k">else</span>
  <span class="pl-en">zexpect_false</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_SSPSC_Msk</span>);

 <span class="pl-c">/* check pulse generator prescaler value (bits 14:12) */</span>
 <span class="pl-en">zassert_equal</span>((<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_PGPSC_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_PGPSC_Pos</span>, <span class="pl-s1">pgpsc</span>, <span class="pl-s">"PGPSC value is not correct, expected %d, got %d"</span>, <span class="pl-s1">pgpsc</span>, (<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_PGPSC_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_PGPSC_Pos</span>);

 <span class="pl-c">/* check max count value (bits 7:5) */</span>
 <span class="pl-en">zassert_equal</span>((<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_MCV_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_MCV_Pos</span>, <span class="pl-s1">max_count</span>, <span class="pl-s">"MCV value is not correct, expected %d, got %d"</span>, <span class="pl-s1">max_count</span>, (<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_MCV_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_MCV_Pos</span>);

 <span class="pl-c">/* check I/O default mode bit (bit 4) */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">iodef</span>)
  <span class="pl-en">zexpect_true</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_IODEF_Msk</span>);
 <span class="pl-k">else</span>
  <span class="pl-en">zexpect_false</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_IODEF_Msk</span>);

 <span class="pl-c">/* check sync polarity bit (bit 3) */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">sync_pol</span>)
  <span class="pl-en">zexpect_true</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_SYNCPOL_Msk</span>);
 <span class="pl-k">else</span>
  <span class="pl-en">zexpect_false</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_SYNCPOL_Msk</span>);

 <span class="pl-c">/* check sync acquisition bit (bit 2) */</span>
 <span class="pl-k">if</span> (<span class="pl-s1">sync_acq</span>)
  <span class="pl-en">zexpect_true</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_AM_Msk</span>);
 <span class="pl-k">else</span>
  <span class="pl-en">zexpect_false</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_AM_Msk</span>);

 <span class="pl-c">/* check start bit (bit 1) */</span>
 <span class="pl-en">zexpect_false</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_START_Msk</span>);

 <span class="pl-c">/* check TSC enable bit (bit 0) */</span>
 <span class="pl-en">zexpect_true</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_TSCE_Msk</span>);
}</pre>
    </div>
    <p>This is a lenghty test, but it is just checking if the values in the device tree are set correctly in the <code
        class="notranslate">CR</code> register of the TSC peripheral.</p>
    <p>To test the group configurations, we need to test the registers like <code class="notranslate">IOCCR</code>,
      <code class="notranslate">IOSCR</code> and <code class="notranslate">IOGCSR</code> of the TSC peripheral.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-c">/* zephyr/tests/drivers/misc/stm32_tsc/src/main.c */</span>
<span class="pl-en">ZTEST</span>(<span class="pl-s1">stm32_tsc</span>, <span class="pl-s1">test_3_group_registers</span>)
{
 <span class="pl-smi">TSC_TypeDef</span>  <span class="pl-c1">*</span><span class="pl-s1">tsc</span> <span class="pl-c1">=</span> (<span class="pl-smi">TSC_TypeDef</span> <span class="pl-c1">*</span>)<span class="pl-en">DT_REG_ADDR</span>(<span class="pl-c1">TSC_NODE</span>);
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_iohcr</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOHCR</span>;
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_ioscr</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOSCR</span>;
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_ioccr</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOCCR</span>;
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_iogcsr</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IOGCSR</span>;

<span class="pl-k">#define</span> <span class="pl-en">GET_GROUP_BITS</span>(<span class="pl-s1">val</span>) (uint32_t)(((val) &amp; 0x0f) &lt;&lt; ((group - 1) * 4))

<span class="pl-k">#define</span> <span class="pl-en">STM32_TSC_GROUP_TEST</span>(<span class="pl-s1">node</span>)                                                                                                                                                                                                         \
 do                                                                                                                                                                                                                                 \
 {                                                                                                                                                                                                                                  \
  const uint8_t group = DT_PROP(node, group);                                                                                                                                                                                \
  const uint8_t channel_ios = DT_PROP(node, channel_ios);                                                                                                                                                                    \
  const uint8_t sampling_io = DT_PROP(node, sampling_io);                                                                                                                                                                    \
  const bool    use_as_shield = DT_PROP(node, use_as_shield);                                                                                                                                                                \
                                                                                                                                                                                                                                           \
  /* check schmitt trigger hysteresis for enabled I/Os */                                                                                                                                                                    \
  zassert_equal((*tsc_iohcr &amp; GET_GROUP_BITS(channel_ios | sampling_io)), 0, "Schmitt trigger hysteresis not disabled, expected %d, got %d", 0, (*tsc_iohcr &amp; GET_GROUP_BITS(channel_ios | sampling_io)));                   \
                                                                                                                                                                                                                                           \
  /* check channel I/Os */                                                                                                                                                                                                   \
  zassert_equal((*tsc_ioccr &amp; GET_GROUP_BITS(channel_ios)), GET_GROUP_BITS(channel_ios), "Channel I/Os value is not correct, expected %d, got %d", GET_GROUP_BITS(channel_ios), (*tsc_ioccr &amp; GET_GROUP_BITS(channel_ios))); \
                                                                                                                                                                                                                                           \
  /* check sampling I/O */                                                                                                                                                                                                   \
  zassert_equal((*tsc_ioscr &amp; GET_GROUP_BITS(sampling_io)), GET_GROUP_BITS(sampling_io), "Sampling I/O value is not correct, expected %d, got %d", GET_GROUP_BITS(sampling_io), (*tsc_ioscr &amp; GET_GROUP_BITS(sampling_io))); \
                                                                                                                                                                                                                                           \
  /* check enabled groups */                                                                                                                                                                                                 \
  if (use_as_shield)                                                                                                                                                                                                         \
   zassert_not_equal((*tsc_iogcsr &amp; BIT(group - 1)), BIT(group - 1), "Group %d is a shield group and should not be enabled", group);                                                                                  \
  else                                                                                                                                                                                                                       \
   zassert_equal((*tsc_iogcsr &amp; BIT(group - 1)), BIT(group - 1), "Group %d is not enabled", group);                                                                                                                   \
 } while (0);

 <span class="pl-en">DT_FOREACH_CHILD_STATUS_OKAY</span>(<span class="pl-c1">TSC_NODE</span>, <span class="pl-c1">STM32_TSC_GROUP_TEST</span>);
}</pre>
    </div>
    <h5>API Tests</h5>
    <p>The first test will be to test the polling function of the driver. For this the setting <code
        class="notranslate">CONFIG_STM32_TSC_INTERRUPT</code> needs to be set to <code class="notranslate">n</code>
      before building the application which is what we did in the <a href="#testcaseyml">testcase.yml</a> file.</p>
    <p>But this test case will run regardless of any Kconfig settings, so we need to skip the test if the interrupt is
      enabled.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-c">/* zephyr/tests/drivers/misc/stm32_tsc/src/main.c */</span>
<span class="pl-en">ZTEST</span>(<span class="pl-s1">stm32_tsc</span>, <span class="pl-s1">test_4_acquisition_polling</span>)
{
 <span class="pl-en">Z_TEST_SKIP_IFDEF</span>(<span class="pl-c1">CONFIG_STM32_TSC_INTERRUPT</span>);

 <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">device</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_dev</span> <span class="pl-c1">=</span> <span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-c1">TSC_NODE</span>);
 <span class="pl-smi">TSC_TypeDef</span>  <span class="pl-c1">*</span><span class="pl-s1">tsc</span> <span class="pl-c1">=</span> (<span class="pl-smi">TSC_TypeDef</span> <span class="pl-c1">*</span>)<span class="pl-en">DT_REG_ADDR</span>(<span class="pl-c1">TSC_NODE</span>);
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>;
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_ier</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IER</span>;
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_isr</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ISR</span>;

 <span class="pl-en">stm32_tsc_start</span>(<span class="pl-s1">tsc_dev</span>);

 <span class="pl-c">/* this should timeout because sync pin is not triggered */</span>
 <span class="pl-en">zexpect_not_ok</span>(<span class="pl-en">stm32_tsc_poll_for_acquisition</span>(<span class="pl-s1">tsc_dev</span>, <span class="pl-en">K_MSEC</span>(<span class="pl-c1">100</span>)));

 <span class="pl-en">stm32_tsc_start</span>(<span class="pl-s1">tsc_dev</span>);

 <span class="pl-en">zexpect_ok</span>(<span class="pl-en">gpio_pin_toggle_dt</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">signal</span>));

 <span class="pl-c">/* check if interrupts are disabled */</span>
 <span class="pl-en">zexpect_false</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_ier</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_IER_EOAIE_Msk</span>);
 <span class="pl-en">zexpect_false</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_ier</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_IER_MCEIE_Msk</span>);

 <span class="pl-c">/* test CR register start bit */</span>
 <span class="pl-en">zexpect_true</span>((<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_START_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_START_Pos</span>);

 <span class="pl-en">zexpect_ok</span>(<span class="pl-en">stm32_tsc_poll_for_acquisition</span>(<span class="pl-s1">tsc_dev</span>, <span class="pl-en">K_MSEC</span>(<span class="pl-c1">100</span>)));

 <span class="pl-c">/* test for max count error flag */</span>
 <span class="pl-en">zexpect_false</span>((<span class="pl-c1">*</span><span class="pl-s1">tsc_isr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_ISR_MCEF_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_ISR_MCEF_Pos</span>);

 <span class="pl-smi">uint32_t</span> <span class="pl-s1">value</span>;
 <span class="pl-en">zexpect_ok</span>(<span class="pl-en">stm32_tsc_read</span>(<span class="pl-s1">tsc_dev</span>, <span class="pl-c1">6</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">value</span>));
}</pre>
    </div>
    <p>The next test will be to test the interrupt driven acquisition. This test will run only if the <code
        class="notranslate">CONFIG_STM32_TSC_INTERRUPT</code> is enabled.</p>
    <div class="highlight highlight-source-c">
      <pre class="notranslate"><span class="pl-k">static</span> <span class="pl-k">volatile</span> <span class="pl-smi">bool</span> <span class="pl-s1">tsc_input_received</span>;

<span class="pl-k">static</span> <span class="pl-smi">void</span>      <span class="pl-en">tsc_input_callback</span>(<span class="pl-k">struct</span> <span class="pl-smi">input_event</span> <span class="pl-c1">*</span><span class="pl-s1">evt</span>, <span class="pl-smi">void</span> <span class="pl-c1">*</span><span class="pl-s1">user_data</span>)
{
 <span class="pl-en">ARG_UNUSED</span>(<span class="pl-s1">evt</span>);
 <span class="pl-en">ARG_UNUSED</span>(<span class="pl-s1">user_data</span>);

 <span class="pl-s1">tsc_input_received</span> <span class="pl-c1">=</span> true;
}
<span class="pl-en">INPUT_CALLBACK_DEFINE</span>(<span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-c1">TSC_NODE</span>), <span class="pl-s1">tsc_input_callback</span>, <span class="pl-c1">NULL</span>);

<span class="pl-en">ZTEST</span>(<span class="pl-s1">stm32_tsc</span>, <span class="pl-s1">test_5_acquisition_interrupt</span>)
{
 <span class="pl-en">Z_TEST_SKIP_IFNDEF</span>(<span class="pl-c1">CONFIG_STM32_TSC_INTERRUPT</span>);

 <span class="pl-smi">TSC_TypeDef</span>  <span class="pl-c1">*</span><span class="pl-s1">tsc</span> <span class="pl-c1">=</span> (<span class="pl-smi">TSC_TypeDef</span> <span class="pl-c1">*</span>)<span class="pl-en">DT_REG_ADDR</span>(<span class="pl-c1">TSC_NODE</span>);
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">CR</span>;
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_ier</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">IER</span>;
 <span class="pl-k">volatile</span> <span class="pl-k">const</span> <span class="pl-smi">uint32_t</span> <span class="pl-c1">*</span><span class="pl-s1">tsc_isr</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">tsc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ISR</span>;

 <span class="pl-s1">tsc_input_received</span> <span class="pl-c1">=</span> false;

 <span class="pl-en">stm32_tsc_start</span>(<span class="pl-en">DEVICE_DT_GET</span>(<span class="pl-c1">TSC_NODE</span>));

 <span class="pl-c">/* test CR register start bit */</span>
 <span class="pl-en">zexpect_true</span>((<span class="pl-c1">*</span><span class="pl-s1">tsc_cr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_CR_START_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_CR_START_Pos</span>);

 <span class="pl-c">/* check if interrupts are enabled */</span>
 <span class="pl-en">zexpect_true</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_ier</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_IER_EOAIE_Msk</span>);
 <span class="pl-en">zexpect_true</span>(<span class="pl-c1">*</span><span class="pl-s1">tsc_ier</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_IER_MCEIE_Msk</span>);

 <span class="pl-en">k_sleep</span>(<span class="pl-en">K_MSEC</span>(<span class="pl-c1">100</span>));

 <span class="pl-c">/* test ISR register max count error flag */</span>
 <span class="pl-en">zexpect_false</span>((<span class="pl-c1">*</span><span class="pl-s1">tsc_isr</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">TSC_ISR_MCEF_Msk</span>) &gt;&gt; <span class="pl-s1">TSC_ISR_MCEF_Pos</span>);

 <span class="pl-c">/* this should fail because of the sync pin */</span>
 <span class="pl-en">zexpect_false</span>(<span class="pl-s1">tsc_input_received</span>);

 <span class="pl-en">zexpect_ok</span>(<span class="pl-en">gpio_pin_toggle_dt</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">signal</span>));

 <span class="pl-en">k_sleep</span>(<span class="pl-en">K_MSEC</span>(<span class="pl-c1">100</span>));

 <span class="pl-en">zexpect_true</span>(<span class="pl-s1">tsc_input_received</span>);
}</pre>
    </div>
    <p>Here in this test a 100ms window is given to allow TSC peripheral to start acqusition and put the value to the
      input subsystem. The <code class="notranslate">tsc_input_callback</code> function is defined to set a flag when an
      input event is received.</p>
    <p>Notice how we use <code class="notranslate">signal</code> and <code class="notranslate">gpio_pin_toggle_dt</code>
      to mock and test the presence and absence of an external trigger for the TSC peripheral.</p>
    <h4>Running the Tests</h4>
    <p>We will use the west extension commands to use twistter and run the tests.</p>
    <div class="highlight highlight-source-shell">
      <pre
        class="notranslate">west twister -T tests/drivers/misc/stm32_tsc --device-testing --device-serial COM4 -p stm32u083c_dk</pre>
    </div>
    <p>In this command we first select a specific test suite with <code class="notranslate">-T</code> flag, then we
      enable the device testing with <code class="notranslate">--device-testing</code> flag, and then we select the
      serial port with <code class="notranslate">--device-serial</code> flag and finally we select the board with <code
        class="notranslate">-p</code> flag, which stands for platform.</p>
    <div class="markdown-alert markdown-alert-note">
      <p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1"
          width="16" height="16" aria-hidden="true">
          <path
            d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z">
          </path>
        </svg>Note</p>
      <p>A physical connection with a jumper between PA10 and PD2 should be made before running the tests.</p>
    </div>
    <p>Twister will upload this and read the output from the serial port and let us know how it went. But for the fun of
      it, we can connect to the serial port with a terminal emulator and see the output.</p>
    <div class="highlight highlight-source-shell">
      <pre class="notranslate">---- Opened the serial port COM4 ----
<span class="pl-k">***</span> Booting Zephyr OS build 6aae5648ff4d <span class="pl-k">***</span>
Running TESTSUITE stm32_tsc
===================================================================
START - test_1_device_ready
 PASS - test_1_device_ready <span class="pl-k">in</span> 0.001 seconds
===================================================================
START - test_2_cr_reg
 PASS - test_2_cr_reg <span class="pl-k">in</span> 0.001 seconds
===================================================================
START - test_3_group_registers
 PASS - test_3_group_registers <span class="pl-k">in</span> 0.001 seconds
===================================================================
START - test_4_acquisition_polling
 SKIP - test_4_acquisition_polling <span class="pl-k">in</span> 0.001 seconds
===================================================================
START - test_5_acquisition_interrupt
 PASS - test_5_acquisition_interrupt <span class="pl-k">in</span> 0.201 seconds
===================================================================
TESTSUITE stm32_tsc succeeded

------ TESTSUITE SUMMARY START ------

SUITE PASS - 100.00% [stm32_tsc]: pass = 4, fail = 0, skip = 1, total = 5 duration = 0.205 seconds
 - PASS - [stm32_tsc.test_1_device_ready] duration = 0.001 seconds
 - PASS - [stm32_tsc.test_2_cr_reg] duration = 0.001 seconds
 - PASS - [stm32_tsc.test_3_group_registers] duration = 0.001 seconds
 - SKIP - [stm32_tsc.test_4_acquisition_polling] duration = 0.001 seconds
 - PASS - [stm32_tsc.test_5_acquisition_interrupt] duration = 0.201 seconds

------ TESTSUITE SUMMARY END ------

===================================================================
RunID: 54191c69b895b72ac69c072ecf65e1d0
PROJECT EXECUTION SUCCESSFUL</pre>
    </div>
    <p>Looks like everything is working just fine. Perfect!</p>
    <h2>Wrapping Up</h2>
    <p>We've implemented the driver and tested it on the hardware. This is now complete as a driver but still not usable
      as is, in a future post I'll implement a driver that uses this driver to generate input events that are usable
      (like actual clicks), instead of using the capture value and putting it in the input subsystem, which is not the
      ideal use of this subsystem at the moment.</p>
  </article>
</body>

</html>