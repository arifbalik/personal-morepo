{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog Posts","text":"<ul> <li>A Practical Guide to Zephyr Device Driver Development</li> </ul>"},{"location":"zephyr-device-driver/","title":"A Practical Guide to Zephyr Device Driver Development","text":"<p>This is a guide on how to write a production grade device driver in Zephyr. This includes driver code, testing, CI and many more. Do not consider this document as a tutorial to Zephyr or device drivers, I'll just showcase my workflow and the environment I use to develop device drivers in Zephyr. Some of this may not be suited for your workflow, but I'll try to keep each section on it's own so you can skip the parts you don't need or don't want to use.</p> <p>I'll not talk about some details and assume you have at least heard about Zephyr and device drivers. If you don't, or want to refresh your memory check out the official documentation. More of the talk will assume you were already developing on embedded projects and want to try something new, or you are already developing on Zephyr and want to see how others do it.</p> <p>Note</p> <p>Zephyr still makes big changes to the framework, so some of the information here might be outdated or not the best practice anymore. I'll try to keep this up to date as much as possible, and give version information anywhere I can. Also I'll run inside a development container for you readers to easily follow along. </p>"},{"location":"zephyr-device-driver/#introduction","title":"Introduction","text":"<p>I've known about Zephyr for a while now but only had the chance to work with it by the beginning of this year when I listened the this Amp Hour podcast. I've quickly come to realize the enormous benefits of using Zephyr for any kind of embedded project. From full blown RTOS running on x86 with network stacks and PCIe drivers to a microcontroller with 32KB of flash, Zephyr is a great choice for any project. It was surreal to edit devicetree files to configure a 50-cent microcontroller.</p> <p>Zephyr gives you a nice framework for everything embedded. You have device trees, device drivers, networking stacks, filesystems, a testing framework, a nice RTOS, a nice build system and anything else you can name. It abstracts low level hardware so nicely that you only need to write what your application ultimately wants to do in a hardware-agnostic way and have it run on anything without touching a single line of code.</p> <p>I especially liked the Zephyr because I was working on a range of similar products with an unorganized and distributed codebase, we needed to run our business logic on slightly different hardware platforms, so the device driver model and device trees was the perfect solution in this case. We initially got concerned about the size of the firmware as we were on very tight budget, we could only get 32KB and 64KB flash microcontrollers, and Zephyr seemed overkill for this, but it was not. It seems like the Zephyr team has a lot of experience in the embedded world and Linux in general, so they've made the right choice of making the entire thing customizable down to the detail. If you strip down everything you can get down to a ~3KB binary, which is amazing. But most of the time you want to use OS services and other features so you end up with a ~7KB-10KB binary for a minimal application.</p> <p>Most of the drivers are already in the Zephyr upstream, but you eventually have to write your own device drivers for your custom hardware. That's what I ended up doing, writing some device drivers, generating my custom board configurations and device trees, and wrote my application logic, and here I'll show you how I did it.</p>"},{"location":"zephyr-device-driver/#prerequisites-and-setup","title":"Prerequisites and Setup","text":"<p>First of all we need an environment to work in. In this environment we'll have all the tools we need to develop, test and debug our device driver. I usually prefer working in docker containers for reproducibility and ease of deployment. Therefore you need some tools installed in your host to get started.</p> <ul> <li>Docker (v26.0.0)</li> <li>VSCode (v1.92.0)</li> <li>Remote - Containers extension for VSCode (v0.389.0)</li> </ul> <p>Note</p> <p>I'm running on a x86 Windows machine, so I can use things like USBIP to debug my hardware connected to my host but this feature is not yet available in macOS, but we will also discuss about remote debugging in later sections.</p> <p>I assume most of you already have those installed, so lets quickly get started.</p>"},{"location":"zephyr-device-driver/#setup","title":"Setup","text":"<p>If you are using VSCode, you can use devcontainers feature to get your development environment up and running in no time. But you can also use any other editor or a terminal to do everything I'll show you here.</p> <p>If you want to work on your host machine, you can check out the official Zephyr documentation to setup your environment.</p> <p>The development container is based on official <code>zephyr-build</code> container in Zephyr's <code>docker-image</code> repository. I've added extra configurations to really integrate it into VSCode with extensions and tools. But basically it has:</p> <ul> <li>Zephyr SDK (0.16.8)</li> <li>All the system packages needed for Zephyr</li> <li>Python3 and pip packages (including west)</li> <li>Oh My Zsh</li> <li>VSCode Extensions</li> </ul> <p>Check out the devcontainer.json if you want to see the exact setup. To keep it compatible with non-vscode users, I kept the configuration minimal. I highly encourage you to modify the file to your needs. There are tons of customizations you can do with devcontainers.</p>"},{"location":"zephyr-device-driver/#using-the-container","title":"Using the container","text":"<p>The fastest way to start is to pull and run the image I prepared from my GitHub Container Registry with the following command:</p> <pre><code>docker run -it --name zephyr-dev -v zephyr-volume:/workdir ghcr.io/arifbalik/zephyr-dev:latest\n</code></pre> <p>This should drop you into a shell with the Zephyr SDK and all the tools installed.</p>"},{"location":"zephyr-device-driver/#vscode-remote-containers","title":"VSCode Remote Containers","text":"<p>Easiest method to work in a container is to use the <code>Remote - Containers</code> extension in VSCode. You can open the project folder in VSCode and click on the blue icon in the bottom left corner or with <code>ctrl + shift + p</code> and select <code>Attach to Running Container...</code> and select the container you just started.</p>"},{"location":"zephyr-device-driver/#building-the-container-optional","title":"Building the container (optional)","text":"<p>The building requires additional tools like node, npm and devcontainers package:</p> <p>First install the package;</p> <pre><code>npm install -g @devcontainers/cli\n</code></pre> <p>Then build the container with the following command:</p> <pre><code>devcontainer up --config /path/to/devcontainer.json --workspace-folder /path/to/your/workspace\n</code></pre>"},{"location":"zephyr-device-driver/#getting-started","title":"Getting Started","text":"<p>Now that we have a system we can build on. We'll use the <code>west</code> tool to get the zephyr repository and start implementing.</p>"},{"location":"zephyr-device-driver/#west-workspaces","title":"West Workspaces","text":"<p>Assuming we want to contribute to the open-source project, we will develop inside the Zephyr source, so the T1 topology is what will be used here, but personally I use free standing application workspaces for professional work, T3 topology to be more specific.</p> <p>Zephyr calls its workspaces <code>west workspaces</code>. And there are 3 main workspace types:</p> <ul> <li>Zephyr source as a workspace (T1)</li> <li>Zephyr application as a workspace (T2)</li> <li>Custom workspace with multiple Zephyr applications (you guessed it..)</li> </ul> <p>More information on them can be found here.</p> <p>Inside the container, we can start by initializing a workspace with the following command:</p> <pre><code>west init\n</code></pre> <p>This will create a <code>.west</code> directory and clone zephyr repository into the <code>/workdir</code> which is mounted as volume and its persistent. What also is required is the Zephyr modules and tools, update the workspace with the following command:</p> <pre><code>west update\n</code></pre> <p>This will fetch all source code that is outside of the Zephyr repository but needed to build an application, like the <code>hal_stm32</code> and <code>mcuboot</code> repositories.</p> <p>Warning</p> <p>Zephyr version is <code>v3.7.0</code> at the time of writing this document and it has a a bug that has been patched by me but is not in the v3.7.0, therefore if you want to be where I was when this document is written, check out to the <code>10fa1eab50ac54e41bf75ab0ad01daa4bd25ba13</code> hash of the <code>zephyr</code> repository, inside <code>zephyr/west.yml</code> file, or apply the patch yourself.</p> <p>This may take some time and it will load a ton of modules we won't need, therefore I highly recommend using a T2 or T3 topology for your projects. Once the update is done, a similar file structure should appear in the workspace;</p> <pre><code>.\n\u251c\u2500\u2500 bootloader\n\u251c\u2500\u2500 modules\n\u251c\u2500\u2500 tools\n\u251c\u2500\u2500 .west\n\u2514\u2500\u2500 zephyr\n</code></pre>"},{"location":"zephyr-device-driver/#device-driver-development","title":"Device Driver Development","text":"<p>Recently I had my hands on a devkit for STMicroelectronic's U0 series microcontrollers, and one peripheral I was interested was the TSC peripheral in this MCU. This is a peripheral used for capacitive touch sensing applications, buttons, sliders and things like that can be implemented with this peripheral (Notice the touch surface in the bottom right corner, it is a bare electrode and a 1mm insulating surface on top) You can implement a touch sensing application by using a PWM and an ADC maybe with comparator but this peripheral is very simple and does all that and a little bit more and offloads the CPU.</p> <p>Conveniently Zephyr does not have a driver for this peripheral. So I will write one here.</p>"},{"location":"zephyr-device-driver/#understanding-the-hardware","title":"Understanding the Hardware","text":"<p>This section goes a little bit into the details of the hardware we are working with. If you are not interested in this part or you already know the terminology you can skip to the next section.</p> <p>If you haven't worked with a capacitive touch sensing application before, allow me to tell you that it is not as easy as it seems when integrating touch sensing into a product end-to-end. Especially if you have stricter requirements for your application, like electrically noisy environments, or any industrial spec really immediately starts to complicate things and EMC becomes a big issue.</p> <p>A capacitive touch point is usually just a piece of conductive material, like a PCB pad. This piece of pad is leveraged to create a capacitive coupling with the human body, so you have to make a sandwich of these two conductive surfaces, (often a plastic is always in between the finger and the plate) forming a capacitor.</p> <p>Then this means we can charge the capacitor and do funky things with it, for example we can say that the capacitance changes when a finger is present than when it is not, and this can be used to detect a touch.</p> <p>Of course this is just one very specific setup with a single ended electrode, there are many setups and ways to do this, what we will specifically talk here is called Surface Charge Transfer (SCT) method, which is what this peripheral does.</p>"},{"location":"zephyr-device-driver/#surface-charge-transfer","title":"Surface Charge Transfer","text":"<p>The dotted capacitor in the figure above represents the capacitor of the electrode we just made with a finder and a conductive patch with an insulating layer in between.</p> <p>This method does not continuously check the voltage of this electrode, instead an external capacitor (in ranges from 1pf to couple hundreds of pf) called <code>sampling capactior</code> is used to transfer some charge in the electrode to this new capacitor (<code>Cs</code> in the figure above), this makes the readings much more repeatable and reliable.</p> <p>ST TSC in particular calls this combo a <code>group</code> and gives each group two extra channels for more custom applications. Each group has to have 1 sampling capacitor channel and at least one IO channel to function properly. These IO channels do not produce a value each, instead each channel is used to charge the same sampling capacitor, so a group will produce only one count value no matter the IO channel count. ST gives the example of a crude proximity sensor by placing two or more electrodes near each other.</p> <p></p> <p>This charge transfer duration is pretty small (and of course programmable), so it does not fill the sampling capacitor right away, the peripheral needs to perform many of these charge transfer cycles and count it. Counting is stopped when this count reaches a certain threshold, which the peripheral then throws a <code>max count error</code> interrupt, or the voltage on this charged <code>sample</code> capacitor is reached a voltage level (again, programmable) before the max count is reached, peripheral then throws an <code>end of acquisition</code> interrupt which than you can read and find out how many cycles it took to reach this voltage level. And this will directly be correlated to the capacitance of the electrode, which is directly correlated to the presence of a finger.</p> <p></p> <p>As I mentioned above touch sensing get really messy in noisy environments, so running these cycles and very fast at a fixed interval would not be very wise because the signal would pick up harmonics of the noise and you would get false positives and whatnot. Therefore the peripheral has a feature called <code>spread spectrum</code> which adds variation to charge transfer cycles.</p> <p>This is a very smart and robust way of detecting a touch. Above you can see the full cycle. I got this image and most of all information about this hardware from the reference manual <code>RM0503</code> of the STM32U0 series microcontrollers.</p>"},{"location":"zephyr-device-driver/#registers-and-configurations","title":"Registers and Configurations","text":"<p>After we understand the Surface Charge Transfer method we can start to see what can we configure. Functional diagrams is a good way to start.</p> <p></p> <p>We can see that we have two different sections which can be clocked at different speeds, one is for generating the charge pulses and other is for spread spectrum which generates a value that feeds into the pulse generator. Something we did not talked about yet is <code>SYNC</code> signal, which is an external signal which triggers pulse generator to start acquisition in addition to the software trigger the driver will use.</p> <p>Pulse generator commands the IO, setting their modes and function while the acquisition is running and it will store the group results in separate 14-bit values in <code>IOGXCR</code> (IO Group X Counter Register).</p>"},{"location":"zephyr-device-driver/#reset-and-clock-configuration","title":"Reset and Clock Configuration","text":"<p>This is a memory mapped peripheral like most all peripherals in STM32 microcontrollers. And often the first thing to do is to reset the peripheral (optional) and enable it. For STM32 MCU's the RCC (Reset and Clock Controller) peripheral is able to do this, so first peripheral to work with is the RCC.</p> <p>The TSC peripheral gets it's clock from the AHB clock, we expect this clock to be initialized by other drivers, what this driver has to do is to set some bits to perform reset and enable operations. Reference manual gives all the information we would need.</p> <p> RCC AHBRSTR (RCC AHB Reset Register Bits 24) </p> Bit 31:25 24 23:0 Name - TSCRST - Desc. - Touch sensing controller reset - Values - <code>0</code>: No effect<code>1</code>: Reset TSC - <p> RCC AHBENR (RCC AHB Enable Register Bits 24) </p> Bit 31:25 24 23:0 Name - TSCEN - Desc. - Touch sensing controller clock enable - Values - <code>0</code>: TSC clock disabled<code>1</code>: TSC clock enabled - <p>As you can see ST conveniently named the registers and put the relevant bits in the same position for both registers (24th bit). So this means whenever we write 1 to the 24th bit of the <code>RCC register base address + register_offset</code> (<code>0x28</code> for reset and <code>0x48</code> for enable) we can reset and enable the peripheral.</p>"},{"location":"zephyr-device-driver/#gpio-configuration","title":"GPIO Configuration","text":"<p>This is the second peripheral before we get to the TSC peripheral. The pins we will use for the TSC should be configured through the GPIO peripheral. Thankfully Zephyr provides a good subsystem and abstraction for this which we will see later.</p> <p>There is also some registers in the TSC peripheral that we need to configure. First of all we have to specify which channels are used for what, and which groups are enabled. We will use different registers for each of these settings.</p> <p>When no acquisition is ongoing, the state of the IO channels are in <code>default mode</code>. And TSC peripheral offers an option to set the default mode of the IO channels. This can be floating, push-pull-low. The register for this is <code>CR</code> (Control Register) and the bit position is 4;</p> <p> TSC CR (TSC Control Register Bit 4) </p> Bit 31:5 4 3:0 Name - IODEF - Desc. - IO default mode - Values - <code>0</code>: Push-pull-low<code>1</code>: Floating - <p>We use <code>IOCCR</code> (IO Channel Control Register) and <code>IOSCR</code> (IO Sampling Control Register) registers for electrodes and sampling capacitors respectively.</p> <p> TSC IOCCR (TSC IO Channel Control Register) </p> Bit 31:28 27:0 Name - Gx_IOy Desc. - IO channel y of group x Values - <code>0</code>: Disabled<code>1</code>: IO used as channel mode <p> TSC IOSCR (TSC IO Sampling Control Register) </p> Bit 31:28 27:0 Name - Gx_IOy Desc. - IO channel y of group x Values - <code>0</code>: Disabled<code>1</code>: IO sampling mode <p>And finally <code>IOGCSR</code> (IO Group Control Status Register) to enable the group.</p> <p> TSC IOGCSR (TSC IO Group Control Status Register) </p> Bit 31:7 6:0 Name - GxS Desc. - Analog I/O group x enable Values - <code>0</code>: Disabled<code>1</code>: Enabled"},{"location":"zephyr-device-driver/#tsc-clock-prescaler-configuration","title":"TSC Clock Prescaler Configuration","text":"<p>The clock enters the TSC IP from the AHB clock, this clock goes to many other peripherals so it is not a good idea to change the AHB clock rate for the TSC peripheral as the first and only thing. Instead we have a clock pre-scaler value to divide clock further before it enters the TSC. User manuals tells us the location of this register that controls this.</p> <p> TSC CR (TSC Control Register Bits 15 and 14:12) </p> Bit 15 14:12 Name SSPSC PGPSC[2:0] Desc. Spread spectrum prescaler Pulse generator prescaler Values <code>0</code>: <code>fHCLK</code><code>1</code>: <code>fHCLK /2</code> <code>000</code>: <code>fHCLK</code>...<code>111</code>: <code>fHCLK /128</code> <p>There are two clock settings</p> <ul> <li><code>PGPSC</code> (Pulse Generator Prescaler) and it is a 3-bit value, and each represents a different division factor.adjust the clock rate for the TSC peripheral.</li> <li><code>SSPSC</code> (Spread Spectrum Prescaler) and it is a 1-bit value. <code>0: AHB/1</code> and <code>1: AHB/2</code>.</li> </ul> <p>Defining the clock finally gives us the full cycle duration for one charge transfer cycle. In <code>U0</code> series this can be from 500ns to 2us.</p>"},{"location":"zephyr-device-driver/#tsc-pulse-generator-configuration","title":"TSC Pulse Generator Configuration","text":"<p>This section is the heart of the peripheral configuration and there are a few settings we can adjust;</p> <ul> <li>Charging duration</li> <li>Transfer Duration</li> <li>Max Cycle Count</li> </ul> <p> TSC CR (TSC Control Register Bits 31:28, 27:24 and 7:5) </p> Bit 31:28 27:24 7:5 Name CTPH[3:0] CTPL[3:0] MCV[2:0] Desc. Charge transfer pulse high Charge transfer pulse low Max count value Values <code>0000</code>: 1x tPGCLK<code>...</code><code>1111</code>: 16x tPGCLK <code>0000</code>: 1x tPGCLK<code>...</code><code>1111</code>: 16x tPGCLK <code>000</code>: 255<code>001</code>: 511<code>...</code><code>110</code>: 16383 <p>Charging and transfer durations are denoted as <code>CTPH</code> (Charge Transfer Pulse High) and <code>CTPL</code> (Charge Transfer Pulse Low) respectively. These are 4-bit values and can be adjusted from 1 to 16 clock cycles. These values are used to charge the external capacitor and transfer the charge to the sample capacitor.</p> <p>Max cycle count is a 3-bit value and each represents a different count value. This is a safety feature where TSC can not fill the capacitor enough to reach the voltage threshold, so it stops the cycle and throws an interrupt.</p>"},{"location":"zephyr-device-driver/#tsc-spread-spectrum-configuration","title":"TSC Spread Spectrum Configuration","text":"<p> TSC CR (TSC Control Register Bits 23:17 and 16) </p> Bit 23:17 16 Name SSD[6:0] SSE Desc. Spread spectrum deviation Spread spectrum enable Values <code>0000000</code>: 1x tSSCLK<code>...</code><code>1111111</code>: 128x tSSCLK <code>0</code>: Disabled<code>1</code>: Enabled <p>Spread spectrum has 9-bits for configuration in the <code>CR</code> register. The pre-scaler bit is already set, so rest if a 1-bit enable and 7-bit deviation value.The deviation value represents the maximum deviation of the charge transfer pulse in spread spectrum clock cycles.</p>"},{"location":"zephyr-device-driver/#tsc-sync-configuration","title":"TSC SYNC Configuration","text":"<p>There are only two bits related to this setting, one is for selecting the polarity and the other is for enabling the SYNC signal.</p> <p> TSC CR (TSC Control Register Bits 4 and 3) </p> Bit 3 2 Name SYNCPOL SYNC Enable Desc. Synchronization pin polarity Synchronization enable Values <code>0</code>: Falling edge only<code>1</code>: Rising edge and high level <code>0</code>: Disabled<code>1</code>: Enabled"},{"location":"zephyr-device-driver/#tsc-interrupts","title":"TSC Interrupts","text":"<p>There are only 2 interrupts, <code>EOAF</code> (End of Acquisition Flag) and <code>MCEF</code> (Max Count Error Flag). These are set when the voltage threshold is reached or the max cycle count is reached respectively. They are enabled through a different register called <code>IER</code> (Interrupt Enable Register).</p> <p> TSC IER (TSC Interrupt Enable Register Bits 1 and 0) </p> Bit 31:2 1 0 Name - MCEIE EOAIE Desc. - Max count error interrupt enable End of acquisition interrupt enable Values - <code>0</code>: Disabled<code>1</code>: Enabled <code>0</code>: Disabled<code>1</code>: Enabled <p>Note</p> <p>There is also a setting to adjust the voltage threshold for the end of acquisition, but this is done using a different comparator peripheral, for the sake of simplicity we will not use this feature.</p>"},{"location":"zephyr-device-driver/#how-to-read-the-count-value","title":"How to Read the Count Value","text":"<p>Before we start reading the <code>START</code> bit in the <code>CR</code> register should be set to start the acquisition. After the acquisition is done, the peripheral will throw an interrupt or we can poll the <code>EOAF</code> bit in the <code>ISR</code> register to check if the acquisition is done. Then we can read the status of each group with <code>IOGSR</code> and see if that group has finished the acquisition. If it has we can read the count value from the <code>IOGXCR</code> register.</p> <p> TSC CR (TSC Control Register Bits 0) </p> Bit 31:1 0 Name - START Desc. - Start acquisition Values - <code>0</code>: No effect<code>1</code>: Start acquisition <p> TSC ISR (TSC Interrupt Status Register Bits 1 and 0) </p> Bit 31:2 1 0 Name - MCEF EOAF Desc. - Max count error flag End of acquisition flag Values - <code>0</code>: No error<code>1</code>: Error <code>0</code>: No end of acquisition<code>1</code>: End of acquisition <p> TSC IOGCSR (TSC IO Group Control Status Register) </p> 31:23 22:16 15:0 Name - GxS - Desc. - Analog I/O group x status - Values - <code>0</code>: Ongoing<code>1</code>: Complete - <p> TSC IOGXCR (TSC IO Group X Counter Register) </p> Bit 31:14 13:0 Name - CT[13:0] Desc. - Counter value <p>There are some other minor settings which I will not go into detail because it does not concern the driver implementation. But here is the complete map of the TSC peripheral registers.</p> <p> STM32U0 TSC Peripheral Registers </p> <p></p>"},{"location":"zephyr-device-driver/#hardware-configuration","title":"Hardware Configuration","text":"<p>The development kit schematic shows the implementation is for one electrode (<code>TKEY</code>) and one sampling capacitor (<code>TKEY_CS</code>), so we will stick with that.</p> <p>Notice how they actually used an extra group for another electrode and called it <code>shield</code> and connected to the end of the electrode to the ground. This is a trick often used to further reduce EMI and noise. Only difference this has over an electrode is this is not selected for acqusition. This is not related to the driver implementation so I will not go into detail.</p> <p>The pins and their alternate functions are as follows:</p> GPIO Pin GPIO Alternate Function TSC Group TSC IO Number Function PD10 AF9 6 1 TKey CS PD11 AF9 6 2 TKey PB12 AF9 1 1 Shield Electrode PB13 AF9 1 2 Shield Electrode Sampling Capacitor <p>I talk more about this in the next section, but this is the hardware we will work with.</p>"},{"location":"zephyr-device-driver/#device-tree-nodes-and-bindings","title":"Device Tree Nodes and Bindings","text":"<p>One of the first things to do is to create a device tree binding to describe our hardware before the implementation starts. The concept of device trees are not new and is used in Linux for many years, so it may be familiar to some of you, but for those who are unfamiliar, it is a JSON-like file that describes a hardware node in a system called <code>device-tree</code>, this allows for decoupling the hardware from the source code so that software may run independent of the hardware it is running on, meaning the API won't change if you change the hardware.</p> <p>To know more about device trees check out the official documentation.</p> <p>To sketch a design lets thinker about a node for the hardware above. This is an attempt to create a definition that will contain all hardware related information in a single node for this peripheral.</p> <pre><code>tsc : tsc@40024000 {\n  compatible = \"st,stm32-tsc\";\n  reg = &lt;0x40024000 0x400&gt;;\n  clocks = &lt;&amp;rcc STM32_CLOCK_BUS_AHB1 0x01000000&gt;;\n  resets = &lt;&amp;rctl STM32_RESET(AHB1, 24U)&gt;;\n  interrupts = &lt;21 0&gt;;\n};\n</code></pre> <p>This simple node seems pretty self-explanatory, it has the most generic properties common to almost all ST -or ARM really- compatible peripherals, a register space, clock, reset and interrupt. The node describes a TSC node with the label <code>tsc</code> and at the address <code>0x40024000</code> which corresponds to the beginning of address space of the TSC module in <code>STM32U0x</code> series microcontrollers, this is the most fundamental information we should have about a memory-mapped io. We can see this information is encoded twice (both in definition with <code>@</code> symbol and with <code>reg</code> property). We can also see the entire memory mapped region is 1KB (<code>0x400</code>), it's clock is connected to the <code>AHB1</code> (24th bit <code>0x01000000</code> of the AHB control register), also it has a reset line again at the bit position 24 in the corresponding reset controller control register (created with <code>STM32_RESET</code> macro). In the vector table the position offset of its interrupt is <code>21</code> and has <code>0</code> priority. Another very important property is the <code>compatible</code> property, this is a string that describes the driver that will handle this node, in other words, this node information will be passed to a driver that declares itself as <code>st,stm32-tsc</code> compatible. Very neat!</p> <p>A <code>node binding</code> is any property of a node, described in a file, a <code>yaml</code> file in our case, so to make our <code>st,stm32-tsc</code> node work we need to create a binding file for it, so that we can enforce out properties and rules about those properties. And there are strict rules to follow about the location of these files and the naming conventions. The binding files must be in the <code>dts/bindings</code> directory of workspace or application root, board directories or in modules. We will create our own in the workspace root.</p> <p>The naming convention for the binding files are usually <code>vendor,driver.yaml</code> (<code>vendor</code> is optional for generic drivers) and usually they reside in subfolders for better organization. So we will create ours in <code>misc</code> folder and put the binding there.</p> <p>And create the <code>st,stm32-tsc.yaml</code> file with the following content:</p> <pre><code># zephyr/dts/bindings/misc/st,stm32-tsc.yaml\n\ndescription: STM32 Tocuh Sensing Controller (TSC) driver\n\ncompatible: \"st,stm32-tsc\"\n\ninclude: [base.yaml, reset-device.yaml]\n\nproperties:\n  reg:\n    required: true\n  clocks:\n    required: true\n  resets:\n    required: true\n  interrupts:\n    required: true\n</code></pre> <p>as you can tell from the file, all the properties are included from other files Zephyr provides for us, this file only makes some of them required. Their definition can be seen in one of these included files; <code>base.yaml</code></p> <pre><code># zephyr/dts/bindings/base/base.yaml\nproperties:\n  compatible:\n    type: string-array\n    required: true\n    description: compatible strings\n\n  reg:\n    type: array\n    description: register space\n\n  interrupts:\n    type: array\n    description: interrupts for device\n\n  ...\n</code></pre> <p>This binding file will make sure we have the properties we need, and they are parsed correctly for the relevant hardware node with the matching <code>compatible</code> property.</p> <p>Again these documents are quite verbose and easy to read and maintain, so that's good. They can also get pretty messy if you don't do it right, so please follow the official documentation for more information.</p> <p>Of course up to this point we only included and set up bindings for the information to enable the peripheral (<code>reg</code>, <code>clocks</code>, <code>resets</code> and <code>interrupts</code>), but we also have to configure it, which requires additional bindings. We went into detail in the section Understanding the Hardware so I will not go into detail here, but basically we will need the following information to set up a TSC peripheral:</p> <ul> <li>IO pins for the electrodes and sampling capacitors</li> <li>Pulse generator prescaler value</li> <li>Spread spectrum prescaler, deviation and enable</li> <li>Charge transfer pulse high and low values</li> <li>Max count value</li> <li>SYNC signal polarity and enable</li> </ul>"},{"location":"zephyr-device-driver/#pin-control","title":"Pin Control","text":"<p>We discussed how configuring the physical pins is a job of another peripheral, <code>pintcrl-device.yaml</code> provides some bindings to allow generic nodes to provide pin configuration information. It is called <code>pinctrl-X</code> where <code>X</code> is the number of the pin group. Take a look at the property;</p> <pre><code># zephyr/dts/bindings/pinctrl-device.yaml\npinctrl-0:\n    type: phandles\n    description: |\n      Pin configuration/s for the first state. Content is specific to the\n      selected pin controller driver implementation.\n\n...\n\npinctrl-x:\n    type: phandles\n    description: |\n      Pin configuration/s for the x-th state. Content is specific to the\n      selected pin controller driver implementation.\npinctrl-names:\n    type: string-array\n    description: |\n      Names for the provided states. The number of names needs to match the\n      number of states.\n</code></pre> <p>A pin configuration can change based on whether the device is running or in sleep mode to preserve power. So we can have multiple states for the pin configuration, separated by the <code>pinctrl-names</code> property. It usually is <code>default</code> and <code>sleep</code> but can be anything. The <code>phandles</code> property is just a reference to another node, so we can point to other nodes which will include the pin information, defined somewhere else.</p> <p>To have this binding required in our <code>st,stm32-tsc.yaml</code> file we just need to add the following lines:</p> <pre><code>properties:\n  ...\n  pinctrl-0:\n    required: true\n  pinctrl-names:\n    required: true\n</code></pre> <p>The use of this binding in the driver implementation will be discussed in the next sections. But the following snippet can give you a glimpse of how it can be used in a device tree node.;</p> <pre><code>&amp;node {\n  pinctrl-0 = &lt;&amp;pin_d12_af9&gt;;\n  pinctrl-names = \"default\";\n};\n\n&amp;pinctrl {\n  pin_d12_af9: pinconfig1 {\n    pinmux = &lt;STM32_PINMUX('D', 12, AF9)&gt;;\n    drive-open-drain;\n  };\n};\n</code></pre> <p>The <code>&amp;</code> symbol works very similar to a pointer in C, in this example we are referencing already existing nodes (through labels; <code>node-label: node-name</code>) and altering them (<code>node</code> and <code>pinctrl</code>) in the device tree. <code>STM32_PINMUX</code> is just a C macro and literally coming from an included header file. We can supply the pin, its function and additional properties like <code>push-pull</code> or <code>open-drain</code>. And passing the definition of these <code>pinctrl</code> nodes to the <code>node</code> node will make sure the pins are configured correctly when the driver is loaded.</p> <p>So based on this let's define the pins and their functions for this development kit. Schematic tells us there is two pins used in this board, one is a shield electrode and the other is the touch electrode itself, of course each with their own sampling capacitor pins. 4 in total. These pins are also belong to a group, ST choose group 1 and group 6 for these pins and they nicely provide a table for the pins in the UM3292 user manual. I also talked about them in the Hardware Configuration section.</p> <p>Also In the reference manual we can get the information about which alternate function is used for the TSC group configuration for that specific pin, conveniently all of them are <code>AF9</code> for these pins. So we can define them in the device tree as follows;</p> <pre><code>&amp;pinctrl {\n  tsc_shield_pb12: tsc_shield_pb12 {\n    pinmux = &lt;STM32_PINMUX('D', 12, AF9)&gt;;\n    drive-open-drain;\n  };\n  tsc_shield_cs_pb13: tsc_shield_cs_pb13 {\n    pinmux = &lt;STM32_PINMUX('D', 13, AF9)&gt;;\n  };\n  tsc_g6_io1_pd10: tsc_g6_io1_pd10 {\n    pinmux = &lt;STM32_PINMUX('D', 10, AF9)&gt;; // TKey CS pin\n    drive-open-drain;\n  };\n  tsc_g6_io2_pd11: tsc_g6_io2_pd11 {\n    pinmux = &lt;STM32_PINMUX('D', 11, AF9)&gt;; // TKey Pin\n  };\n};\n</code></pre> <p>And later we will provide these pins to the TSC node in the device tree;</p> <pre><code>&amp;tsc {\n  pinctrl-0 = &lt;&amp;tsc_shield_pb12 &amp;tsc_shield_cs_pb13 &amp;tsc_g6_io1_pd10 &amp;tsc_g6_io2_pd11&gt;;\n  pinctrl-names = \"default\";\n};\n</code></pre> <p>and use this information to set up the GPIO pins in the driver implementation.</p> <p>It is important to define these pins inside the <code>pinctrl</code> parent node so we can use the bindings like <code>drive-open-drain</code> and <code>pinmux</code> in the child nodes. This node is provided by your vendor in the <code>soc</code> device tree file, this file and many other will be included in the final device tree file, so many overlays can be used to configure the hardware, SOC DTS files &gt; Board DTS files &gt; Application DTS files &gt; Final DTS file.</p>"},{"location":"zephyr-device-driver/#other-bindings","title":"Other Bindings","text":"<p>Now we only deal with bindings with basic types, like <code>int</code>, <code>enum</code>, <code>string</code> and <code>boolean</code>.</p>"},{"location":"zephyr-device-driver/#pulse-generator-prescaler","title":"Pulse Generator Prescaler","text":"<p>The pulse generator prescaler is a 3-bit value as discussed in the Registers and Configurations section, so it can be defined as an enum in the binding file.</p> <pre><code>pulse-generator-prescaler:\n    type: int\n    default: 2\n    description: |\n      Prescaler for the pulse generator clock (t_pgclk=f_hclk/prescaler).\n      The prescaler is used to generate the charge transfer pulse.\n      0: f_hclk/1\n      1: f_hclk/2\n      2: f_hclk/4\n      3: f_hclk/8\n      4: f_hclk/16\n      5: f_hclk/32\n      6: f_hclk/64\n      7: f_hclk/128\n    enum: [0, 1, 2, 3, 4, 5, 6, 7]\n</code></pre>"},{"location":"zephyr-device-driver/#charge-transfer-pulse-high-and-low","title":"Charge Transfer Pulse High and Low","text":"<p>These are 4-bit values, this too can be defined as integer enum.</p> <pre><code>  ctph:\n    type: int\n    default: 2\n    description: |\n      Number of cycles for the high state of the \n      charge transfer pulse (1 to 16 cycles of t_pgclk).\n    enum: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n\n  ctpl:\n    type: int\n    default: 2\n    description: |\n      Number of cycles for the low state of the \n      charge transfer pulse (1 to 16 cycles of t_pgclk).\n    enum: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n</code></pre>"},{"location":"zephyr-device-driver/#max-count-value","title":"Max Count Value","text":"<p>This is a 3-bit value, we can define it as an integer enum.</p> <pre><code>max-count-value:\n    type: int\n    default: 5\n    description: |\n      Max number of charge transfer pulses before max count error is generated.\n      0: 255\n      1: 511\n      2: 1023\n      3: 2047\n      4: 4095\n      5: 8191\n      6: 16383\n      7: 32767\n    enum: [0, 1, 2, 3, 4, 5, 6, 7]\n</code></pre>"},{"location":"zephyr-device-driver/#spread-spectrum","title":"Spread Spectrum","text":"<p>The spread spectrum prescaler is a 1-bit value, it should be easy to define.</p> <pre><code>spread-spectrum-prescaler:\n    type: int\n    description: Spread spectrum clock prescaler (t_ssclk)\n    enum:\n      - 1\n      - 2\n</code></pre> <p>and to enable it we can define a boolean property.</p> <pre><code>  spread-spectrum:\n    type: boolean\n    description: Spread spectrum enable\n</code></pre> <p>These boolean properties are easy to use;</p> <pre><code>&amp;tsc {\n  spread-spectrum;\n  spread-spectrum-prescaler = &lt;2&gt;;\n};\n</code></pre> <p>We also need to define the deviation value for the spread spectrum, it can have a value from 0 to 127. But for convenience we will start from 1 and offset it in the driver implementation.</p> <pre><code>spread-spectrum-deviation:\n    type: int\n    default: 1\n    description: Spread spectrum deviation (1 to 128 cycles of t_ssclk)\n</code></pre>"},{"location":"zephyr-device-driver/#sync-signal","title":"SYNC Signal","text":"<p>We have two properties for the SYNC signal, one is for the polarity and the other is for the enable.</p> <pre><code>synced-acquisition:\n    type: boolean\n    description: |\n      Synchronized acquisition enable. Acquisition starts when START bit and signal on sync pin.\n      You have to provide a pinctrl for the sync pin.\n\n  syncpol-rising:\n    type: boolean\n    description: Rising synchronization pin polarity, instead of falling\n</code></pre> <p>I choose to use a boolean property for the polarity it could also be a string enum, but I think this is more readable.</p>"},{"location":"zephyr-device-driver/#io-default-mode","title":"IO Default Mode","text":"<p>IO mode is 1-bit value, it can be either floating or driven low (default).</p> <pre><code>  iodef-float:\n    type: boolean\n    description: |\n      I/Os are floating when not used for acquisition.\n      If not set, I/Os are driven low.\n</code></pre>"},{"location":"zephyr-device-driver/#child-nodes-and-bindings","title":"Child Nodes and Bindings","text":"<p>We talked about the group logic in the Understanding the Hardware section. Once we enable the TSC peripheral, we should also enable groups and channels within those groups for acquisition. Device tree offers a way to describe these as child nodes of the TSC node. Lets say we can define a group node as follows;</p> <pre><code>&amp;tsc {\n  group1 {\n    group = &lt;1&gt;;\n    use-as-shield;****\n    channel-ios = &lt;2&gt;;\n    sampling-io = &lt;1&gt;;\n  };\n\n  group6 {\n    group = &lt;6&gt;;\n    channel-ios = &lt;2&gt;;\n    sampling-io = &lt;1&gt;;\n  };\n};\n</code></pre> <p>So this nodes inside the <code>tsc</code> node are called child nodes, and in our case they give us information about the group index, channel and sampling io pin bits and one more property to use the group as shield (basically configure the group but do not acquire a value from it). We can define these nodes in the binding file as follows;</p> <pre><code># zephyr/dts/bindings/misc/st,stm32-tsc.yaml\nproperties:\n  ...\n\nchild-binding:\n  description: STM32 TSC group configuration\n  properties:\n    group:\n      type: int\n      required: true\n      description: Group number (0 to 7)\n      enum: [0, 1, 2, 3, 4, 5, 6, 7]\n\n    channel-ios:\n      type: int\n      description: Channel I/Os to be enabled\n      enum: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n\n    sampling-io:\n      type: int\n      required: true\n      description: Channel to be selected for sampling\n      enum: [1, 2, 4, 8]\n\n    use-as-shield:\n      type: boolean\n      description: |\n        Use channel as shield. This configures group but \n        does not enable it for acqusition. channel-io is used \n        as shield pin and can only have values 1, 2, 4 or 8.\n</code></pre> <p>This information unfortunately can not be extracted from the pin information, so child nodes like these are required to configure and acquire data from the TSC peripheral.</p>"},{"location":"zephyr-device-driver/#final-binding-file-and-device-tree-nodes","title":"Final Binding File and Device Tree Nodes","text":"<p>For the device tree, we will have two definitions in two different files. The first definition is the core information about the peripheral, and is the same for all <code>U0</code> series microcontrollers. Therefore it has to be inside the main <code>stm32u0.dtsi</code> file which all stm32u0 based boards include (device tree files can be nested and included in each other).</p> <p>This file already exists in upstream Zephyr, under <code>dts/arm/st/u0/stm32u0.dtsi</code>, we just need to modify it.</p> <pre><code># zephyr/dts/arm/st/u0/stm32u0.dtsi\n\nsoc {\n  tsc: tsc@40024000 {\n    compatible = \"st,stm32-tsc\";\n    reg = &lt;0x40024000 0x400&gt;;\n    clocks = &lt;&amp;rcc STM32_CLOCK_BUS_AHB1 0x01000000&gt;;\n    resets = &lt;&amp;rctl STM32_RESET(AHB1, 24U)&gt;;\n    interrupts = &lt;21 0&gt;;\n    interrupt-names = \"global\";\n    status = \"disabled\";\n    };\n};\n</code></pre> <p>We define the node and let it be disabled by default so our driver wont be compiled into the application until <code>status</code> is set to <code>okay</code>.</p> <p>The second definition is in the development kit specific file, <code>stm32u083c-dk.dts</code> in our case, this file again is defined in the upstream Zephyr, under <code>boards/st/stm32u083c_dk/stm32u083c_dk.dts</code>. This file will contain the information about the pins and the groups we will use in the TSC peripheral along with the pin configuration.</p> <p>Note</p> <p>You can also define these in the device tree overlay file in your application, and avoid modifying files inside Zephyr source, but since we already have a demo board definition we will use that.</p> <p>  If you want to use an overlay it would look something like this;  <pre><code>include \"...\";\n&amp;soc {\n  tsc: tsc@40024000 {\n    status = \"okay\";\n    clocks = &lt;&amp;rcc STM32_CLOCK_BUS_AHB1 0x01000000&gt;;\n    resets = &lt;&amp;rctl STM32_RESET(AHB1, 24U)&gt;;\n    interrupts = &lt;21 0&gt;;\n    pinctrl-0 = &lt;&amp;tsc_shield_pb12 &amp;tsc_shield_cs_pb13 &amp;tsc_g6_io1_pd10 &amp;tsc_g6_io2_pd11&gt;;\n    pinctrl-names = \"default\";\n    spread-spectrum;\n    spread-spectrum-prescaler = &lt;2&gt;;\n    spread-spectrum-deviation = &lt;100&gt;;\n    g1 {\n      group = &lt;1&gt;;\n      use-as-shield;\n      channel-ios = &lt;2&gt;;\n      sampling-io = &lt;1&gt;;\n    };\n    g6 {\n      group = &lt;6&gt;;\n      channel-ios = &lt;2&gt;;\n      sampling-io = &lt;1&gt;;\n    };\n  };\n};\n\n&amp;pinctrl {\n   tsc_shield_pb12: tsc_shield_pb12 {\n    pinmux = &lt;STM32_PINMUX('D', 12, AF9)&gt;;\n    drive-open-drain;\n  };\n   tsc_shield_cs_pb13: tsc_shield_cs_pb13 {\n    pinmux = &lt;STM32_PINMUX('D', 13, AF9)&gt;;\n  };\n   tsc_g6_io1_pd10: tsc_g6_io1_pd10 {\n    pinmux = &lt;STM32_PINMUX('D', 10, AF9)&gt;; // TKey CS pin\n    drive-open-drain;\n  };\n   tsc_g6_io2_pd11: tsc_g6_io2_pd11 {\n    pinmux = &lt;STM32_PINMUX('D', 11, AF9)&gt;; // TKey Pin\n  };\n};\n</code></pre> <pre><code># zephyr/boards/st/stm32u083c_dk/stm32u083c_dk.dts\n\n#include &lt;zephyr/dt-bindings/misc/stm32-tsc-defines.h&gt; \n\n&amp;tsc {\n  status = \"disabled\";\n  pinctrl-0 = &lt;&amp;tsc_shield_pb12 &amp;tsc_shield_cs_pb13 &amp;tsc_g6_io1_pd10 &amp;tsc_g6_io2_pd11&gt;;\n  pinctrl-names = \"default\";\n  spread-spectrum;\n  spread-spectrum-prescaler = &lt;2&gt;;\n  spread-spectrum-deviation = &lt;100&gt;;\n\n  g1 {\n    group = &lt;1&gt;;\n    use-as-shield;\n    channel-ios = &lt;2&gt;;\n    sampling-io = &lt;1&gt;;\n  };\n\n  g6 {\n    group = &lt;6&gt;;\n    channel-ios = &lt;2&gt;;\n    sampling-io = &lt;1&gt;;\n  };\n};\n\n&amp;pinctrl {\n   tsc_shield_pb12: tsc_shield_pb12 {\n    pinmux = &lt;STM32_PINMUX('D', 12, AF9)&gt;;\n    drive-open-drain;\n  };\n   tsc_shield_cs_pb13: tsc_shield_cs_pb13 {\n    pinmux = &lt;STM32_PINMUX('D', 13, AF9)&gt;;\n  };\n   tsc_g6_io1_pd10: tsc_g6_io1_pd10 {\n    pinmux = &lt;STM32_PINMUX('D', 10, AF9)&gt;; // TKey CS pin\n    drive-open-drain;\n  };\n   tsc_g6_io2_pd11: tsc_g6_io2_pd11 {\n    pinmux = &lt;STM32_PINMUX('D', 11, AF9)&gt;; // TKey Pin\n  };\n};\n</code></pre> <p>The peripheral and the groups are defined as child nodes of the TSC node. Pins are supplied and spread spectrum feature is enabled and configured. The <code>status</code> property is set to <code>disabled</code> by default, users will be able to enable this in application overlay file.</p> <p>Notice how this information could only be given in the development kit specific file instead of the soc definition, because the pins are different in every board. And other bindings are also application specific.</p> <p>When device tree compiler compiles all the device tree files into one final device tree, we get the following node;</p> <pre><code>/ {\n  soc {\n    pinctrl {\n      ...\n      tsc_shield_pb12: tsc_shield_pb12 {\n        pinmux = &lt; 0x789 &gt;;\n        drive-open-drain;\n        phandle = &lt; 0x10 &gt;;\n      };\n      tsc_shield_cs_pb13: tsc_shield_cs_pb13 {\n        pinmux = &lt; 0x7a9 &gt;;\n        phandle = &lt; 0x11 &gt;;\n      };\n      tsc_g6_io1_pd10: tsc_g6_io1_pd10 {\n        pinmux = &lt; 0x749 &gt;;\n        drive-open-drain;\n        phandle = &lt; 0x12 &gt;;\n      };\n      tsc_g6_io2_pd11: tsc_g6_io2_pd11 {\n        pinmux = &lt; 0x769 &gt;;\n        phandle = &lt; 0x13 &gt;;\n      };\n    };\n    tsc: tsc@40024000 {\n      compatible = \"st,stm32-tsc\";\n      reg = &lt; 0x40024000 0x400 &gt;;\n      clocks = &lt; &amp;rcc 0x48 0x1000000 &gt;;\n      resets = &lt; &amp;rctl 0x518 &gt;;\n      interrupts = &lt; 0x15 0x0 &gt;;\n      status = \"disabled\";\n      pinctrl-0 = &lt; &amp;tsc_shield_pb12 &amp;tsc_shield_cs_pb13 &amp;tsc_g6_io1_pd10 &amp;tsc_g6_io2_pd11 &gt;;\n      pinctrl-names = \"default\";\n      spread-spectrum;\n      spread-spectrum-prescaler = &lt; 0x2 &gt;;\n      spread-spectrum-deviation = &lt; 0x64 &gt;;\n      g1 {\n        group = &lt; 0x1 &gt;;\n        use-as-shield;\n        channel-ios = &lt; 0x2 &gt;;\n        sampling-io = &lt; 0x1 &gt;;\n      };\n      g6 {\n        group = &lt; 0x6 &gt;;\n        channel-ios = &lt; 0x2 &gt;;\n        sampling-io = &lt; 0x1 &gt;;\n      };\n    };\n  }\n}\n</code></pre> <p>All files included and all macros expanded, this is the final device tree node that will be converted to a header file (instead of a binary blob used in Linux) containing all this information as C defines, so they will take up no space if not used. This generated header file can not be used directly as it is pretty verbose and hard to read;</p> <pre><code>// devicetree_generated.h\n\n...\n\n/*\n * Devicetree node: /soc/tsc@40024000\n *\n * Node identifier: DT_N_S_soc_S_tsc_40024000\n *\n * Binding (compatible = st,stm32-tsc):\n *   /workdir/zephyr/dts/bindings/misc/st,stm32-tsc.yaml\n *\n * (Descriptions have moved to the Devicetree Bindings Index\n * in the documentation.)\n */\n\n/* Node's full path: */\n#define DT_N_S_soc_S_tsc_40024000_PATH \"/soc/tsc@40024000\"\n\n/* Node's name with unit-address: */\n#define DT_N_S_soc_S_tsc_40024000_FULL_NAME \"tsc@40024000\"\n\n/* Node parent (/soc) identifier: */\n#define DT_N_S_soc_S_tsc_40024000_PARENT DT_N_S_soc\n\n/* Macros for properties that are special in the specification: */\n#define DT_N_S_soc_S_tsc_40024000_REG_NUM 1\n#define DT_N_S_soc_S_tsc_40024000_REG_IDX_0_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_REG_IDX_0_VAL_ADDRESS 1073889280 /* 0x40024000 */\n#define DT_N_S_soc_S_tsc_40024000_REG_IDX_0_VAL_SIZE 1024 /* 0x400 */\n#define DT_N_S_soc_S_tsc_40024000_RANGES_NUM 0\n#define DT_N_S_soc_S_tsc_40024000_FOREACH_RANGE(fn) \n#define DT_N_S_soc_S_tsc_40024000_IRQ_NUM 1\n#define DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_irq 21\n#define DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_irq_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_priority 0\n#define DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_priority_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_CONTROLLER DT_N_S_soc_S_interrupt_controller_e000e100\n#define DT_N_S_soc_S_tsc_40024000_IRQ_LEVEL 1\n#define DT_N_S_soc_S_tsc_40024000_IRQ_NAME_global_VAL_irq DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_irq\n#define DT_N_S_soc_S_tsc_40024000_IRQ_NAME_global_VAL_irq_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_IRQ_NAME_global_VAL_priority DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_VAL_priority\n#define DT_N_S_soc_S_tsc_40024000_IRQ_NAME_global_VAL_priority_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_IRQ_NAME_global_CONTROLLER DT_N_S_soc_S_tsc_40024000_IRQ_IDX_0_CONTROLLER\n#define DT_N_S_soc_S_tsc_40024000_COMPAT_MATCHES_st_stm32_tsc 1\n#define DT_N_S_soc_S_tsc_40024000_COMPAT_VENDOR_IDX_0_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_COMPAT_VENDOR_IDX_0 \"STMicroelectronics\"\n#define DT_N_S_soc_S_tsc_40024000_COMPAT_MODEL_IDX_0_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_COMPAT_MODEL_IDX_0 \"stm32-tsc\"\n#define DT_N_S_soc_S_tsc_40024000_STATUS_okay 1\n#define DT_N_S_soc_S_tsc_40024000_P_resets_LEN 1\n#define DT_N_S_soc_S_tsc_40024000_P_resets_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_pulse_generator_prescaler 2\n#define DT_N_S_soc_S_tsc_40024000_P_pulse_generator_prescaler_ENUM_IDX 2\n#define DT_N_S_soc_S_tsc_40024000_P_pulse_generator_prescaler_ENUM_VAL_2_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_pulse_generator_prescaler_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_ctph 2\n#define DT_N_S_soc_S_tsc_40024000_P_ctph_ENUM_IDX 1\n#define DT_N_S_soc_S_tsc_40024000_P_ctph_ENUM_VAL_2_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_ctph_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_ctpl 2\n#define DT_N_S_soc_S_tsc_40024000_P_ctpl_ENUM_IDX 1\n#define DT_N_S_soc_S_tsc_40024000_P_ctpl_ENUM_VAL_2_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_ctpl_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_spread_spectrum 0\n#define DT_N_S_soc_S_tsc_40024000_P_spread_spectrum_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_spread_spectrum_deviation 1\n#define DT_N_S_soc_S_tsc_40024000_P_spread_spectrum_deviation_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_max_count_value 5\n#define DT_N_S_soc_S_tsc_40024000_P_max_count_value_ENUM_IDX 5\n#define DT_N_S_soc_S_tsc_40024000_P_max_count_value_ENUM_VAL_5_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_max_count_value_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_iodef_float 0\n#define DT_N_S_soc_S_tsc_40024000_P_iodef_float_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_synced_acquisition 0\n#define DT_N_S_soc_S_tsc_40024000_P_synced_acquisition_EXISTS 1\n#define DT_N_S_soc_S_tsc_40024000_P_syncpol_rising 0\n#define DT_N_S_soc_S_tsc_40024000_P_syncpol_rising_EXISTS 1\n\n...\n</code></pre> <p>The values are not meant to be accessed directly by us, instead a macro library is used to get the values programmatically. In my opinion this part needs a rework because it is very hard to trace macros when something is not right and you want to debug, but I think Zephyr is already working on a revised solution.</p> <p>An example of how to access these values can be seen below;</p> <pre><code>#include &lt;zephyr/devicetree.h&gt;\n\nDT_PROP(DT_NODELABEL(tsc), pulse_generator_prescaler); // 2\n</code></pre>"},{"location":"zephyr-device-driver/#plumbing-device-tree-to-driver-code","title":"Plumbing Device Tree to Driver Code","text":"<p>We have a binding file that defines the information the driver would need to work with a general STM32 TSC peripheral, and we have a device tree node that describes a specific instance of this peripheral. Now we need to write a driver that will use this information to configure and use the peripheral. From now on the idea is that this hardware node can be inside any ARM Cortex-M based STM32 microcontroller, and we will be able to use the same driver for all of them. Also our code wont only run on a specific hardware node, but instead may work on any hardware node that has the same properties (same <code>compatible</code> property in the device tree), so multiple TSC hardware can be used in the same application even though ST has no MCU with such feature, it's best practice to write drivers this way in case ST releases a new MCU with multiple TSC peripherals.</p> <p>We therefore need to store all these information in a struct inside our MCU, preferably in flash memory so it won't take up any RAM.</p>"},{"location":"zephyr-device-driver/#device-tree-macros","title":"Device Tree Macros","text":"<p>Zephyr provides us with a set of macros to access the device tree properties in the generated header file. These are usually harder to debug when something goes wrong but it makes everything compile-time. To use it we need to include the API from <code>zephyr/include/zephyr/devicetree.h</code>.;</p> <pre><code>#include &lt;zephyr/devicetree.h&gt;\n</code></pre>"},{"location":"zephyr-device-driver/#register-base-address","title":"Register Base Address","text":"<p>The memory address is the first thing we care about. it will be a 32-bit pointer to the base address of the TSC peripheral and can be casted to a pointer to a struct that represents the TSC peripheral memory layout.</p> <pre><code>#define TSC_BASE(node) ((TSC_TypeDef *)DT_INST_REG_ADDR(node))\n</code></pre> <p>So <code>TSC_BASE</code> macro takes a node and calls Zephyr macro <code>DT_INST_REG_ADDR</code> to get the <code>reg</code> property of the node, which is the base address of the peripheral. This is a pointer to the memory mapped registers of the peripheral, we than cast it to a pointer to a struct that represents the TSC peripheral memory layout and we have the peripheral ready to use.</p> <p>Note</p> <p>Since we are using a multi-instance compatible driver, we use instances, therefore we use the macro <code>DT_INST_REG_ADDR</code> instead of <code>DT_REG_ADDR</code> which is used for single instance drivers. when using <code>_INST</code> macros we need to provide <code>DT_DRV_COMPAT</code> in the beggining of the driver source file later when we create the driver.</p> <p><code>TSC_TypeDef</code> is provided by ST and is defined as a simple struct;</p> <pre><code>typedef struct\n{\n  volatile uint32_t CR;            /*!&lt; TSC control register,                                     Address offset: 0x00 */\n  volatile uint32_t IER;           /*!&lt; TSC interrupt enable register,                            Address offset: 0x04 */\n  volatile uint32_t ICR;           /*!&lt; TSC interrupt clear register,                             Address offset: 0x08 */\n  volatile uint32_t ISR;           /*!&lt; TSC interrupt status register,                            Address offset: 0x0C */\n  volatile uint32_t IOHCR;         /*!&lt; TSC I/O hysteresis control register,                      Address offset: 0x10 */\n  uint32_t      RESERVED1;     /*!&lt; Reserved,                                                 Address offset: 0x14 */\n  volatile uint32_t IOASCR;        /*!&lt; TSC I/O analog switch control register,                   Address offset: 0x18 */\n  uint32_t      RESERVED2;     /*!&lt; Reserved,                                                 Address offset: 0x1C */\n  volatile uint32_t IOSCR;         /*!&lt; TSC I/O sampling control register,                        Address offset: 0x20 */\n  uint32_t      RESERVED3;     /*!&lt; Reserved,                                                 Address offset: 0x24 */\n  volatile uint32_t IOCCR;         /*!&lt; TSC I/O channel control register,                         Address offset: 0x28 */\n  uint32_t      RESERVED4;     /*!&lt; Reserved,                                                 Address offset: 0x2C */\n  volatile uint32_t IOGCSR;        /*!&lt; TSC I/O group control status register,                    Address offset: 0x30 */\n  volatile uint32_t IOGXCR[8];     /*!&lt; TSC I/O group x counter register,                         Address offset: 0x34-50 */\n} TSC_TypeDef;\n</code></pre> <p>Pretty simple and efficient so far. This macro will expand into a simple pointer to the memory mapped registers of the TSC peripheral after preprocessor does its job.</p> <pre><code>((TSC_TypeDef *)DT_N_S_soc_S_tsc_40024000_REG_IDX_0_VAL_ADDRESS) // 0x40024000\n</code></pre>"},{"location":"zephyr-device-driver/#clock-and-reset-control","title":"Clock and Reset Control","text":"<p>We now need the <code>clocks</code> property to get the device responsible for clock control in the system, we already passed the clock controller <code>RCC</code> as a reference to the TSC device node.</p> <p>Clock and reset control is common to ARM based MCUs so Zephyr provides a Clock Control Peripheral API to vendors to develop their own clock and reset control drivers. We can use this API to enable the clock for the TSC peripheral.</p> <p>Here is the API to enable the clock for a subsystem (TSC in our case);</p> <pre><code>/* zephyr/drivers/clock_control.h */\n\nstatic int clock_control_on ( const struct device *dev, clock_control_subsys_t  sys );\n</code></pre> <p>This means we can just pass a generic <code>device</code> that has been defined in the device tree <code>clocks</code> property to the generic <code>clock_control_on</code> with the peripheral and bus information and it will do the job for us. The <code>sys</code> argument is the opaque data to the Clock Control Peripheral API (void pointer) and will be passed to the API implementer that will cast and use the data to enable the clock for the TSC peripheral, this corresponds to the <code>STM32_CLOCK_BUS_AHB1 (0x48)</code> and <code>0x01000000</code> value in the device tree node. We can extract these values on our own but ST provides a nice macro to do this for us.</p> <pre><code>#include &lt;zephyr/drivers/clock_control/stm32_clock_control.h&gt;\n\n#define TSC_CLOCK(node) (struct stm32_pclken) STM32_CLOCK_INFO(0, node);\n</code></pre> <p>This macro will expand into more device tree macros and will give us the clock information for the TSC peripheral.</p> <pre><code>/* zepryr/include/drivers/clock_control/stm32_clock_control.h */\n\n#define STM32_CLOCK_INFO(clk_index, node_id)    \\\n {        \\\n .enr = DT_CLOCKS_CELL_BY_IDX(node_id, clk_index, bits),  \\\n .bus = DT_CLOCKS_CELL_BY_IDX(node_id, clk_index, bus)  \\\n }\n</code></pre> <p>Note</p> <p>We are only using one clock for this peripheral but multiple can be defined, in that case a different macro <code>STM32_DT_INST_CLOCKS</code> is used instead.</p> <p>Which will expand into;</p> <pre><code>{\n  .enr = DT_N_S_soc_S_tsc_40024000_P_clocks_IDX_0_VAL_bus // 0x48\n  .bus = DT_N_S_soc_S_tsc_40024000_P_clocks_IDX_0_VAL_bits // 0x1000000\n}\n</code></pre> <p>Reset control is even simpler, we again use the <code>resets</code> property to get the device responsible for reset control in the system, and we can use the same API to reset the TSC peripheral. We will use the Reset Controller Peripheral API to reset the TSC peripheral.</p> <pre><code>#include &lt;zephyr/reset.h&gt;\n\n#define TSC_RESET(node) (const struct reset_dt_spec *) RESET_DT_SPEC_INST_GET_OR(node, NULL)\n</code></pre> <p>This macro will get the <code>resets</code> property if it exists, <code>NULL</code> otherwise. This is a pointer to the reset controller device that will be used to reset the TSC peripheral. And <code>reset_dt_spec</code> is a struct that contains the reset controller device and the reset line number, <code>24</code> in our case.</p> <pre><code>struct reset_dt_spec {\n  const struct device *dev;\n  uint32_t line_num;\n};\n</code></pre> <p>So this will expand into</p> <pre><code>(const struct reset_dt_spec *) { .dev = DT_N_S_soc_S_tsc_40024000_P_resets, .line_num = 24 }\n</code></pre> <p>With this struct we can use variety of reset control APIs to reset the TSC peripheral.</p> <pre><code>/* zephyr/include/drivers/reset.h */\nint reset_status_dt(const struct reset_dt_spec *spec, uint8_t *status);\nint reset_line_assert_dt(const struct reset_dt_spec *spec);\nint reset_line_deassert_dt(const struct reset_dt_spec *spec);\nint reset_line_toggle_dt(const struct reset_dt_spec *spec)\n</code></pre>"},{"location":"zephyr-device-driver/#pin-controller","title":"Pin Controller","text":"<p>This is another peripheral we have to deal with, again Zephyr has a Pin Controller Peripheral API to handle the pin configuration. We can use this API to configure the pins for the TSC peripheral.</p> <p>This is a little tricky because the pin controller configs needs to be defined, but there is a macro for it too.</p> <pre><code>#include &lt;zephyr/drivers/pinctrl.h&gt;\n\n#define TSC_PINCTRL_DEFINE(node) PINCTRL_DT_INST_DEFINE(node)\n#define TSC_PINCTRL(node) ((const struct pinctrl_dev_config *) PINCTRL_DT_INST_DEV_CONFIG_GET(node))\n</code></pre> <p>We can then use this struct to apply all the pin states at runtime.</p> <pre><code>int pinctrl_apply_state(const struct pinctrl_dev_config *config, uint8_t id)\n</code></pre> <p><code>id</code> is the pin control name property, <code>default (0)</code> in our case.</p>"},{"location":"zephyr-device-driver/#group-configurations","title":"Group Configurations","text":"<p>From now on we only have basic types and need no additional subsystem or peripheral API.</p> <p>A driver instance can have many groups, so lets define a struct to hold the group configurations.</p> <pre><code>struct stm32_tsc_group_config\n{\n  uint8_t group;\n  uint8_t channel_ios;\n  uint8_t sampling_io;\n  bool use_as_shield;\n};\n</code></pre> <p>To fill this struct we need to access the child nodes of the TSC node in the device tree.</p> <pre><code>#define STM32_TSC_GROUP(node) \n  { \n    .group = DT_PROP(node, group), \n    .channel_ios = DT_PROP(node, channel_ios), \n    .sampling_io = DT_PROP(node, sampling_io), \n    .use_as_shield = DT_PROP(node, use_as_shield), \n  },\n</code></pre> <p>This macro will expand into the following code;</p> <pre><code>{\n  .group = DT_N_S_soc_S_tsc_40024000_g1_group,\n  .channel_ios = DT_N_S_soc_S_tsc_40024000_g1_channel_ios,\n  .sampling_io = DT_N_S_soc_S_tsc_40024000_g1_sampling_io,\n  .use_as_shield = DT_N_S_soc_S_tsc_40024000_g1_use_as_shield,\n},\n</code></pre> <p>To define multiple of these, Zephyr provides a macro <code>DT_INST_FOREACH_CHILD_STATUS_OKAY</code> that will iterate over all the child nodes of a parent node and call a function for each child node that has a status of <code>okay</code>.</p> <pre><code>#define STM32_TSC_GROUPS(node) (const struct stm32_tsc_group_config[]) { \n  DT_INST_FOREACH_CHILD_STATUS_OKAY(node, STM32_TSC_GROUP) \n}\n</code></pre> <p>This will eventually expand into;</p> <pre><code>(const struct stm32_tsc_group_config[]) {\n  {\n    .group = DT_N_S_soc_S_tsc_40024000_g1_group,\n    .channel_ios = DT_N_S_soc_S_tsc_40024000_g1_channel_ios,\n    .sampling_io = DT_N_S_soc_S_tsc_40024000_g1_sampling_io,\n    .use_as_shield = DT_N_S_soc_S_tsc_40024000_g1_use_as_shield,\n  },\n  {\n    .group = DT_N_S_soc_S_tsc_40024000_g6_group,\n    .channel_ios = DT_N_S_soc_S_tsc_40024000_g6_channel_ios,\n    .sampling_io = DT_N_S_soc_S_tsc_40024000_g6_sampling_io,\n    .use_as_shield = DT_N_S_soc_S_tsc_40024000_g6_use_as_shield,\n  }\n}\n</code></pre>"},{"location":"zephyr-device-driver/#tsc-configuration","title":"TSC Configuration","text":"<p>Finally we need a struct to hold all the information about the TSC peripheral, including the base address, clock and reset control, pin controller, group configurations and other properties.</p> <pre><code>struct stm32_tsc_config\n{\n  TSC_TypeDef *tsc;\n  const struct stm32_pclken *pclken;\n  const struct reset_dt_spec *reset;\n  const struct pinctrl_dev_config *pcfg;\n  const struct stm32_tsc_group_config *groups;\n  uint8_t groups_size;\n  uint8_t pgpsc;\n  uint8_t ctph;\n  uint8_t ctpl;\n  uint8_t sscpsc;\n  uint8_t ssd;\n  uint8_t max_count;\n  bool spread_spectrum;\n  bool sync_acq;\n  bool sync_pol;\n  bool iodef_float;\n\n  void (*irq_func)(void);\n};\n</code></pre>"},{"location":"zephyr-device-driver/#putting-it-all-together","title":"Putting it all together","text":"<p>Once we put it all together we get a big initialization macro (backlashes are omitted for readability);</p> <pre><code>#define TSC_GROUP(node) \n  { \n    .group = DT_PROP(node, group), \n    .channel_ios = DT_PROP(node, channel_ios), \n    .sampling_io = DT_PROP(node, sampling_io), \n    .use_as_shield = DT_PROP(node, use_as_shield), \n  },\n\n#define TSC_GROUPS(node) \n  (const struct stm32_tsc_group_config[]) { \n    DT_INST_FOREACH_CHILD_STATUS_OKAY(node, STM32_TSC_GROUP) \n  }\n\n#define TSC_BASE(node) ((TSC_TypeDef *)DT_INST_REG_ADDR(node))\n#define TSC_CLOCK(node) (struct stm32_pclken) STM32_CLOCK_INFO(0, node)\n#define TSC_RESET(node) (const struct reset_dt_spec) RESET_DT_SPEC_INST_GET_OR(node, NULL)\n#define TSC_PINCTRL_DEFINE(node) PINCTRL_DT_INST_DEFINE(node)\n#define TSC_PINCTRL(node) ((const struct pinctrl_dev_config *) PINCTRL_DT_INST_DEV_CONFIG_GET(node))\n\n#define STM32_TSC_INIT(node)\n\n  static void stm32_tsc_irq_init_##node(void){\n    IRQ_CONNECT(DT_INST_IRQN(node), DT_INST_IRQ(node, priority), stm32_tsc_isr, DEVICE_DT_INST_GET(node), 0);\n    irq_enable(DT_INST_IRQN(node));\n  };\n\n  TSC_PINCTRL_DEFINE(node);\n\n  static const struct stm32_tsc_group_config groups[] = TSC_GROUPS(node);\n\n  static const struct stm32_tsc_config tsc_config##node = \n  {\n    .tsc = TSC_BASE(node),\n    .pclken = TSC_CLOCK(node),\n    .reset = TSC_RESET(node),\n    .pcfg = TSC_PINCTRL(node),\n    .groups = groups,\n    .groups_size = DT_INST_CHILD_NUM_STATUS_OKAY(groups),\n    .pgpsc = DT_INST_PROP_OR(node, pulse_generator_prescaler, 2),\n    .ctph = DT_INST_PROP_OR(node, ctph, 2),\n    .ctpl = DT_INST_PROP_OR(node, ctpl, 2),\n    .sscpsc = DT_INST_PROP_OR(node, spread_spectrum_prescaler, 1),\n    .ssd = DT_INST_PROP_OR(node, spread_spectrum_deviation, 1),\n    .max_count = DT_INST_PROP_OR(node, max_count_value, 5),\n    .spread_spectrum = DT_INST_PROP_OR(node, spread_spectrum, false),\n    .sync_acq = DT_INST_PROP_OR(node, synced_acquisition, false),\n    .sync_pol = DT_INST_PROP_OR(node, syncpol_rising, false),\n    .iodef_float = DT_INST_PROP_OR(node, iodef_float, false),\n    .irq_func = stm32_tsc_irq_init_##node,\n  };\n\n  DEVICE_DT_INST_DEFINE(node, stm32_tsc_init, NULL, NULL, &amp;stm32_tsc_cfg_##node, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, NULL);\n</code></pre> <p>When Zephyr starts booting, it will call all drivers' initialization functions, so when we enter <code>main()</code> we will have everything ready for our application. To enable Zephyr to pick up our driver and call it before main <code>DEVICE_DT_INST_DEFINE</code> is used. This macro has parameters <code>node_id</code>, initialization function, power management function (<code>NULL</code> for us), a pointer to device data in RAM (<code>NULL</code> for us), a pointer to device data in FLASH (cast to void pointer as we will see in Peripheral API section), initialization level, initialization priority, and a pointer to a device API structure (<code>NULL</code> for us).</p> <p>What all the device tree was is to be able to fill this struct. We have defined the binding file, written the node and generated the <code>devicetree_generated.h</code> file and got all the data we need.</p> <p>For this specific node if we call <code>STM32_TSC_INIT</code> with our node, the generated code will look like this;</p> <pre><code>static void stm32_tsc_irq_init_0(void){\n  IRQ_CONNECT(21, 0, stm32_tsc_isr, DEVICE_DT_INST_GET(0), 0);\n  irq_enable(21);\n};\n\nstatic const struct stm32_tsc_group_config groups[] = \n{\n  {\n    .group = DT_N_S_soc_S_tsc_40024000_g1_group,\n    .channel_ios = DT_N_S_soc_S_tsc_40024000_g1_channel_ios,\n    .sampling_io = DT_N_S_soc_S_tsc_40024000_g1_sampling_io,\n    .use_as_shield = DT_N_S_soc_S_tsc_40024000_g1_use_as_shield,\n  },\n  {\n    .group = DT_N_S_soc_S_tsc_40024000_g6_group,\n    .channel_ios = DT_N_S_soc_S_tsc_40024000_g6_channel_ios,\n    .sampling_io = DT_N_S_soc_S_tsc_40024000_g6_sampling_io,\n    .use_as_shield = DT_N_S_soc_S_tsc_40024000_g6_use_as_shield,\n  }\n};\n\nstatic const struct stm32_tsc_config tsc_config = \n{\n  .tsc = (TSC_TypeDef *)DT_N_S_soc_S_tsc_40024000_REG_IDX_0_VAL_ADDRESS,\n  .pclken = &amp;DT_N_S_soc_S_tsc_40024000_P_clocks,\n  .reset = DT_N_S_soc_S_tsc_40024000_P_resets,\n  .groups = groups,\n  .irq_func = tsc_isr,\n  .groups_size = 2,\n  .pgpsc = DT_N_S_soc_S_tsc_40024000_P_pulse_generator_prescaler,\n  .ctph = DT_N_S_soc_S_tsc_40024000_P_ctph,\n  .ctpl = DT_N_S_soc_S_tsc_40024000_P_ctpl,\n  .sscpsc = DT_N_S_soc_S_tsc_40024000_P_spread_spectrum_prescaler,\n  .ssd = DT_N_S_soc_S_tsc_40024000_P_spread_spectrum_deviation,\n  .max_count = DT_N_S_soc_S_tsc_40024000_P_max_count_value,\n  .spread_spectrum = DT_N_S_soc_S_tsc_40024000_P_spread_spectrum,\n  .sync_acq = DT_N_S_soc_S_tsc_40024000_P_synced_acquisition,\n  .sync_pol = DT_N_S_soc_S_tsc_40024000_P_syncpol_rising,\n  .iodef_float = DT_N_S_soc_S_tsc_40024000_P_iodef_float,\n  .irq_func = stm32_tsc_irq_init_0,\n};\n\n/* device defininition code */\n</code></pre> <p>This is very roughly what ends up happening after preprocessor does its job.</p>"},{"location":"zephyr-device-driver/#interrupts","title":"Interrupts","text":"<p>One important thing not mentioned here is interrupts. We defined in the node that the interrupts are at position <code>21</code> and the priority is <code>0</code>. Zephyr has a nice API to connect interrupts to ISRs and enable them. In this implementation all interrupts are connected to <code>stm32_tsc_isr</code> function, which is a generic interrupt service routine, and it will take a parameter of type <code>const struct device *</code> (provided by passing <code>DEVICE_DT_INST_GET</code> to <code>ISR_CONNECT</code> ) so we will be able to serve multiple instances of the TSC peripheral with the same ISR. So if we call <code>stm32_tsc_irq_init_0</code> function, it will connect the interrupt to the ISR and enable it.</p> <p>I plan to be able to enable and disable interrupts from the Kconfig files which what Zephyr uses to configure the kernel at compile time.</p>"},{"location":"zephyr-device-driver/#device-driver-implementation","title":"Device Driver Implementation","text":"<p>Now that we have our device tree node and binding ready, data plumbed to the driver, and the device defined, we can start writing the driver code.</p> <p>We will again start by creating a directory for our driver in the workspace in the <code>zephyr/drivers/misc</code> folder for a cohesive folder structure. These are not mandatory but it is good practice to keep things organized.</p> <p>We can start writing the code right away. I'll just create <code>stm32_tsc.c</code> file in the <code>drivers/misc/stm32_tsc</code> directory.</p> <p>I like to start with the <code>DT_DRV_COMPAT</code> macro to define the compatible string for the driver, this is the same string we used in the binding file but special characters are replaced with underscores. And include the plumbing code so we can have the data ready.</p> <pre><code>/* zephyr/drivers/misc/stm32_tsc/stm32_tsc.c */\n\n#define DT_DRV_COMPAT st_stm32_tsc\n\n#include &lt;zephyr/irq.h&gt;\n#include &lt;zephyr/devicetree.h&gt;\n#include &lt;zephyr/drivers/reset.h&gt;\n#include &lt;zephyr/drivers/pinctrl.h&gt;\n#include &lt;zephyr/drivers/clock_control/stm32_clock_control.h&gt;\n\nstruct stm32_tsc_group_config {\n const uint8_t  group;\n const uint8_t  channel_ios;\n const uint8_t  sampling_io;\n const bool     use_as_shield;\n const uint32_t zephyr_code;\n};\n\nstruct stm32_tsc_config {\n TSC_TypeDef       *tsc;\n const struct stm32_prcc_deven     pclken;\n const struct reset_dt_spec      reset;\n const struct pinctrl_dev_config     *pcfg;\n const struct stm32_tsc_group_config *groups;\n const uint8_t        groups_size;\n\n const uint8_t        pgpsc;\n const uint8_t        ctph;\n const uint8_t        ctpl;\n const bool        spread_spectrum;\n const uint8_t        sscpsc;\n const uint8_t        ssd;\n const uint16_t        max_count;\n const bool        iodef;\n const bool        sync_acq;\n const bool        sync_pol;\n void (*irq_func)(void);\n};\n\n#define STM32_TSC_GROUP(node)                                 \\\n  {                                                           \\\n    .group = DT_PROP(node, group),                            \\\n    .channel_ios = DT_PROP(node, channel_ios),                \\\n    .sampling_io = DT_PROP(node, sampling_io),                \\\n    .use_as_shield = DT_PROP(node, use_as_shield),            \\\n  },\n\n#define STM32_TSC_GROUPS(node)                                \\\n  (const struct stm32_tsc_group_config[]) {                   \\\n    DT_INST_FOREACH_CHILD_STATUS_OKAY(node, STM32_TSC_GROUP)  \\\n  }\n\n#define STM32_TSC_BASE(node) ((TSC_TypeDef *)DT_INST_REG_ADDR(node))\n#define STM32_TSC_CLOCK(node) (const struct stm32_pclken) STM32_CLOCK_INFO(0, DT_DRV_INST(node))\n#define STM32_TSC_RESET(node) (const struct reset_dt_spec) RESET_DT_SPEC_INST_GET_OR(node, NULL)\n#define STM32_TSC_PINCTRL_DEFINE(node) PINCTRL_DT_INST_DEFINE(node)\n#define STM32_TSC_PINCTRL(node) ((const struct pinctrl_dev_config *) PINCTRL_DT_INST_DEV_CONFIG_GET(node))\n\n#define STM32_TSC_INIT(node)                                                                                        \\\n                                                                                                                    \\\n  static void stm32_tsc_irq_init_##node(void) {                                                                     \\\n    IRQ_CONNECT(DT_INST_IRQN(node), DT_INST_IRQ(node, priority), stm32_tsc_isr, DEVICE_DT_INST_GET(node), 0);       \\\n    irq_enable(DT_INST_IRQN(node));                                                                                 \\\n  };                                                                                                                \\\n                                                                                                                    \\\n  STM32_TSC_PINCTRL_DEFINE(node);                                                                                   \\\n                                                                                                                    \\\n  static const struct stm32_tsc_group_config groups[] = STM32_TSC_GROUPS(node);                                     \\\n                                                                                                                    \\\n  static const struct stm32_tsc_config tsc_config##node =                                                           \\\n  {                                                                                                                 \\\n  .tsc = STM32_TSC_BASE(node),                                                                                      \\\n  .pclken = STM32_TSC_CLOCK(node),                                                                                  \\\n  .reset = STM32_TSC_RESET(node),                                                                                   \\\n  .pcfg = STM32_TSC_PINCTRL(node),                                                                                  \\\n  .groups = groups,                                                                                                 \\\n  .groups_size = DT_INST_CHILD_NUM_STATUS_OKAY(node),                                                               \\\n  .pgpsc = DT_INST_PROP_OR(node, pulse_generator_prescaler, 2),                                                     \\\n  .ctph = DT_INST_PROP_OR(node, ctph, 2),                                                                           \\\n  .ctpl = DT_INST_PROP_OR(node, ctpl, 2),                                                                           \\\n  .spread_spectrum = DT_INST_PROP_OR(node, spread_spectrum, false),                                                 \\\n  .sscpsc = DT_INST_PROP_OR(node, spread_spectrum_prescaler, 1),                                                    \\\n  .ssd = DT_INST_PROP_OR(node, spread_spectrum_deviation, 1),                                                       \\\n  .max_count = DT_INST_PROP_OR(node, max_count_value, 5),                                                           \\\n  .iodef = DT_INST_PROP_OR(node, iodef_float, false),                                                               \\\n  .sync_acq = DT_INST_PROP_OR(node, synced_acquisition, false),                                                     \\\n  .sync_pol = DT_INST_PROP_OR(node, syncpol_rising, false),                                                         \\\n  };                                                                                                                \\\n                                                                                                                    \\\n  DEVICE_DT_INST_DEFINE(node, stm32_tsc_init, NULL, NULL, &amp;tsc_config##node, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, NULL);\n\nDT_INST_FOREACH_STATUS_OKAY(STM32_TSC_INIT)\n</code></pre> <p><code>DT_INST_FOREACH_STATUS_OKAY</code> is another macro which will iterate over all the instances of the driver in the device tree and call the function for each instance that has a status of <code>okay</code>.</p> <p>We already defined in some parts of the code that we will use functions named <code>stm32_tsc_isr</code> and <code>stm32_tsc_init</code> so we need to define them. But before doing that a little info about peripheral and subsystem APIs so we can initialize TSC related configurations using other devices like <code>RCC</code>, <code>GPIO</code>, <code>NVIC</code>, etc.</p>"},{"location":"zephyr-device-driver/#peripheral-and-subsystem-apis","title":"Peripheral and Subsystem APIs","text":"<p>Peripheral APIs are generic Zephyr APIs that defines a common interface for general \"peripherals\", like GPIO, PWM, I2C, SPI, etc. These APIs are implemented by the SoC specific HALs so we don't have to change our application code, or driver code, if we change the hardware. We will be only dealing with the Zephyr APIs and it will do the plumbing for us.</p> <p>These peripheral APIs are usually pretty nice and complete, for example check out the comprehensive GPIO Peripheral API documentation.</p> <p>To use any GPIO in Zephyr we just need to include the header file and use the API.</p> <pre><code>#include &lt;zepryr/drivers/gpio.h&gt;\n\nvoid main(void)\n{\n    struct device *dev = NULL;\n    int ret = 0;\n\n    dev = device_get_binding(\"GPIO_0\");\n    if (!dev) {\n        k_panic(\"Could not get GPIO device\\n\");\n        return;\n    }\n\n    ret = gpio_pin_configure(dev, 0, GPIO_INPUT | GPIO_ACTIVE_HIGH);\n    if (ret) {\n        k_panic(\"Could not configure GPIO pin 0\\n\");\n        return;\n    }\n\n    ...\n}\n</code></pre> <p>Once we are able to get a <code>device</code> struct, we can then pass it to its respective API. Notice how <code>struct device</code> is just a generic struct, in fact if we look at the definition of it we see a really abstract structure:</p> <pre><code>/**\n * @brief Runtime device structure (in ROM) per driver instance\n */\nstruct device {\n /** Name of the device instance */\n const char *name;\n /** Address of device instance config information */\n const void *config;\n /** Address of the API structure exposed by the device instance */\n const void *api;\n /** Address of the common device state */\n struct device_state *state;\n /** Address of the device instance private data */\n void *data;\n\n  ...\n};\n</code></pre> <p><code>config</code>, <code>api</code> and <code>data</code> are all adapters (void pointers) to whatever any \"device\" wants. And if we look at the <code>gpio_pin_configure</code> function you see after some checking it calls the actual driver that was described in the device tree of the hardware we are using, which was connected to this adapter at boot time, by the device tree macros. We will see this in detail in the next section.</p> <pre><code>int gpio_pin_configure(const struct device *port,\n     gpio_pin_t pin,\n     gpio_flags_t flags)\n{\n  const struct gpio_driver_api *api =\n    (const struct gpio_driver_api *)port-&gt;api;\n\n  ...\n\n return api-&gt;pin_configure(port, pin, flags);\n}\n</code></pre> <p>So the <code>void *api</code> was assigned to the device structure by the actual vendor driver at boot time and again dereferenced here by the API to get the address of the actual driver function which does the actual configuration. So probably the vendor driver will look into the <code>config</code> field or the <code>data</code> field to get the actual hardware registers and do the configuration.</p> <p>Strong opinion time; C allowed this kind of abstraction all along, but nobody dared to implement it. I think this was the framework industry needed for a long time, and Zephyr did it right. So hats off to the Zephyr team for this.</p> <p>The peripheral APIs this driver will use are;</p> <ul> <li>Clock Control</li> <li>Reset Controller</li> <li>Pin Controller</li> <li>Interrupts</li> </ul> <p>There are also subsystems, they are pretty similar to peripherals in terms of their use but the difference is that they do not rely on hardware. Things like console or file systems. One subsystem this driver can use is the Input Subsystem. This subsystem is used for anything that is an input, usually touch screens, buttons, etc. We can use this subsystem to get the touch input from the TSC peripheral.</p>"},{"location":"zephyr-device-driver/#reset-api","title":"Reset API","text":"<p>Since we will be using another device we should check if it was initialized before using it. Zephyr has a function for this</p> <pre><code>#include &lt;zephyr/device.h&gt;\n\nvoid stm32_tsc_init(const struct device *dev)\n{\n  const struct stm32_tsc_config *config = dev-&gt;config;\n  const struct device *const  rcc_dev = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);\n\n  if (!device_is_ready(rcc_dev))\n  {\n    LOG_ERR(\"TSC@%p: clock and reset controller device not ready\", config-&gt;tsc);\n    return -ENODEV;\n  }\n\n}\n</code></pre> <p>First thing to do is to get the devices and configs we will use. In this case this device's config point to a memory location that holds the <code>struct stm32_tsc_config</code> we defined earlier, so we will cast the <code>dev-&gt;config</code>, which was a void pointer to this struct and use it. Another one is the <code>rcc_dev</code> which is the clock and reset controller device we will use to reset the TSC peripheral. <code>STM32_CLOCK_CONTROL_NODE</code> is defined in <code>stm32_clock_control.h</code> and points to the device tree node that holds the clock and reset controller information.</p> <p>After this we will use <code>reset_line_toggle_dt</code> from the reset API to reset the TSC peripheral, so the peripheral values are at their defaults.</p> <p>Note</p> <p>Also a subsystem called <code>Log</code> is used here, but since it is irrelevant, I will not discuss it. Please find more information about it in the Zephyr Documentation.</p> <pre><code>#include &lt;zephyr/drivers/reset.h&gt;\n\nvoid stm32_tsc_init(const struct device *dev)\n{\n  const struct stm32_tsc_config *config = dev-&gt;config;\n  const struct device *const  rcc_dev = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);\n\n  ...\n\n  int ret = reset_line_toggle_dt(config-&gt;reset);\n  if (ret &lt; 0)\n  {\n    LOG_ERR(\"Failed to reset TSC@%p (%d)\", config-&gt;tsc, ret);\n    return ret;\n  }\n}\n</code></pre>"},{"location":"zephyr-device-driver/#clock-control-api","title":"Clock Control API","text":"<p>Then we will use the clock control API to enable the clock for the TSC peripheral.</p> <pre><code>#include &lt;zephyr/drivers/clock_control.h&gt;\n\nvoid stm32_tsc_init(const struct device *dev)\n{\n  const struct stm32_tsc_config *config = dev-&gt;config;\n  const struct device *const  rcc_dev = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);\n\n  ...\n\n  ret = clock_control_on(rcc_dev, (clock_control_subsys_t)&amp;config-&gt;pclken);\n  if (ret &lt; 0)\n  {\n    LOG_ERR(\"Failed to enable clock for TSC@%p (%d)\", config-&gt;tsc, ret);\n    return ret;\n  }\n}\n</code></pre>"},{"location":"zephyr-device-driver/#pin-controller-api","title":"Pin Controller API","text":"<p>And finally we will use the pin controller API to configure the pins for the TSC peripheral.</p> <pre><code>#include &lt;zephyr/drivers/pinctrl.h&gt;\n\nvoid stm32_tsc_init(const struct device *dev)\n{\n  const struct stm32_tsc_config *config = dev-&gt;config;\n  const struct device *const  rcc_dev = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);\n\n  ...\n\n  ret = pinctrl_apply_state(config-&gt;pcfg, PINCTRL_STATE_DEFAULT);\n  if (ret &lt; 0)\n  {\n    LOG_ERR(\"Failed to configure TSC@%p pins (%d)\", config-&gt;tsc, ret);\n    return ret;\n  }\n}\n</code></pre> <p>This will be all for now for the peripheral APIs, the rest of it is just memory writes and reads to/from the TSC peripheral registers and finally calling the interrupt enable function we defined earlier in <code>STM32_TSC_INIT</code>, which makes this final code for the <code>stm32_tsc_init</code> function.</p>"},{"location":"zephyr-device-driver/#stm32_tsc_init","title":"stm32_tsc_init","text":"<pre><code>#include &lt;soc.h&gt;\n\nstatic int stm32_tsc_init(const struct device *dev)\n{\n const struct stm32_tsc_config *config = dev-&gt;config;\n const struct device *const     rcc_dev = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);\n\n int          ret;\n\n if (!device_is_ready(rcc_dev))\n {\n  LOG_ERR(\"TSC@%p: clock and reset controller device not ready\", config-&gt;tsc);\n  return -ENODEV;\n }\n\n /* reset TSC values to default */\n ret = reset_line_toggle_dt(&amp;config-&gt;reset);\n if (ret &lt; 0)\n {\n  LOG_ERR(\"Failed to reset TSC@%p (%d)\", config-&gt;tsc, ret);\n  return ret;\n }\n\n ret = clock_control_on(rcc_dev, (clock_control_subsys_t)&amp;config-&gt;pclken);\n if (ret &lt; 0)\n {\n  LOG_ERR(\"Failed to enable clock for TSC@%p (%d)\", config-&gt;tsc, ret);\n  return ret;\n }\n\n ret = pinctrl_apply_state(config-&gt;pcfg, PINCTRL_STATE_DEFAULT);\n if (ret &lt; 0)\n {\n  LOG_ERR(\"Failed to configure TSC@%p pins (%d)\", config-&gt;tsc, ret);\n  return ret;\n }\n\n /* set ctph (bits 31:28) and ctpl (bits 27:24) */\n sys_set_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, (((config-&gt;ctph - 1) &lt;&lt; 4) | (config-&gt;ctpl - 1)) &lt;&lt; TSC_CR_CTPL_Pos);\n\n /* set spread spectrum deviation (bits 23:17) */\n sys_set_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, config-&gt;ssd &lt;&lt; TSC_CR_SSD_Pos);\n\n /* set pulse generator prescaler (bits 14:12) */\n sys_set_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, config-&gt;pgpsc &lt;&lt; TSC_CR_PGPSC_Pos);\n\n /* set max count value (bits 7:5) */\n sys_set_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, config-&gt;max_count &lt;&lt; TSC_CR_MCV_Pos);\n\n /* set spread spectrum prescaler (bit 15) */\n if (config-&gt;sscpsc == 2)\n  sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, TSC_CR_SSPSC_Pos);\n\n /* set sync bit polarity */\n if (config-&gt;sync_pol)\n  sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, TSC_CR_SYNCPOL_Pos);\n\n /* set sync acquisition */\n if (config-&gt;sync_acq)\n  sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, TSC_CR_AM_Pos);\n\n /* set I/O default mode */\n if (config-&gt;iodef)\n  sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, TSC_CR_IODEF_Pos);\n\n /* set spread spectrum */\n if (config-&gt;spread_spectrum)\n  sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, TSC_CR_SSE_Pos);\n\n /* group configuration */\n for (int i = 0; i &lt; config-&gt;groups_size; i++)\n {\n  const struct stm32_tsc_group_config *group = &amp;config-&gt;groups[i];\n\n  if (group-&gt;channel_ios &amp; group-&gt;sampling_io)\n  {\n   LOG_ERR(\"TSC@%p: group %d has the same channel and sampling I/O\", config-&gt;tsc, group-&gt;group);\n   return -EINVAL;\n  }\n\n  /* if use_as_shield is true, the channel I/Os are used as shield, and can only have values 1,2,4,8 */\n  if (group-&gt;use_as_shield &amp;&amp;\n      group-&gt;channel_ios != 1 &amp;&amp;\n      group-&gt;channel_ios != 2 &amp;&amp;\n      group-&gt;channel_ios != 4 &amp;&amp;\n      group-&gt;channel_ios != 8)\n  {\n   LOG_ERR(\"TSC@%p: group %d is used as shield, but has invalid channel I/Os. Can only have one\", config-&gt;tsc, group-&gt;group);\n   return -EINVAL;\n  }\n\n  /* each group only has 4 configurable I/O */\n#define GET_GROUP_BITS(val) (uint32_t)(((val) &amp; 0x0f) &lt;&lt; ((group-&gt;group - 1) * 4))\n\n  /* clear schmitt trigger hysteresis for enabled I/Os */\n  sys_clear_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;IOHCR, GET_GROUP_BITS(group-&gt;channel_ios | group-&gt;sampling_io));\n\n  /* set channel I/Os */\n  sys_set_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;IOCCR, GET_GROUP_BITS(group-&gt;channel_ios));\n\n  /* set sampling I/O */\n  sys_set_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;IOSCR, GET_GROUP_BITS(group-&gt;sampling_io));\n\n  /* enable group */\n  if (!group-&gt;use_as_shield)\n   sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;IOGCSR, group-&gt;group - 1);\n }\n\n /* disable interrupts */\n sys_clear_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;IER, TSC_IER_EOAIE | TSC_IER_MCEIE);\n\n /* clear interrupts */\n sys_set_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;ICR, TSC_ICR_EOAIC | TSC_ICR_MCEIC);\n\n /* enable peripheral */\n sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, TSC_CR_TSCE_Pos);\n\n#if IS_ENABLED(CONFIG_STM32_TSC_INTERRUPT)\n config-&gt;irq_func();\n#endif\n\n return 0;\n}\n</code></pre> <p>The functions like <code>sys_set_bits</code> and <code>sys_clear_bits</code> are just memory writes to the peripheral registers and definitions like <code>TSC_IER_EOAIE</code> or <code>TSC_CR_IODEF_Pos</code> are taken from the SOC specific header file, which gets included with <code>soc.h</code> which corresponds to the <code>stm32u083xx.h</code> file in this case.</p> <p>If you noticed the interrupt is only enabled when there is a definition  called <code>CONFIG_STM32_TSC_INTERRUPT</code>. We will not define it in this file instead it will be defined globally by the Zephyr build system when parsing Kconfig files which we will see in the next section.</p>"},{"location":"zephyr-device-driver/#tsc-peripheral-api","title":"TSC Peripheral API","text":"<p>This is not quite a set-and-forget type of a driver. Application implementer should start the acquisition. Therefore the driver should expose some functions to interact with the TSC peripheral.</p> <p>Header files are resided in <code>include</code> directory of the Zephyr source, therefore this driver will be in <code>zephyr/include/drivers/misc/stm32_tsc.h</code>.</p> <pre><code>/* zephyr/include/drivers/misc/stm32_tsc.h */\n\n#ifndef ZEPHYR_DRIVERS_MISC_STM32_TSC_H_\n#define ZEPHYR_DRIVERS_MISC_STM32_TSC_H_\n\n#include &lt;zephyr/types.h&gt;\n\nvoid stm32_tsc_start(const struct device *dev);\nint  stm32_tsc_poll_for_acquisition(const struct device *dev, k_timeout_t timeout);\nint  stm32_tsc_read(const struct device *dev, uint8_t group, uint32_t *value);\n\n#endif /* ZEPHYR_DRIVERS_MISC_STM32_TSC_H_ */\n</code></pre> <p>This API is as simple as it can get. All functions require a <code>device</code> to work. <code>stm32_tsc_start</code> will start the acquisition, and if interrupt is enabled it should put the acquisition value to the input subsystem, or user can poll and read manually.</p>"},{"location":"zephyr-device-driver/#tsc-peripheral-api-implementation","title":"TSC Peripheral API Implementation","text":""},{"location":"zephyr-device-driver/#stm32_tsc_start","title":"stm32_tsc_start","text":"<pre><code>void stm32_tsc_start(const struct device *dev)\n{\n const struct stm32_tsc_config *config = dev-&gt;config;\n\n /* clear interrupts */\n sys_set_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;ICR, TSC_ICR_EOAIC | TSC_ICR_MCEIC);\n\n#if IS_ENABLED(CONFIG_STM32_TSC_INTERRUPT)\n /* enable end of acquisition and max count error interrupts */\n sys_set_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;IER, TSC_IER_EOAIE | TSC_IER_MCEIE);\n#endif\n\n /* start acquisition */\n sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;CR, TSC_CR_START_Pos);\n}\n</code></pre> <p>This is discussed in the previous sections, we clear and enable interrupts if enabled, only only set a bit to start the acquisition.</p>"},{"location":"zephyr-device-driver/#stm32_tsc_poll_for_acquisition","title":"stm32_tsc_poll_for_acquisition","text":"<p>When error or acquisition occurs the <code>ISR</code> register bits are set. Driver will check those and return if the bits are set (clearing them before returning) or a timeout occurs.</p> <pre><code>int stm32_tsc_poll_for_acquisition(const struct device *dev, k_timeout_t timeout)\n{\n const struct stm32_tsc_config *config = dev-&gt;config;\n uint32_t         status;\n uint32_t         start_tick = sys_clock_tick_get_32();\n\n do\n {\n  status = sys_read32((mem_addr_t)&amp;config-&gt;tsc-&gt;ISR);\n\n  if (sys_clock_tick_get_32() - start_tick &gt; timeout.ticks)\n  {\n   LOG_ERR(\"TSC@%p: timeout\", config-&gt;tsc);\n   return -ETIMEDOUT;\n  }\n\n } while (!(status &amp; TSC_ISR_EOAF) &amp;&amp; !(status &amp; TSC_ISR_MCEF));\n\n if (status &amp; TSC_ISR_MCEF)\n {\n  sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;ICR, TSC_ICR_MCEIC_Pos);\n  LOG_ERR(\"TSC@%p: max count error\", config-&gt;tsc);\n  return -EIO;\n }\n\n sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;ICR, TSC_ICR_EOAIC_Pos);\n\n return 0;\n}\n</code></pre>"},{"location":"zephyr-device-driver/#stm32_tsc_read","title":"stm32_tsc_read","text":"<p>Reading is also straightforward, we just read the data register of the TSC group.</p> <pre><code>int stm32_tsc_read(const struct device *dev, uint8_t group, uint32_t *value)\n{\n const struct stm32_tsc_config *config = dev-&gt;config;\n\n /* make sure group starts with 1 and can go max to IOGXCR count */\n if (value == NULL || group &lt; 1 || group &gt; 8)\n  return -EINVAL;\n\n *value = sys_read32((mem_addr_t)&amp;config-&gt;tsc-&gt;IOGXCR[group - 1]);\n\n return 0;\n}\n</code></pre>"},{"location":"zephyr-device-driver/#stm32_tsc_isr","title":"stm32_tsc_isr","text":"<p>This function just disables the interrupts and checks for errors just like in the polling function, and if there is no error it reads the values and reports them to the input subsystem.</p> <pre><code>static void stm32_tsc_isr(const struct device *dev)\n{\n const struct stm32_tsc_config *config = dev-&gt;config;\n\n /* disable interrupts */\n sys_clear_bits((mem_addr_t)&amp;config-&gt;tsc-&gt;IER, TSC_IER_EOAIE | TSC_IER_MCEIE);\n\n if (sys_test_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;ISR, TSC_ISR_MCEF_Pos))\n {\n  /* clear max count error flag */\n  sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;ICR, TSC_ICR_MCEIC_Pos);\n  LOG_ERR(\"TSC@%p: max count error\", config-&gt;tsc);\n  LOG_HEXDUMP_DBG(config-&gt;tsc, sizeof(TSC_TypeDef), \"TSC Registers\");\n  return -EIO;\n }\n\n if (sys_test_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;ISR, TSC_ISR_EOAF_Pos))\n {\n  /* clear end of acquisition flag */\n  sys_set_bit((mem_addr_t)&amp;config-&gt;tsc-&gt;ICR, TSC_ICR_EOAIC_Pos);\n\n  /* read values */\n  for (int i = 0; i &lt; config-&gt;groups_size; i++)\n  {\n   const struct stm32_tsc_group_config *group = &amp;config-&gt;groups[i];\n   uint32_t        group_bit = BIT(group-&gt;group - 1) &lt;&lt; 16;\n\n   if (config-&gt;tsc-&gt;IOGCSR &amp; group_bit)\n   {\n    int32_t count_value = sys_read32((mem_addr_t)&amp;config-&gt;tsc-&gt;IOGXCR[group-&gt;group - 1]);\n    input_report(dev, INPUT_EV_DEVICE, group-&gt;zephyr_code, count_value, true, K_FOREVER);\n   }\n  }\n }\n}\n</code></pre>"},{"location":"zephyr-device-driver/#integration-into-the-build-system","title":"Integration into the Build System","text":"<p>Zephyr uses Kconfig and CMake to decide if it will compile and link our source code. So this driver needs to integrate itself into this build system.</p> <p>In total 2 new files need to be created and 2 more needs editing.</p> <ul> <li><code>zephyr/drivers/misc/stm32_tsc/CMakeLists.txt</code> for the driver source</li> <li><code>zephyr/drivers/misc/stm32_tsc/Kconfig</code> for the driver configuration</li> <li><code>zephyr/drivers/misc/CMakeLists.txt</code> for the driver inclusion</li> <li><code>zephyr/drivers/misc/Kconfig</code> for the driver inclusion</li> </ul> <p>First thing this driver needs is to have a <code>CMakeLists.txt</code> and <code>Kconfig</code> file where the driver source is;</p>"},{"location":"zephyr-device-driver/#source-cmakeliststxt","title":"Source CMakeLists.txt","text":"<pre><code># zephyr/drivers/misc/stm32_tsc/CMakeLists.txt\nzephyr_library()\nzephyr_library_sources(stm32_tsc.c)\n</code></pre> <p>This will add this as a Zephyr library and include the <code>stm32_tsc.c</code> file in the build system.</p>"},{"location":"zephyr-device-driver/#source-kconfig","title":"Source Kconfig","text":"<p>For the Kconfig file, we will create a <code>Kconfig</code> file in the same directory as the <code>CMakeLists.txt</code> file.</p> <pre><code># zephyr/drivers/misc/stm32_tsc/Kconfig\nconfig STM32_TSC\n bool \"STM32 TSC driver\"\n depends on DT_HAS_ST_STM32_TSC_ENABLED\n help\n   Enable driver for STM32 TSC peripheral.\n\nif STM32_TSC\n\nconfig STM32_TSC_INTERRUPT\n bool \"Use interrupt for STM32 TSC\"\n default y\n help\n   Use interrupt for STM32 TSC peripheral.\n\nendif\n</code></pre> <p>Kconfig files are easy to read, and in this one we have only two configurations. The first one is to enable the driver, and the second one is to enable the interrupt. The first one depends on <code>DT_HAS_ST_STM32_TSC_ENABLED</code> which requires many more configs to make sure we run on <code>STM32</code> and in the system we have a TSC peripheral.</p>"},{"location":"zephyr-device-driver/#zephyr-cmakeliststxt","title":"Zephyr CMakeLists.txt","text":"<p>But the driver did not used <code>STM32_TSC</code> anywhere, so how does Zephyr know to include this driver in the build? This is done in the <code>zephyr/drivers/misc/CMakeLists.txt</code> file. We strategically placed these in subfolders, and these subfolders have their own <code>Kconfig</code> and <code>CMakeLists.txt</code> files. So that subdirs are accumulated as a chain. Therefore this drivers needs to be made aware to the parent directory.</p> <pre><code># zephyr/drivers/misc/CMakeLists.txt\nadd_subdirectory_ifdef(CONFIG_STM32_TSC stm32_tsc)\n</code></pre> <p>This is where the definition in the Kconfig file is used. If <code>CONFIG_STM32_TSC</code> is defined, then the <code>stm32_tsc</code> directory will be included in the build. The <code>CONFIG_</code> prefix is attached to every configuration in the Kconfig file.</p>"},{"location":"zephyr-device-driver/#zephyr-kconfig","title":"Zephyr Kconfig","text":"<p>Same has to be done with Kconfig but without the conditional inclusion.</p> <pre><code># zephyr/drivers/misc/Kconfig\nmenu \"Miscellaneous Drivers\"\n...\nsource \"drivers/misc/stm32_tsc/Kconfig\"\nendmenu\n</code></pre>"},{"location":"zephyr-device-driver/#how-do-we-test-this","title":"How Do We Test This?","text":"<p>Zephyr has an extensive testing and emulation framework, allowing us to do all kinds of tricks to confidently say our code works. And without even running it on a real hardware. Of course for this memory mapped peripheral driver, we would have to emulate the entire TSC peripheral, which is outside of the scope of this document, but I plan to write on emulation frameworks in the future.</p> <p>But first, lets test it on the real hardware.</p>"},{"location":"zephyr-device-driver/#building","title":"Building","text":"<p>The driver is written but there also needs to be an application to test it, we could create a new application but lets use an existing one. The Input Dump example is a good candidate for this. It is a simple application that reads every input event and prints it to the console.</p> <p>One change we need to edit in this application is to start the acquisition of the TSC peripheral, since it needed to be manually started.</p> <pre><code>/* zephyr/samples/subsys/input/input_dump/src/main.c */\n\n#include &lt;stdio.h&gt;\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/misc/stm32_tsc/stm32_tsc.h&gt;\n\nint main(void)\n{\n printf(\"Input sample started\\n\");\n\n const struct device *tsc_dev = DEVICE_DT_GET(DT_NODELABEL(tsc));\n\n if (!device_is_ready(tsc_dev))\n {\n  printf(\"TSC device is not ready\\n\");\n  return -ENODEV;\n }\n\n while (1)\n {\n  /* This will start the acqusition and print the readings to input subsystem */\n  stm32_tsc_start(tsc_dev);\n\n    /* You can alternatively disable interrupts and\n   * poll for acquisition completion. */\n#if !IS_ENABLED(CONFIG_STM32_TSC_INTERRUPT)\n  int ret = stm32_tsc_poll_for_acquisition(tsc_dev, K_MSEC(100));\n  if (ret &lt; 0)\n  {\n   printf(\"Failed to poll for acquisition\\n\");\n   return ret;\n  }\n\n  uint32_t value;\n  ret = stm32_tsc_read(tsc_dev, 6, &amp;value);\n  if (ret &lt; 0)\n  {\n   printf(\"Failed to read TSC\\n\");\n   return ret;\n  }\n\n  printf(\"TSC value: %u\\n\", value);\n#endif\n\n  k_msleep(100);\n }\n\n return 0;\n}\n</code></pre> <p>If you remember we kept the <code>status</code> of TSC at <code>disabled</code> in the device tree, so we need to change it to <code>okay</code> in the application overlay to be able to use it in the application.</p> <pre><code>/* zephyr/samples/subsys/input/input_dump/boards/stm32u083c_dk.overlay */\n\n&amp;tsc {\n status = \"okay\";\n};\n</code></pre> <p>Now all its left is to enable the driver in the config file of the application.</p> <pre><code># zephyr/samples/subsys/input/input_dump/prj.conf\nCONFIG_STM32_TSC=y\n</code></pre> <p>after all these changes, west is ready to build the application.</p> <pre><code>west build -b stm32u083c_dk zephyr/samples/subsys/input/input_dump\n</code></pre>"},{"location":"zephyr-device-driver/#flashing","title":"Flashing","text":""},{"location":"zephyr-device-driver/#linux","title":"Linux","text":"<p>If your host is Linux, you can use USB pass-through to flash the device. For this the devcontainer should be started with host's USB bus.</p> <p>There are several ways to do this but one way is to add it in <code>devcontainer.json</code></p> <pre><code>\"mounts\": [\"type=bind,source=/dev/bus/usb,target=/dev/bus/usb\"]\n</code></pre>"},{"location":"zephyr-device-driver/#windows","title":"Windows","text":"<p>If your host is Windows, USB pass-through is not possible. But you can use USB/IP to share the USB device with the container. This is a bit more complicated but it is possible. Please read the Microsoft's documentation on how to do this.</p>"},{"location":"zephyr-device-driver/#osx","title":"OSX","text":"<p>I am not sure if USB pass-through is possible, but USB/IP is currently unavailable on OSX. In this case you are on your own. I recommend pulling the files from the volume and flashing on the host with vendor tools, or opening an openOCD remote server and connecting to it inside the container.</p> <p>After starting the container with a mount or USB/IP, you can flash the device with the following command.</p> <pre><code>west flash\n</code></pre> <p>and if you connect to the USB Serial port with a terminal emulator (115200bps), we should see the input events printed on the console.</p> <pre><code>*** Booting Zephyr OS build 5466949aefaf ***\nInput sample started\nI: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1813\nI: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1803\nI: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1801\nI: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1811\nI: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1820\nI: input event: dev=tsc@40024000     SYN type=ef code=  2 value=1815\n</code></pre> <p>How do we know which group's value is this? From the schematic it is connected to the group 6, but as you can see the <code>code</code> field for this input event is <code>2</code>, and that is the <code>zephyr,code</code> field in the device tree. So we can check the <code>zephyr,code</code> field of the group 6 in the device tree and see it is <code>2</code>.</p>"},{"location":"zephyr-device-driver/#integration-testing","title":"Integration Testing","text":"<p>This step can be done at the beginning of the driver implementation to make sure the driver works as expected. This is called TDD (Test Driven Development) and it is a good practice to write tests before writing the actual code. But for the sake of this document I'll write the tests here. These tests can also be used to test the further modifications to the driver to make sure there is no regression in the driver when a change is made.</p>"},{"location":"zephyr-device-driver/#what-to-test","title":"What to Test?","text":"<p>There are two main options that can be tested in this driver. One is to test the driver API and its behavior, and the other is to test the actual register states for this peripheral, and see if it matches the device tree configuration.</p> <p>Our initial tests kept interrupt enabled, but in the integration tests we should test with and without this feature; <code>CONFIG_STM32_TSC_INTERRUPT</code>.</p>"},{"location":"zephyr-device-driver/#test-plan","title":"Test Plan","text":"<p>Here I outline the simple test plan for this driver. This might seem not enough to some, but should cover most cases.</p> <ul> <li>Test MMIO</li> <li>Check if the registers are set correctly</li> <li>Test the driver API (interrupt)</li> <li>Start the acquisition</li> <li>Test if input events are reported</li> <li>Test the driver API (polling)</li> <li>Start the acquisition</li> <li>Poll for acquisition</li> <li>Read the values</li> </ul>"},{"location":"zephyr-device-driver/#test-application","title":"Test Application","text":"<p>A test application (or a test suite as Zephyr calls it) is just another application that can either run on the host or on the target. Only difference is the inclusion of the <code>ztest</code> library and the test functions with an additional <code>testcase.yml</code> file for the test runner (twister) to pick up the application as a test.</p> <p>I'll create a new application in the <code>tests/drivers/misc/stm32_tsc</code> directory and add my files there.</p>"},{"location":"zephyr-device-driver/#cmakeliststxt","title":"CMakeLists.txt","text":"<p>This is just a generic cmake file that used in any other application cmake file.</p> <pre><code># zephyr/tests/drivers/misc/stm32_tsc/CMakeLists.txt\ncmake_minimum_required(VERSION 3.20.0)\nfind_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})\nproject(stm32_tsc)\n\nFILE(GLOB app_sources src/*.c)\ntarget_sources(app PRIVATE ${app_sources})\n</code></pre>"},{"location":"zephyr-device-driver/#prjconf","title":"prj.conf","text":"<p>Since we do not have any emulator for TSC peripheral, we will run all the tests on the hardware.</p> <pre><code># tests/drivers/misc/stm32_tsc/prj.conf\nCONFIG_STM32_TSC=y\nCONFIG_ZTEST=y\nCONFIG_INPUT=y\nCONFIG_INPUT_MODE_SYNCHRONOUS=y\n</code></pre> <p>This enables the driver and the test framework, and also the input subsystem to be able to test input events.</p>"},{"location":"zephyr-device-driver/#device-tree-overlays","title":"Device tree overlays","text":"<p>This devicetree modification is to make sure we use different values for the configuration than the reset values of the TSC peripheral, so that we can hit the parts of our code that sets the registers.</p> <p>This includes using <code>synced acquisition</code> as discussed in the Hardware Configuration section. This requires two different additional pin configurations, one for the sync input pin and the other one is to trigger the sync pin. In the following example I've used generic <code>zephyr,user</code> node to define the trigger pin, which I arbitrarily chose to be <code>GPIOA 10</code> which is exposed in my development kit.</p> <p>And for the sync pin, I've used <code>PD2</code> but this is not an arbitrary pin and it has been chosen with the help of the MCU datasheet. Luckily this pin is also exposed in my development kit. </p> <p>Since we are overwriting <code>pinctrl-0</code> property, we have to re-supply the previous channel pins, we do not have to re define them as they will be defined in the original <code>.dts</code> file.</p> <pre><code>/* zephyr/tests/drivers/misc/stm32_tsc/boards/stm32u083c_dk.overlay */\n#include &lt;zephyr/dt-bindings/misc/stm32-tsc-defines.h&gt;\n\n/ {\n    zephyr,user {\n        /* This will be used to trigger the SYNC pin high and low programmatically. They have to be connected with a jumper cable */\n        signal-gpios = &lt;&amp;gpioa 10 GPIO_ACTIVE_HIGH&gt;;\n    };\n};\n\n&amp;tsc {\n    status = \"okay\";\n\n    pinctrl-0 = &lt;&amp;tsc_shield_pb12 &amp;tsc_shield_cs_pb13 &amp;tsc_g6_io1_pd10 &amp;tsc_g6_io2_pd11 &amp;syncpin&gt;;\n    pinctrl-names = \"default\";\n\n    pulse-generator-prescaler = &lt;TSC_PG_PRESC_DIV128&gt;;\n\n    spread-spectrum;\n    spread-spectrum-prescaler = &lt;2&gt;;\n    spread-spectrum-deviation = &lt;10&gt;;\n\n    max-count-value = &lt;TSC_MCV_16383&gt;; \n\n    synced-acquisition;\n    syncpol-rising;\n};\n\n&amp;pinctrl {\n  syncpin: syncpin_pd2 {\n    pinmux = &lt;STM32_PINMUX('D', 2, AF9)&gt;;\n    drive-open-drain;\n  };\n};\n</code></pre> <p>This devicetree modification will make sure the driver will be utilized to its full extent.</p>"},{"location":"zephyr-device-driver/#testcaseyml","title":"testcase.yml","text":"<p>This file is searched when the test runner twister is run. There is a pretty comprehensive documentation on how to write this file.</p> <p>Here we will use a pretty simple one.</p> <pre><code># zephyr/tests/drivers/misc/stm32_tsc/testcase.yml\ntests:\n  drivers.misc.stm32_tsc:\n    tags: drivers misc stm32 tsc\n    filter: dt_compat_enabled(\"st,stm32-tsc\")\n  drivers.misc.stm32_tsc_poll:\n    tags: drivers misc stm32 tsc poll\n    filter: dt_compat_enabled(\"st,stm32-tsc\")\n    extra_args: CONFIG_STM32_TSC_INTERRUPT=n\n</code></pre> <p>We can define multiple tests in a single file and each will be built, flashed and run separately. In this case I've defined two tests with two different configurations. These tests are called <code>drivers.misc.stm32_tsc</code> and <code>drivers.misc.stm32_tsc_poll</code>. The first one will test the driver with interrupt enabled and the second one will test the driver with polling enabled. There are also properties like <code>tags</code> which twister uses to scope and run multiple tests and <code>filter</code> which is used to figure out if the test should be run or not. In this case the test will only run if the device tree node <code>st,stm32-tsc</code> is enabled.</p>"},{"location":"zephyr-device-driver/#test-cases","title":"Test Cases","text":""},{"location":"zephyr-device-driver/#test-setup","title":"Test Setup","text":"<p>We want to run a setup function before each test, and define out test suite first.</p> <pre><code>/* zephyr/tests/drivers/misc/stm32_tsc/src/main.c */\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n#include &lt;zephyr/drivers/misc/stm32_tsc/stm32_tsc.h&gt;\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/ztest.h&gt;\n\n#if DT_HAS_COMPAT_STATUS_OKAY(st_stm32_tsc)\n  #define TSC_NODE DT_INST(0, st_stm32_tsc)\n#else\n  #error \"Define a TSC device\"\n#endif\n\n#define ZEPHYR_USER_NODE DT_PATH(zephyr_user)\n\nconst struct gpio_dt_spec signal =\n  GPIO_DT_SPEC_GET(ZEPHYR_USER_NODE, signal_gpios);\n\nstatic void *stm32_tsc_setup(void)\n{\n  zassert_true(device_is_ready(DEVICE_DT_GET(TSC_NODE)), \"STM32 TSC device is not ready\");\n  zexpect_ok(gpio_pin_configure_dt(&amp;signal, GPIO_OUTPUT_INACTIVE), \"Failed to configure signal pin\");\n  return NULL;\n}\n\nZTEST_SUITE(stm32_tsc, NULL, stm32_tsc_setup, NULL, NULL, NULL);\n</code></pre> <p>You can return a special data struct to be used in your tests by returning it in the setup function. Also you can define a teardown function to run after each test. I kept them <code>NULL</code> for now.</p> <p>Please find more information about the <code>ztest</code> library in the Ztest documentation.</p>"},{"location":"zephyr-device-driver/#first-test-case","title":"First Test Case","text":"<p>A simple test case has the following structure;</p> <pre><code>ZTEST(test_suite_name, test_testname)\n{\n  /* Test code */\n}\n</code></pre> <p>By this definition lets keep the first test simple and just check if the device is ready (<code>stm32_tsc_init</code> function returns 0).</p> <pre><code>/* zephyr/tests/drivers/misc/stm32_tsc/src/main.c */\nZTEST(stm32_tsc, test_1_device_ready)\n{\n  zassert_true(device_is_ready(DEVICE_DT_GET(TSC_NODE)), \"STM32 TSC device is not ready\");\n}\n</code></pre>"},{"location":"zephyr-device-driver/#test-mmio","title":"Test MMIO","text":"<p>The first thing we will test is the <code>CR</code> register of the TSC peripheral, this register is where most of the configuration is done except for the group configurations, which we will test in the next test.</p> <pre><code>/* zephyr/tests/drivers/misc/stm32_tsc/src/main.c */\n#include &lt;soc.h&gt;\nZTEST(stm32_tsc, test_2_cr_reg)\n{\n TSC_TypeDef  *tsc = (TSC_TypeDef *)DT_REG_ADDR(TSC_NODE);\n volatile const uint32_t *tsc_cr = &amp;tsc-&gt;CR;\n const uint8_t   pgpsc = DT_PROP(TSC_NODE, pulse_generator_prescaler);\n const uint8_t   ctph = DT_PROP(TSC_NODE, ctph);\n const uint8_t   ctpl = DT_PROP(TSC_NODE, ctpl);\n const uint8_t   ssd = DT_PROP_OR(TSC_NODE, spread_spectrum_deviation, 0);\n const bool   spread_spectrum = DT_PROP_OR(TSC_NODE, spread_spectrum, false);\n const uint8_t   sscpsc = DT_PROP_OR(TSC_NODE, spread_spectrum_prescaler, 0);\n const uint8_t   max_count = DT_PROP_OR(TSC_NODE, max_count_value, 0);\n const bool   iodef = DT_PROP_OR(TSC_NODE, iodef_float, false);\n const bool   sync_pol = DT_PROP_OR(TSC_NODE, syncpol_rising, false);\n const bool   sync_acq = DT_PROP_OR(TSC_NODE, synced_acquisition, false);\n\n /* check charge transfer pulse high value (bits 31:28) */\n zassert_equal((*tsc_cr &amp; TSC_CR_CTPL_Msk) &gt;&gt; TSC_CR_CTPL_Pos, ctph - 1, \"CTPH value is not correct, expected %d, got %d\", ctph - 1, (*tsc_cr &amp; TSC_CR_CTPL_Msk) &gt;&gt; TSC_CR_CTPL_Pos);\n\n /* check charge transfer pulse low value (bits 27:24) */\n zassert_equal((*tsc_cr &amp; TSC_CR_CTPL_Msk) &gt;&gt; TSC_CR_CTPL_Pos, ctpl - 1, \"CTPL value is not correct, expected %d, got %d\", ctpl - 1, (*tsc_cr &amp; TSC_CR_CTPL_Msk) &gt;&gt; TSC_CR_CTPL_Pos);\n\n /* check spread spectrum deviation value (bits 23:17) */\n zassert_equal((*tsc_cr &amp; TSC_CR_SSD_Msk) &gt;&gt; TSC_CR_SSD_Pos, ssd, \"SSD value is not correct, expected %d, got %d\", ssd, (*tsc_cr &amp; TSC_CR_SSD_Msk) &gt;&gt; TSC_CR_SSD_Pos);\n\n /* check spread spectrum enable bit (bit 16) */\n if (spread_spectrum)\n  zexpect_true(*tsc_cr &amp; TSC_CR_SSE_Msk);\n else\n  zexpect_false(*tsc_cr &amp; TSC_CR_SSE_Msk);\n\n /* check spread spectrum prescaler value (bits 15) */\n if (sscpsc == 2)\n  zexpect_true(*tsc_cr &amp; TSC_CR_SSPSC_Msk);\n else\n  zexpect_false(*tsc_cr &amp; TSC_CR_SSPSC_Msk);\n\n /* check pulse generator prescaler value (bits 14:12) */\n zassert_equal((*tsc_cr &amp; TSC_CR_PGPSC_Msk) &gt;&gt; TSC_CR_PGPSC_Pos, pgpsc, \"PGPSC value is not correct, expected %d, got %d\", pgpsc, (*tsc_cr &amp; TSC_CR_PGPSC_Msk) &gt;&gt; TSC_CR_PGPSC_Pos);\n\n /* check max count value (bits 7:5) */\n zassert_equal((*tsc_cr &amp; TSC_CR_MCV_Msk) &gt;&gt; TSC_CR_MCV_Pos, max_count, \"MCV value is not correct, expected %d, got %d\", max_count, (*tsc_cr &amp; TSC_CR_MCV_Msk) &gt;&gt; TSC_CR_MCV_Pos);\n\n /* check I/O default mode bit (bit 4) */\n if (iodef)\n  zexpect_true(*tsc_cr &amp; TSC_CR_IODEF_Msk);\n else\n  zexpect_false(*tsc_cr &amp; TSC_CR_IODEF_Msk);\n\n /* check sync polarity bit (bit 3) */\n if (sync_pol)\n  zexpect_true(*tsc_cr &amp; TSC_CR_SYNCPOL_Msk);\n else\n  zexpect_false(*tsc_cr &amp; TSC_CR_SYNCPOL_Msk);\n\n /* check sync acquisition bit (bit 2) */\n if (sync_acq)\n  zexpect_true(*tsc_cr &amp; TSC_CR_AM_Msk);\n else\n  zexpect_false(*tsc_cr &amp; TSC_CR_AM_Msk);\n\n /* check start bit (bit 1) */\n zexpect_false(*tsc_cr &amp; TSC_CR_START_Msk);\n\n /* check TSC enable bit (bit 0) */\n zexpect_true(*tsc_cr &amp; TSC_CR_TSCE_Msk);\n}\n</code></pre> <p>This is a lenghty test, but it is just checking if the values in the device tree are set correctly in the <code>CR</code> register of the TSC peripheral.</p> <p>To test the group configurations, we need to test the registers like <code>IOCCR</code>, <code>IOSCR</code> and <code>IOGCSR</code> of the TSC peripheral.</p> <pre><code>/* zephyr/tests/drivers/misc/stm32_tsc/src/main.c */\nZTEST(stm32_tsc, test_3_group_registers)\n{\n TSC_TypeDef  *tsc = (TSC_TypeDef *)DT_REG_ADDR(TSC_NODE);\n volatile const uint32_t *tsc_iohcr = &amp;tsc-&gt;IOHCR;\n volatile const uint32_t *tsc_ioscr = &amp;tsc-&gt;IOSCR;\n volatile const uint32_t *tsc_ioccr = &amp;tsc-&gt;IOCCR;\n volatile const uint32_t *tsc_iogcsr = &amp;tsc-&gt;IOGCSR;\n\n#define GET_GROUP_BITS(val) (uint32_t)(((val) &amp; 0x0f) &lt;&lt; ((group - 1) * 4))\n\n#define STM32_TSC_GROUP_TEST(node)                                                                                                                                                                                                         \\\n do                                                                                                                                                                                                                                 \\\n {                                                                                                                                                                                                                                  \\\n  const uint8_t group = DT_PROP(node, group);                                                                                                                                                                                \\\n  const uint8_t channel_ios = DT_PROP(node, channel_ios);                                                                                                                                                                    \\\n  const uint8_t sampling_io = DT_PROP(node, sampling_io);                                                                                                                                                                    \\\n  const bool    use_as_shield = DT_PROP(node, use_as_shield);                                                                                                                                                                \\\n                                                                                                                                                                                                                                           \\\n  /* check schmitt trigger hysteresis for enabled I/Os */                                                                                                                                                                    \\\n  zassert_equal((*tsc_iohcr &amp; GET_GROUP_BITS(channel_ios | sampling_io)), 0, \"Schmitt trigger hysteresis not disabled, expected %d, got %d\", 0, (*tsc_iohcr &amp; GET_GROUP_BITS(channel_ios | sampling_io)));                   \\\n                                                                                                                                                                                                                                           \\\n  /* check channel I/Os */                                                                                                                                                                                                   \\\n  zassert_equal((*tsc_ioccr &amp; GET_GROUP_BITS(channel_ios)), GET_GROUP_BITS(channel_ios), \"Channel I/Os value is not correct, expected %d, got %d\", GET_GROUP_BITS(channel_ios), (*tsc_ioccr &amp; GET_GROUP_BITS(channel_ios))); \\\n                                                                                                                                                                                                                                           \\\n  /* check sampling I/O */                                                                                                                                                                                                   \\\n  zassert_equal((*tsc_ioscr &amp; GET_GROUP_BITS(sampling_io)), GET_GROUP_BITS(sampling_io), \"Sampling I/O value is not correct, expected %d, got %d\", GET_GROUP_BITS(sampling_io), (*tsc_ioscr &amp; GET_GROUP_BITS(sampling_io))); \\\n                                                                                                                                                                                                                                           \\\n  /* check enabled groups */                                                                                                                                                                                                 \\\n  if (use_as_shield)                                                                                                                                                                                                         \\\n   zassert_not_equal((*tsc_iogcsr &amp; BIT(group - 1)), BIT(group - 1), \"Group %d is a shield group and should not be enabled\", group);                                                                                  \\\n  else                                                                                                                                                                                                                       \\\n   zassert_equal((*tsc_iogcsr &amp; BIT(group - 1)), BIT(group - 1), \"Group %d is not enabled\", group);                                                                                                                   \\\n } while (0);\n\n DT_FOREACH_CHILD_STATUS_OKAY(TSC_NODE, STM32_TSC_GROUP_TEST);\n}\n</code></pre>"},{"location":"zephyr-device-driver/#api-tests","title":"API Tests","text":"<p>The first test will be to test the polling function of the driver. For this the setting <code>CONFIG_STM32_TSC_INTERRUPT</code> needs to be set to <code>n</code> before building the application which is what we did in the testcase.yml file.</p> <p>But this test case will run regardless of any Kconfig settings, so we need to skip the test if the interrupt is enabled.</p> <pre><code>/* zephyr/tests/drivers/misc/stm32_tsc/src/main.c */\nZTEST(stm32_tsc, test_4_acquisition_polling)\n{\n Z_TEST_SKIP_IFDEF(CONFIG_STM32_TSC_INTERRUPT);\n\n const struct device *tsc_dev = DEVICE_DT_GET(TSC_NODE);\n TSC_TypeDef  *tsc = (TSC_TypeDef *)DT_REG_ADDR(TSC_NODE);\n volatile const uint32_t *tsc_cr = &amp;tsc-&gt;CR;\n volatile const uint32_t *tsc_ier = &amp;tsc-&gt;IER;\n volatile const uint32_t *tsc_isr = &amp;tsc-&gt;ISR;\n\n stm32_tsc_start(tsc_dev);\n\n /* this should timeout because sync pin is not triggered */\n zexpect_not_ok(stm32_tsc_poll_for_acquisition(tsc_dev, K_MSEC(100)));\n\n stm32_tsc_start(tsc_dev);\n\n zexpect_ok(gpio_pin_toggle_dt(&amp;signal));\n\n /* check if interrupts are disabled */\n zexpect_false(*tsc_ier &amp; TSC_IER_EOAIE_Msk);\n zexpect_false(*tsc_ier &amp; TSC_IER_MCEIE_Msk);\n\n /* test CR register start bit */\n zexpect_true((*tsc_cr &amp; TSC_CR_START_Msk) &gt;&gt; TSC_CR_START_Pos);\n\n zexpect_ok(stm32_tsc_poll_for_acquisition(tsc_dev, K_MSEC(100)));\n\n /* test for max count error flag */\n zexpect_false((*tsc_isr &amp; TSC_ISR_MCEF_Msk) &gt;&gt; TSC_ISR_MCEF_Pos);\n\n uint32_t value;\n zexpect_ok(stm32_tsc_read(tsc_dev, 6, &amp;value));\n}\n</code></pre> <p>The next test will be to test the interrupt driven acquisition. This test will run only if the <code>CONFIG_STM32_TSC_INTERRUPT</code> is enabled.</p> <pre><code>static volatile bool tsc_input_received;\n\nstatic void      tsc_input_callback(struct input_event *evt, void *user_data)\n{\n ARG_UNUSED(evt);\n ARG_UNUSED(user_data);\n\n tsc_input_received = true;\n}\nINPUT_CALLBACK_DEFINE(DEVICE_DT_GET(TSC_NODE), tsc_input_callback, NULL);\n\nZTEST(stm32_tsc, test_5_acquisition_interrupt)\n{\n Z_TEST_SKIP_IFNDEF(CONFIG_STM32_TSC_INTERRUPT);\n\n TSC_TypeDef  *tsc = (TSC_TypeDef *)DT_REG_ADDR(TSC_NODE);\n volatile const uint32_t *tsc_cr = &amp;tsc-&gt;CR;\n volatile const uint32_t *tsc_ier = &amp;tsc-&gt;IER;\n volatile const uint32_t *tsc_isr = &amp;tsc-&gt;ISR;\n\n tsc_input_received = false;\n\n stm32_tsc_start(DEVICE_DT_GET(TSC_NODE));\n\n /* test CR register start bit */\n zexpect_true((*tsc_cr &amp; TSC_CR_START_Msk) &gt;&gt; TSC_CR_START_Pos);\n\n /* check if interrupts are enabled */\n zexpect_true(*tsc_ier &amp; TSC_IER_EOAIE_Msk);\n zexpect_true(*tsc_ier &amp; TSC_IER_MCEIE_Msk);\n\n k_sleep(K_MSEC(100));\n\n /* test ISR register max count error flag */\n zexpect_false((*tsc_isr &amp; TSC_ISR_MCEF_Msk) &gt;&gt; TSC_ISR_MCEF_Pos);\n\n /* this should fail because of the sync pin */\n zexpect_false(tsc_input_received);\n\n zexpect_ok(gpio_pin_toggle_dt(&amp;signal));\n\n k_sleep(K_MSEC(100));\n\n zexpect_true(tsc_input_received);\n}\n</code></pre> <p>Here in this test a 100ms window is given to allow TSC peripheral to start acqusition and put the value to the input subsystem. The <code>tsc_input_callback</code> function is defined to set a flag when an input event is received.</p> <p>Notice how we use <code>signal</code> and <code>gpio_pin_toggle_dt</code> to mock and test the presence and absence of an external trigger for the TSC peripheral.</p>"},{"location":"zephyr-device-driver/#running-the-tests","title":"Running the Tests","text":"<p>We will use the west extension commands to use twistter and run the tests.</p> <pre><code>west twister -T tests/drivers/misc/stm32_tsc --device-testing --device-serial COM4 -p stm32u083c_dk\n</code></pre> <p>In this command we first select a specific test suite with <code>-T</code> flag, then we enable the device testing with <code>--device-testing</code> flag, and then we select the serial port with <code>--device-serial</code> flag and finally we select the board with <code>-p</code> flag, which stands for platform.</p> <p>Note</p> <p>A physical connection with a jumper between PA10 and PD2 should be made before running the tests.</p> <p>Twister will upload this and read the output from the serial port and let us know how it went. But for the fun of it, we can connect to the serial port with a terminal emulator and see the output.</p> <pre><code>---- Opened the serial port COM4 ----\n*** Booting Zephyr OS build 6aae5648ff4d ***\nRunning TESTSUITE stm32_tsc\n===================================================================\nSTART - test_1_device_ready\n PASS - test_1_device_ready in 0.001 seconds\n===================================================================\nSTART - test_2_cr_reg\n PASS - test_2_cr_reg in 0.001 seconds\n===================================================================\nSTART - test_3_group_registers\n PASS - test_3_group_registers in 0.001 seconds\n===================================================================\nSTART - test_4_acquisition_polling\n SKIP - test_4_acquisition_polling in 0.001 seconds\n===================================================================\nSTART - test_5_acquisition_interrupt\n PASS - test_5_acquisition_interrupt in 0.201 seconds\n===================================================================\nTESTSUITE stm32_tsc succeeded\n\n------ TESTSUITE SUMMARY START ------\n\nSUITE PASS - 100.00% [stm32_tsc]: pass = 4, fail = 0, skip = 1, total = 5 duration = 0.205 seconds\n - PASS - [stm32_tsc.test_1_device_ready] duration = 0.001 seconds\n - PASS - [stm32_tsc.test_2_cr_reg] duration = 0.001 seconds\n - PASS - [stm32_tsc.test_3_group_registers] duration = 0.001 seconds\n - SKIP - [stm32_tsc.test_4_acquisition_polling] duration = 0.001 seconds\n - PASS - [stm32_tsc.test_5_acquisition_interrupt] duration = 0.201 seconds\n\n------ TESTSUITE SUMMARY END ------\n\n===================================================================\nRunID: 54191c69b895b72ac69c072ecf65e1d0\nPROJECT EXECUTION SUCCESSFUL\n</code></pre> <p>Looks like everything is working just fine. Perfect!</p>"},{"location":"zephyr-device-driver/#wrapping-up","title":"Wrapping Up","text":"<p>We've implemented the driver and tested it on the hardware. This is now complete as a driver but still not usable as is, in a future post I'll implement a library that uses this driver to generate input events that are usable (like actual clicks), instead of using the capture value and putting it in the input subsystem, which is not the ideal use of this subsystem at the moment.</p>"}]}